{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "PrivateRegister",
  "functions": [
    {
      "name": "add_credential_note",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "flag",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "claim",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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vlD9wtUn66tcfbK+ytUn66tcfbK+wlnfQtZXuPorWV/l6pP1Va4+WV/l6pP1FZ75V6H6hatP1le5+mR9latP1le5+mR9latP1le4+kLWV7n6ZH2Vq0/WVzjrE7K+ytUXql+4+mR9latP1le5+mR9lWd+sr7K1SfrK1z9jayvcvXJ+ipXn6yvcvXJ+ipXX6h+4eqT9VWuPllf4axvI+urXH2yvsrVJ+srXP2drK9y9cn6Cs/8O1lf5eqT9VWuvlD9wtUn66tcfbK+ytUn66tcfbK+ytUn6ytc/YOsr3DWd5D1Va4+WV/l6pP1Va6+UP3C1Sfrqzzzk/VVrj5ZX+Xqk/VVrj5ZX+Hqn2R9latP1le5+mR9latP1le5+kL162Z9J1lf5eqT9VWuPllf5eqT9VWuPllf4Zn/IuurXH2yvsrVJ+urXH2yvsrVF6pfuPpkfZWrT9ZXufpkfZWrT9ZXOOu7yPrqVn+ZyPoqV5+sr3L1yfoqV5+sr+7Mv0xC9QtXn6yvcvXJ+ipXn6yvcvXJ+ipXn6yvcPVnsr7K1Sfrq1x9sr7CWd9M1le5+kL1C1efrK9y9cn6KlefrK/yzE/WV7n6ZH2Fq7+Q9VWuPllf5eqT9VWuPllf5eoL1S9cfbK+ytUn6yuc9S1kfZWrT9ZXufpkfYWrv5L1Va4+WV/hmX8l66tcfbK+ytUXql+4+mR9latP1le5+mR9latP1le5+mR9hasvZH2Fsz4h66tcfbK+ytUn66tcfaH6hatP1ld55ifrq1x9sr7K1Sfrq1x9sr7C1d/I+ipXn6yvcvXJ+ipXn6yvcvWF6tfN+jayvsrVJ+urXH2yvsrVJ+urXH2yvsIz/07WV7n6ZH2Vq0/WV7n6ZH2Vqy9Uv3D1yfoqV5+sr3L1yfoqV5+sr3DWt5P1Fa7+QdZXufpkfZWrT9ZXufpkfYVn/kOofuHqk/VVrj5ZX+Xqk/VVrj5ZX+Xqk/UVrv5J1le5+mR9latP1lc46zvJ+ipXX6h+4eqT9VWuPllf5eqT9VWe+cn6KlefrK9w9S+yvsrVJ+urXH2yvsrVJ+urXH2h+oWrT9ZXufpkfYWzvousr3L1yfoqV5+sr27114msr3L1yfrqzvzrRNZXufpkfZWrL1S/cPXJ+ipXn6yvcvXJ+ipXn6yvcvXJ+gpXfybrK5z1zWR9latP1le5+mR9lasv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/tz337frX+bl/fqTv56uvf5+7r+P15/8/nvMx/3g83qw/uT33+b6k99/m+tPfv9trj/5/be5/uT33+b6k99/m+tPfv9trT/56+na609+/22uv/P7b/LX07XX3/n9N/nr6bZznW4HX/vZ+NNy3U/27U+ZjuvlXJPfq03PNfl93fRck88ApueafF6wPNfkr96zPdfkc4jpuSafWUzPNfl8Y3quMtC5PsVdt4PlfHCuI81NrXMdaW5qnetIc1PrXEeam1rnOtLc1DjX5K9MtD3Xkeam1rmONDe1znWkuWnb7nPT+WBuSv6KR9tzHWpuapzrUHNT41yHmpsa5zrU3NQ416Hmpo/PNfmrLm3Pdai5qXGuQ81NjXMtNDclfzXnR+f6vP5+Z6Hn9fc73zyvP/fMsk/TbSH7us8P1p97DmmvP/ds0Vx/8ldzttefewZorz/3fb29/tz36vb6c99/2+vPff9trz/3/be9/s7vv8lfzdlef9/33y35qznb6+/7/rslfzVne/1933+3qe/775b81Zzt9fd9/92Sv5qzvf6+779b8ldzNtef/NWc7fV3fv9N/mrO9vo7v/8mf9Vle/2d33+Tvzmyvf7O77/J38PYXn/n99/kbzVsr7/z+2/yNwq219/5/Tf5u//a6+/8/pv83X/t9Xd+/03+7r/2+ju//yZ/9197/Z3ff5O/+6+9/s7vv8nf/ddef+f33+Tv/muvv/P7b/J3/7XX3/n9N/m7/9rr7/z+m/zdf+31d37/Tf7uv/b6O7//Jn/3X3v9nd9/k7/7r73+zu+/yd/9115/5/ff5O/+a6+/8/tv8nf/tdff+f03+fv82uvv/P6b/L177fV3fv9N/n689vo7v/8mf49de/2d33+Tv2+uvf7O77/J3wvXXn/n99/k729rr7/z+2/y96y119/5/Tf5+9Da6+/8/pv8vWXt9Xd+/03+frH2+ju//yZ/D1h7/Z3ff5O/r6u9/s7vv8nfq9Vef+f33+Tvv2qvv/P7b/L3X7XX3/n9t/P3X22dv/9q6/z9V1vn77/aOn//1db5+6+2zt9/tXX+/qut8/dfbZ2//2rr/P1XW+fvv9o7f//V3vn7r/bO33+1d/7+q33q+/67d/7+q73z91/tnb//as/+/is5bwfv27w8WH/y++963Pk//YeNP31O8nLwub7us7yc04Njr/P2h6/r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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "read_all_credentials",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "addr",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "std::collections::bounded_vec::BoundedVec",
            "fields": [
              {
                "name": "storage",
                "type": {
                  "kind": "array",
                  "length": 10,
                  "type": {
                    "kind": "struct",
                    "path": "credential_notes::CredentialNotes",
                    "fields": [
                      {
                        "name": "owner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "claim_type",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 8
                        }
                      },
                      {
                        "name": "claim_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "randomness",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "len",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "read_all_credentials"
      ]
    },
    {
      "name": "read_root",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "addr",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "root_struct::RootStruct",
            "fields": [
              {
                "name": "root",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "owner",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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RH26c3VVY71Hoj7dubqqsd4jUZ/uXF3VWO+RqE93rq5qrPdI1Kc7V1c12JshqtOdq6sa7O0N1enO1VUN9oaF6nTn6qoGewtCdbpzdVWDvamgOt25uqrB3iZQne5cXdVgbxOoTneurmqwtwlUpztXVzXa2wRq052rqxptd/7adOfqqkbb7b423bm6qtF2j69Nd66uarTd2GvTnaurGm1389p05+qqRtstvDbdubqqMldXVebqqubaWz3Mtbd6mGtv9TDX3uphrr3Vw1x7q4e59lYPc+2tLnPtrS5z7a0uc+2tLqPtrf6y9xzF7Vi3/JrV3cFXjgLHJhx5J2EbjryUsA1H3krYhiOvJWzCcbQt6B9zvE53mtd3X6c7zWu2r9Odpvm8Tlfmmu40rdx1utN0XNfpTtMYXac7Tf9yne40rz/+Pd3RtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423am6qnW0Lehr052qq1pH24K+Nt2puqp1kbmmO1VXtc6z7/p1ulN1Ves8u5hfpztXVzXX3urrXHurr3Ptrb4Otrd6DGWbbl5C5U//6IULeZthKZ+PvWIUMLbAOFYXqIZxrO7ydRifv0VlHWzzej2OY/XDehzHarTVOA62j78ex7GsgR7HsTxH3v+0ZKlxTDF8HJzSbYbiP8iMZU9akhHIPCAzlol4QuY63bGa/ep0x+rJq9Mdq3WuTnesDrc23cFefVCd7lD94iX0W7eDXTzIVsd69UF9ukP1avXpylzTHaqrqk93qK6q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",
      "brillig_names": [
        "read_root"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "verify_note_in_merkle_tree",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "claim_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "siblings",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "indices",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "expected_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11358519862625644973": {
            "error_kind": "string",
            "string": "Merkle root verification failed"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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b/z8W/1dxUrrb/z82/DNv97X3/j5t+Fbab2vv/Hzb8M3pnpff+Pn38bvf2WN3//KGr//ldV+/6sY8n39aQqFl/7VjeXSfYc5fz72nUvl5/XLuFTeL1zGpfI+5Dgu39+g0Wq/wdh1YCrvnK4DU3lLdhmY2u+1dh2YypvI68BU3p2m9aUtWQnMEsPHwcsS12PNf2y18kZWuVUbZ6uVt5vfbPV9/ZW3hcX1V969FddfeZNVXH/lvVBp/bXfnq64/ro7i9nZfD/YxY3xTuW3pyuvv+6zenn9dZ+qy+uv+/xbXn/d59/y+us+/5bXX/f5t7z+us+/xfVXfnu65/V75zfW3875d3v97Zx/t9df+fl3cct6cMob66/8/Ftcf+Xn3+L6Kz//Ftdf+fm3uP7Kz7/F9Vd+/i2tv/Lb05XXX/n5t7j+ys+/xfU3fv6t/PZ05fU3fv6t/PZ0cwrT/eAcU+GlLa+bff4q05I/9lr5uVq618rP69K9Vt4DKPda+e30tHutvLeQ7rXyPkS618p7FulebaC9Vt4L/Wqvt3HX/WBLG3vtqW8q7bWnvqm01576ptJee+qbCnut/DaI2r321DeV9tpT31Taa099U2mv1tNe57VvSht9U+W3eNTutau+qbDXrvqmwl676psKe+2qb/p2r3Plt6/U7rWrvqmw1676psJeu+qbCnu1gfbabt/0vv52e6H39bfb37yvv+6eJU7TfSExRLex/rr7kOL6K781Z3n9dfcL5fXX3QOU11/3eb28/rrP1eX1133+La+/7vNvef11n3/L62/8/Fv5rTmL66/81pzl9Td+/q381pzl9Td+/q381pzl9Td+/q381pzl9Td+/q381pzl9Td+/q381pzl9Td+/q381pzl9Td+/q38Fprl9Td+/q38lpTl9Td+/q38Bo/l9Td+/q38donl9Td+/q385oPl9Td+/q38NoHl9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q383n/l9Td+/q38Hn3l9Td+/q38Xnrl9Td+/q38nnfl9Td+/q383nTl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0POZ46HnM8dDz2eOh57PHA89m3me8NDzmeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2fu8NDzmeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2fu8dDzmeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2ce8NDzmeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2dueOj5zPHQ85njoeczx0PPZ24wP505Hno+czz0fOZ46PnM8dDzmeOhpzOf8dDzmeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2ce8dDzmeOh5zPHQ89njoeez9xgfjpzPPR85njo+czx0POZ46HnM8dDT2e+4KHnM8dDz2eOh57PHA89n7nB/HTmeOj5zPHQ85njoeczx0PPZ46Hns484aHnM8dDz2eOh57PHA89n7nB/HTmeOj5zPHQ85njoeczx0PPZ46Hns4846HnM8dDz2eOh57PHA89n7nB/HTmeOj5zPHQ85njoeczx0PPZ46Hnsw8TBMeej5zPPR85njo+czx0POZG8xPZ46Hns8cDz2fOR56PnM89HzmeOjpzB0eej5zPPR85njo+czx0POZG8xPZ46Hns8cDz2fOR56PnM89HzmeOjpzD0eej5zPPR85njo+czx0POZG8xPZ46Hns8cDz2fOR56PnM89HzmeOjpzAMeej5zPPR85njo+czx0POZG8xPZ46Hns8cDz2fOR56PnM89HzmeOjpzA0PPZ85Hno+czz0fOZ46PnMDeanM8dDz2eOh57PHA89nzkeej5zPPR05jMeej5zPPR85njo+czx0POZG8xPZ46Hns8cDz2fOR56PnM89HzmeOjpzCMeej5zPPR85njo+czx0POZG8xPZ46Hns8cDz2fOR56PnM89HzmeOjpzBc89HzmeOj5zPHQ85njoeczN5ifzhwPPZ85Hno+czz0fOZ46PnM8dDTmSc89HzmeOj5zPHQ85njoeczN5ifzhwPPZ85Hno+czz0fOZ46PnM8dDTmWc89HzmeOj5zPHQ85njoeczN5ifzhwPPZ85Hno+czz0fOZ46PnM8dCzmbsJDz2fOR56PnM89HzmeOj5zA3mpzPHQ89njoeezxwPPZ85Hno+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",
      "brillig_names": [
        "discover_new_messages",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "update_verification_root",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "new_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHxgAAwACgEguCIBIAAElAAAARSUAAABpKAIAAQSASScCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAlgeAgACAB4CAAMAMzgAAgADAAQkAgAEAAAAjSUAAAKBHgIAAgEnAgMAAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBS0MBQYtDgMGACgGAgYtDgMGACgGAgYtDgMGLQ0EBQAoBQIFLQ4FBCsCAAUAAAAAAAAAAAIAAAAAAAAAAC0IAQYnAgcEBQAQAQcBJwMGBAEAKAYCBy0MBwgtDgMIACgIAggtDgMIACgIAggtDgMIACgIAggtDgUILQ0EBQAoBQIFLQ4FBC0NBgUAKAUCBS0OBQYtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4KgEUABi0IAQcAAAECAS4KgEQABycCCAABJwIJBAotCAAKLQwFCy0MBAwtDAYNLQwHDi0MCA8AEAAJACUAAAKTLQQAACcCCQQKLQgACi0MBQstDAQMLQwGDS0MBw4tDAIPABAACQAlAAACky0EAAAtDQcCCygAAoBEAAkkAgAJAAAB8CcCCgQAPAkBCicCAgQJLQgACS0MBQotDAQLLQwGDC0MBw0AEAACACUAAAO8LQQAAC0NBAIBKAACgEcABS0NBQQKOAQDAgsoAAKARAADJAIAAwAAAkElAAAEzx4CAAIBMAwAAQAEADgECAEwDAACAAEmKACABAR4AA0AAACABIADJACAAwAAAoAqAQABBfeh86+lrdTKPAEBAiYqAQABBb4eP/8+pPb6PAEBAiYlAAACWC0NAwYtDQQHCygAB4BEAAgkAgAIAAACuScCCQQAPAkBCQsoAAaAQwAHJAIABwAAA0gjAAACzi0NAQYtDQIHLQ0DCC0NBAkNKAAIgEMACiQCAAoAAALzJQAABOEuBAAGgAMoAIAEBAAEJQAABPMuCIAFAAoAKAoCCwA4CwgMLQ4FDAEoAAiARwAFDjgIBQYkAgAGAAADMyUAAAWBLQ4KAS0OBwItDgUDLQ4JBCMAAAO7JwIGBActCAAHLQwBCC0MAgktDAMKLQwECwAQAAYAJQAAA7wtBAAALQ0BBi0NAgctDQQILgQABoADKACABAQABCUAAATzLgiABQAJACgJAgoBKAAKgEUACy0OBQstDgkBLQ4HAi4KgEcAAy0OCAQjAAADuyYlAAACWC4IgEUABSMAAAPMDSgABYBDAAYkAgAGAAAEPCMAAAPhLQ0BBS0NAgYtDQMHLQ0ECCcCCQQELQgBCicCCwQFABABCwEnAwoEAQAoBgILJwIMBAQAKAoCDT8PAAsADS0NCgYAKAYCBi0OBgotDgUBLQ4KAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWARwAGJAIABwAABFojAAAExi0NAQctDQIILQ0DCS0NBAoAKAgCDAA4DAUNLQ0NCwAoBwINADgNBQ4tDQ4MADgLDA0uBAAIgAMoAIAEBAAFJQAABPMuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAExi0MBgUjAAADzCoBAAEFAtxuJ4B2Ep08AQECJioBAAEFxWvEWg4QAAI8AQECJi4BgAOABgsAgAYAAoAHJACABwAABQ4jAAAFGS4AgAOABSMAAAWALgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABWwuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAABTsoAYAFBAABAwCABgACgAYjAAAFgCYqAQABBUWnynEZQeQVPAEBAiY=",
      "debug_symbols": "7Z3dbuo4EMffhWsuPPbYHvdVjlYVbTkVEoKK0pVWVd99TZcktJngZZz9OPLctFD874x/cTzjIYnfF0/rh7fn+83u5/51cffjfbHdP66Om/0uv3v/WC4eDpvtdvN8f/nnhTn9ADCfgteX1e70/vW4OhwXd+As+uVivXs6vXZk8j/5udmuF3cpfizHzY21XWuDdmiMTGNMJp4bY4LQNw6WaUyIdG5MGPCy8W/L7L2fxfuUutYA6d/z3s7D3lPPngrswcfOewjOXfc+eYfnxinrRt7TzN6D/eL9yYYL/7wNBM6Gxb7z2dgg8sBY8IbMuXF+SYVB4aFznrwz37Fi4N0B6t25OHCsO2CCGwb00Bh8YMdE6P6zGfrpgJi2MfXgY0pDa0ucH853swJenCnWcG0tJOjcsCYVWnvbnbGXBE9tTwg9KMJahF4RViIMRhHWItRRWIsw6iisRqijsBphUoSVCMkpwlqEpAgrESarCGsRRkVYhzD/UoRlhH0H/UXpqUeoSU0tQtDUuhohKsIywtTVbAP4EUKnJ3I1Ql2d1CJEPZGrEeoorEXodRRWI9RRWIswaKWmGqGukWsRRq3UVCPUr+JrEZJWaqoR6gKvFmHSSk01QlSE3xB+YtGvlBgszmgKzGLRtJbDApoksFg0/eSwWA3mLBYN0CwWrWdxWJwGaBaLBmgOC2oticWiAZrD4jVAs1i0jsNhCZr8s1h0tHBY9HYGHkujkchSd5modRd+dFha/fahhEVHC4el1W8JSlhQsXBYGq38X8eCptGlYgmLTrkcllYvoS9haTT5L2BptfJfwqIBmsXSaOW/gKXVyn8JS6OV/wIW1BU0i0UDNItFp1wOi9cpl8WiK2gOS6u3j5SwNBqgI/RuxG+PQrit9QlibDSc3wQRQuie5ggh0hhio1FuVoikp3M9xFafxjMvxEZLs7dBjLHvYUyj6OxbfSLPvBAbXVXOC1Gjcz1EaHQNMi9ETXHqIVoNLDNA1BSnHqLTkTgDRE1xZoCoKc7fgJhMv6tLsmOIqNG5HuIcO20A9buzWPQFiN6nbjEfyA4PlARjOIyhu2o6Xiz8Ifi/nA+/sPMBf2Hn53g20X/nPD9x5E51zmdj152fcb8gTxMsw8Cy5A6g6ToMaOOXHjP+WOp6Ss5gwXlDvfPgwvXGAMH0+4hBQDfqK/2/+9rvI0Zgv+/25ZNr5kAFfnb6sk1cGD1jJgSSqPjJJMfjvuoLOKr6BjIiFUlU/JEvqiKvCgN5GtGIMLErW/9wn/xyZCtaK1IFicoZkQolKhT1y4s85O/vBG/7o5xzzpGKv/2xqCKJKjqRKklUhCKVyNbE+eVDn7t6Gt0zRwZEqiBRAYpUSaKyIho2SlROxBAnzq9hreEsjVVepEoSFX/FVlEVJaqJGaCkEtGIIvJRZktEnkTkSUQ+TZBH7FU+jlVRoEoGRaokUU3tintdNbUbbUFFEpWTxOXkJPlGQiNSiWzxuWhOQ7r1JIaRho9eQwEo+bEdfgxe1eSlLkhEXiJKgkQeDKBMRiLZRJwsymTWnMyak1lDmTWUWfOy4+Zl1oKsb/z1o0UZf8VkWeZlMtmJwyfbV6edLGLxD9ubJ8uIBJNVLo3j7ZYABO4Bv44tiYJAxK9iCyCcYDIFlFji92NJfe0gRc+IkkDkJZb4U/+iT5woSMZeSAIR/ziVgohAIhIE8olNGEsigSUrSRmsJGWwRnCcLNw6Ij7y299Xh83qYbt+zZLTp2+7x+Nmvzu/Pf7x0n3ycNhst5vn+5fD/nH99HZY32/3j6fPFub840cu2S5tNJ9TY36bKS9z5feT9+nTCPlTl61my38C",
      "brillig_names": [
        "update_verification_root"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "init_credential_note",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "flag",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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/tWd3r+60/tXd3r/6k6/Xt23ly3XXrZee9l27WX50stkuvaycO1l8drL0rWXybWXXasSuVYlcq1K5FqVyLUqma9VyXytSuZrVTJfq5L5WpXM16pkvlYl87Uqma9VyXytSpZrVbJcq5LlWpUs16pkuVYly7UqWa5VyXKtSpZrVbJcq5L1WpWs16pkvVYl67UqWa9VyXqtStZrVbJeq5L1WpWs16pku1Yl27Uq2a5VyXatSrZrVbJdq5LtWpVs16pku1Yl27UqydeqJF+rknytSvK1KsnXqiRfq5J8rUrytSrJ16okX6qSPE3XXhauvSxee1m69jK59rL52suWay9br71su/aya1USrlVJuFYl4VqVhGtVEq5VSbhWJeFalYRrVRKuVUm4ViXxWpXEa1USr1VJvFYl8VqVxGtVEq9VSbxWJfFalcRrVZKuVUm6ViXpWpWka1WSrlXJtew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvO17DVfy17ztew1X8te87XsNV/LXvOl7HWeLmWvHy8L114Wr70sXXuZXHvZfO1ly7WXrddetl172bUqCdeqJFyrknCtSsK1KgnXqiRcq5JwrUrCtSoJ16rkJHvN+4/3wkfI8f1lZ9nruu4vy/HLy45OnFV6nsXHcIKv4URfw0m+hiO+hjP7Gs7iazirr+FsvoaTXQ0n+fpWTr6+lZOvb+Xk61s5+fpWTr6+lZOvb+Xk61s5WX8r//gopo/xZF/jkcnZeIKz8URn40nOxvPr7+bby+ZrL1uuvezwOymG7X6ER4xhLkALy5r2p/su6/I4WOfw4b5buh8ik6bnQ3im46NAp/0ArI/v8/3qLX+Of3M+/nm6C7DMKX0ff257/Mc31xsaf2h8/LHx8afGxy+Nj39ufPxL4+P3vv+Wxt/4/js3vv8uje+/S+P779L4/rs0vv8uje+/S+P779L4/rs0vv8uje+/S+P779r4/rs2vv+uje+/a+P779r4/rs2vv+uje+/a+P779r4/rs2vv9uje+/W+P779b4/rs1vv9uje+/W+P779b4/rs1vv9uje+/W+P7b258/82N77+58f03N77/5sb339z4/psb339z4/tvbnz/zW3vv2Fqe/8NU9v7b5ja3n/D1Pb+G6a2998wtb3/hqnt/TdMbe+/YWp7/w1T4/tvaHz/DY3vv6Hx/Tc0vv+Gxvff0Pj+Gxrff0Pj+29ofP8Nje+/sfH9Nza+/8bG99/Y+P4bG99/Y+P7b2x8/42N77+x8f03Nr7/psb339T4/psa339T4/tvanz/TY3vv6nx/Tc1vv+mxvff1Pj+K43vv9L4/iuN77/S+P4rje+/0vj+K43vv+7PvyqNv/H9t/Hzr0Lj51+Fxs+/Co2ffxUaP/8qNH7+VWj8/KvQ+PlXofHzr0Lj51+Fxs+/Co2ffxUaP/8qNH7+VWj8/KvQ+PlXofHzr0Lj51+Fxs+/Co2ffxUaP/8qNH7+VWj8/KvQ+PlXofHzr0Lj51+Fxs+/Co2ffxUaP/8qNH7+VWj8/KvQ+PlXofHzr0Lj51+Fxs+/Co2ffxUaP/8qNH7+VWj8/KvQ+PlXofHzr0Lj51+Fxs+/Co2ffxUaP/8qNH7+VWj8/KvQ+PlXofHzr0Lj51+Fxs+/io2ffxUbP/8qNn7+VWz8/Ks4tb3/xsbPv4qNn38VGz//KjZ+/lVs/Pyr2Pj5V7Hx869i4+dfxcbPv4qNn38VGz//KjZ+/lVs/Pyr2Pj5V7Hx869i4+dfxcbPv4qNn38VGz//KjZ+/lVs/Pyr2Pj5V7Hx869i4+dfxcbPv4qNn38VGz//KjZ+/lVs/Pyr2Pj5V7Hx869i4+dfxcbPv4qNn38VGz//KjZ+/lVs/Pyr2Pj5V7Hx869i4+dfxcbPv4qNn38VGz//KjZ+/lVs/Pyr6P38q3WW+Hn1ukzL8/i/X5zS/dokT4OOB5fOy3wf8rxOTxen6WjMOe/vPE3bl6tvGJ23Aa1gdN6NtILReVPUCkYBowZG5y1iKxidd6qtYHTeMLeC0Xnf3gpG5/ahEYzeTxFsBSMuRgUjLkYFIy5GBaOAUQMjLkYFIy5GBSMuRgUjLkYFIy5GA6P3s1hbwYiLUcGIi1HBiItRwShg1MCIi1HBiItRwYiLUcGIi1HBiIvRwOj9ROtWMOJiVDDiYlQw4mJUMAoYNTDiYlQw4mJUMOJiVDDiYlQw4mI0MHp/LkArGHExKhhxMSoYcTEqGAWMGhhxMSoYcTEqGHExKhhxMSoYcTEKGJP3p6u0ghEXo4IRF6OCERejglHAqIERF6OCERejghEXo4IRF6OCERejgdH7M6pawYiLUcGIi1HBiItRwShg1MCIi1HBiItRwYiL+f/a+7Zd2XHkyn+Z5/PAS/D2LUbDsD3GoIGGbfTYAwwG9e+jPNqitJ3UZiqKmQyR66Wwq0orGVwrREYERbIJjchimtCILKYFjdJv+rsLjchimtCILKYJjchimtBIoLEFjchimtCILKYJjchimtCILKYJjchiWtAo/b7Uu9CILKYJjchimtCILKYJjQQaW9CILKYJjchimtCILKYJjchimtCILKYFjdJvnb4LjchimtCILKYJjchimtBIoLEFjchimtCILKYJjchimtCILKYJjchiWtDokMU0oRFZTBMakcU0oRFZTBMaCTS2oBFZTBMakcU0oRFZTBMakcU0oRFZTAsaPbKYJjQii2lCI7KYJjQii2lCI4HGFjQii2lCI7KYJjQii2lCI7KYJjQii2lBY0AW04RGZDFNaEQW04RGZDFNaCTQ2IJGZDFNaEQW04RGZDFNaEQW04RGZDEtaIzIYprQiCymCY3IYprQiCymCY0EGlvQiCymCY3IYprQiCymCY3IYprQiCymBY0JWUwTGpHFNKERWUwTGpHFNKGRQGMLGpHFNKERWUwTGpHFNKERWUwTGpHFNKCRFLKYJjQii2lCI7KYJjQii2lCI4HGFjQii2lCI7KYJjQKz2JccnGjMer0M43OqLBxY9zOeSo9rMlsdmgKB4FcSSAd1Wa0TvvDxpeMtspk1jXtrFsVCk9H7enr6WgOGpmoC09TUPbraQoPD9l+29kvRYUnVFD0sqLCczsoelVRLTzNhKKXFRWe8ULRy4oKT76h6GVFhdcBoOhlRQmKDqao8OoIFL2sqPBCDRS9rChqRqMpiprRaIqiZjSYogY1o9EURc1oNEVRM3pJ0WV62oymaCqKOqXziqeisHfRf5GOsk4H0gmkf550FEc6kI76RQfSUWLoQDqqAB1IR6L+edItcukOpCPd7UA6MtIOpCMj7UA6jUS6p0x6DPZn0qMO2y/HbwWypYi1UjNU3tiWmqGyu7bUDJWDtaVmqEypLTVD5TNNqaGhso621AyVG7SlRlQEv5okKr5dTSJ5JomKulaTREU7q0mioozVJFGz+2qSqFn1t0lO1Gy2miRqFllNkjd6O3mjt5M3ejt5o7esC+1Xk+SN3rIuWl9Nkjd6y7oAfDVJ3ugt62Lq1SR5o7esC5NXk+SN3rIu8l1Nkjd6y7pgdjVJ3ugt6+LT1SR5o7esCzlXk+SN3rIuilxNkjd6y7rAcDVJ3ugt62K91SR5o7esC99Wk+SN3rIuIltNkjd6y7ogazVJ3ugt6+Km1SR5o7esC4VWk+SN3rIuullNkjd6y7qAZTVJ3ugt62KQ1SR5o7esCytWk+SN3rIuUlhNEjd6O1kH/K8miRu9nayD51eTxI3eTokbvZ2sw8VXk8SN3k7WoderSeJGbyfr2OHfJsk6N3c1Sd7oLevk0tUkeaO3rLMjV5Pkjd6yTu9bTZI3ess6P201Sd7oLesEq9UkeaO3rDOEVpPkjd6yzp9ZTZI3ess6u2Q1Sd7oLevci9UkeaO3rDMTVpPkjd6y9tuvJskbvWXt1V5Nkjd6y9qbvJokb/SWtRd3NUne6C1r7+lqkrzRW95eSydvr6WTt9fSydtr6eTttXTy9lo6eXstnby9lk7eXksnb6+lk7fX0snba+nk7bV08vZaOnl7LZ28vZZO3l5LJ2+vpZO319LJ22vp5O21dI32NOXz85a/dTiYtDZyeTxeYY4H8zxY4MEiD5ZYsOv7KlaY5sEMD2Z5MJ6XRJ6XRJ6XRJ6XRJ6XRJ6XJJ6XJJ6XJJ6XJJ6XJJ6XJJ6XJJ6XJJ6XJJ6XJJaXeKV4MM2DGR7M8mDEgzkezPNggQeLPBjPSzTPSzTPSzTPSzTPSzTPSzTPSzTPSzTPSzTPSzTPSwzPSwzPSwzPSwzPSwzPSwzPSwzPSwzPSwzPSwzPSyzPSyzPSyzPSyzPSyzPSyzPSyzPSyzPSyzPSyzPS4jnJcTzEuJ5SXnNinyGfbs9b4dRGaZ3mFF//JxuR5Xv87P7Ma0mqsKzKW61gpS+P7ua42SZ42WZE2SZE2WZk0SZU14/6meOlmWOkWWOlWWOrFHZyRqVnaxR2ckald2nR+V8m69WyhTsSbLs8UqYPVqYPUaYPVaYPW2WhH9coPKNjmSsNJI+0EijYxNJ7424dGjk2oLkapKWZ5KRZ5L9tEmk03YtB5mCJ5E0g5w0gz7+AU1tsPz8eYlVi6I4i5I0iz5/WGLVIi3OIiPOIivOIhJnkRNnkbgxO4obs6O4MTuKG7OTuDE7iRuzk7gxO4kbs5O4MTuJG7OTuDE7iRuzk7gxO0kbs4OSNmYHJW3MDkramB06nIrolNp+21Gq/XZy+adT1IcO6K8O0N074O7eAX/3DoS7dyDevQPp5h3ocK5k4w7ou3fA3L0D0mfimOz2tLLfO1BYpKzcSh46nJ7ZtbvSZ/nG3ZUeEzTurvQIonF3pccbjbsrPTpp210jPZa52N2cAUejYqG70iOfxt2VHic17u5gUVWtuzRXdweLqmrdHSyqqnV3sKiq1t3BoqpadweLqirdtXNFVXasqMrovbuu9nRItB0LFFIylaetM18Pkz5E46r0rNFp50+lb0+vtI8V3d2G9rGizNvQTqC9B+1jRd23oX2s6P82tI+VhdyG9rGyodvQPlZWdhfaaazs8Da0I0vtQjuy1C60I0vtQjuB9h60I0vtQjuy1C60I0vtQjuy1C60I0vtQbtDltqFdmSpXWhHltqFdmSpXWgn0N6DdmSpXWhHltqFdmSpXWhHltqDdo+4/R20G7vzR6ZAO4H2N9Ae9EaICVYVaEck04V2RDJdaEck04V2RDJdaEe9vQftAfX2LrQjbu9CO+rtXWhHvb0L7fRx2qPdOmuVtpXfDibfzLTMQ7tIMZUMCWr7ab0EC/tP29JPx/xwDLbyrLFme9gQVdWvnW0SHFjvwLoH6x1YD2C9A+sRrHdgPYH1z7P++at1wPrCuh6JdW/yAeVLnFBh0iqlsyHRf5h3A9678G7Bexfead7RPW4lB61UlXbtM+3Ghj9N+8Qpak/aJ85Re9I+cZLak/aJs9SetE+cpnakPU2cp/akfeJEdefGGhM+zPvEiWpX3idOVDvyHpXw4d07Fb6e9s7aI++r/cLHyar9wsebqv3C39uq/XRz+4VXPKr2Cy8dVO0XnoNX7ReezFbtF54V1uzXN59/9c3nX33z+VfffP7tcJVhW/tvPv/qm8+/+ubzr775/KtvPv+am8+/5ubzr7n5/GtuPv92uPSurf03n3+N9Pl3/2m/LEr88WPd04fNan/84Caar75Kn6tb9lX6vN6yr9JjgIZ9tdLjhZZ9lR5btOyr9DikZV+lxywt+0qy++qSi3tfzc99pZA2Oyjaw82RyZWWLPPS37K6mp+11n8xIzxy6siM8JisIzPCI7gjM8e9JVu0bYVHZVX7hUdaNftJePRUtV94RFS1X3iUU7VfeORStZ9ubv+NYoai/Tea2Yv233z+JemfzjvajikJ/vDJbzGysnZ71tLBaFPixbvNZBfU4eHH6SbPNqeUf1kdLoh/PP2bRid8GJFBo1Upbb/8jY/i0yFbvH9TSfaLb+nbykbjW/p+stH4lr6RbDS+MQ1+lm/pW8cG49tL3zM2Gt/SN4uNxrf0TWKj8S19c9hofBP4/ijfyC8/yzfyy8/yjfzys3wjv/ws38gvP8p3QH75Wb6RX36Wb+SXn+Ub+eVn+Z734DqntjOlHKlvz67MzHu2XI2ZeY9/qzAz8UniNWaGOkStKTNDHXPWlJmhDiJrygyBmRNm5j12usbMvCdD15hBDHzGzMQxsN/OjXQpVp4l4zYayUT6lo795nGsIzXfeMPMfqCmDd8P1Fx5nHfea8sj7g9swyNuBGzDI+74a8Mjbu1rwyPu4WvBY5J+pPVteJy3etaWx3lrbe+86dHvd5Uf9sjtrCP76cE6gfUOrCOz6sE68rAerCNr68E6crwerCMj7MC69CsZBmUd2WYP1pGb9mAduekbWDd6Z93Vng6Jtt8O6XCGYvlp67avWUnvn98aVXrW6LTLeCDv8fSqPkH9idVHrj6z+qgZzKw+ahczq48ayszqo5YzsfrSrxmD+m9VH7WtmdVHjW1m9VHrm1l9gvoTq49a38zqo9Y3s/qo9c2sPmp9M6uPWt/E6ku/Ihjqv1V91PpmVh+1vpnVR61vZvUJ6k+sPmp9M6uPWt/M6qPWN7P6qPXNrD5qfROrT6j1zaw+8v2B1Td2l5FMQX3E/AOrH/RGnglWFdRHzD+z+oj5Z1YfMf/E6jvE/DOrj/X9mdXH+v7M6iPfn1l9gvoTq4/1/ZnVn7fWl8zWx+UdqDzrVMgXWP02ND+tvnict2rWlsd5609teZy3ktOURz9xTSRu1/Bpdbib/YRIrXcinS8QOXF5oS2RE2fqbYmcOOltSySByDZETpyKtSVy4i8Y2hI58ccAbYmceF29LZETL1FfIdLo/fY+Y7/f3lf46drJ/gF5UBfakTV1oR05VhfakZF1oZ1Aew/ake11oR25YRfakUl2oR15ZxfakaX2oD0iS30H7XfZthiRLU8tP7L2qeVH9WBq+Qnyzyw/qilTy4+qztTyo7o0tfyock0tP6ptM8ufUPWbWn5U/aaWH1W/qeVH1W9q+Qnyzyw/qn5Ty4+q39Tyo+o3tfyo+k0tP6p+88rvlULVb2r5UfWbWn5U/aaWH1W/qeUnyD+z/Kj6TS0/qn5Ty4+q38zya+T9I8v/8+V0i/yI/EeW/+fzyhf5CfLPLD8i/6nlR+Q/tfyI/KeWH+v9U8uP9f6Z5TfI+6eWH+v9U8uP9f6p5R8q7/eGsvyhqmhS29MmOVt5mpTavIUUHV1LrUzaoabRS0xapXQ2JFZ5t/ubZMP3N2llcqgZqSuTQw3uXZkcanWkK5MEJhsxOe/c3ZrJocrfXZkcqpLclcmhirJdmRyqvvlWJi9dxf7zoeFeETKiPrwjf+rDO7KtPrwjN+vDO4H3Lrwj7+vDO7LEPrwjp+zDOzLQPrwjX+3Cu0O++hbe77IByiFvnlt/5O9z6486wtz6E/SfWn/UVebWH/WdufVHnWlu/VHvmlt/1N2m1t+j/je3/qj/za0/6n9z64/639z6E/SfWn/U/+bWH/W/ufVH/W9u/VH/m1t/1P+m1j+g/je3/qj/za0/6n9z64/639z6E/SfWn/U/+bWH/W/ufVH/W9q/SPy/6H1r92AFRH/D61/7SzkSNB/av0R/8+tP+L/ufVH/D+3/lj/n1t/rP9PrX9C/j+3/lj/n1t/rP/Prf/E9T+t4maIdqHyNIW0GUKR1OHpr7uwEoHJRkxOXJNqzOTE1Z3GTE5cJ9EhM2lMjUmn88zntPMFJieuODRmcuLcvSmTWk2cBTdmcuJ8sjGTE2dmjZmcOcdpyySByUZMzpzjtGVy5hznCpMXb3Ov3BygFTKiPrwjf+rDO7KtLrxr5GZ9eEcm14d35H19eEeW2Id3Au9deEcG2od35Kt9eEe++hbeb7LTUWvkzXPrj/x9av0N6ghz6496xtz6o64yt/6o78ytP0H/qfVHvWtu/VF3m1t/1P/m1h/1v7n1R/1vav0t6n9z64/639z6o/43t/6o/82tP0H/qfVH/W9u/VH/m1t/1P/m1h/1v7n1R/1vav0J9b+59Uf9b279Uf+bW3/U/+bWn6D/1Poj/x9a/8pNd9oh/h9a/8pJ59oh/p9bf8T/c+uP+H9u/Qn6T60/1v/n1h/r/3Prj/x/bv2x/j+3/lj/n1p/Lzz/d8ltIoWoK/o7o8LXw84cTsVPRWexdntY27hLFF3hYbKbnBQPdFD4YlF4Fn0TFgksNmBReEZ3ExaF50U3YVF4dnETFoXH6EJYdG7roPMlFoVHuvdgMQhfL5bCYlDbD4dUYFH4qutNWETu8hKLaZtdvLIFFpG7tGCRwOI1FrUusIjcpQWLyF1eYdGHjQ8fVYFF5C4tWETu8hKLcbPZJyqwiNylAYsRucsrLC7LLJsVOhZYRO7SgkXkLhdZNL7AInKXFiwSWGzAInKXl1hMm81RleZo5C4tWETu8gqLMb/RsThHI3dpwSJyl5dYtHZj8bBPL7OYkLu0YBG5y0UWXaGmk5C7tGARucsrLCa9PZtKUXcisNiAReQuL7GYN9MnKqy7JOQuLVhE7vISi/k7neRLbzRylxYsIne5yGJ4rkYYhdylBYvIXV5hUSu3fTSmlVcFHpG9tOFx3vyFzGbHwob/mUe7LDtvRi8RYn7Y+JLRVvm9i4dvHpd/KT0d1PYhkA2HWOrx9KoRQSPxGs2be91Ho3kzu/toNG/eeB+N5s1K76PRvDnvbTTS82bU99Fo3nz9PhrNWwu4j0aoM8jXiKCReI1QZ5CvEeoM8jVCnUG+RqgzyNcIdQbxGhnUGeRrhDqDfI1QZ5CvEeoM8jUiaCReI9QZ5GuEOoN8jVBnkK8R6gzyNUKdQbxGFnUG+RqhziBfI9QZ3qGRMflpihWNovb7zS9qf7p8lwsFtW0Sp6D3Ewuss1+KoioxmqIERQdTFBWP0RRFfWQ0RVFNGUxRQs54N0XzoYXLn76gKGLdmykacx9pebygKEFRwYquGiF6la8R4lH5GiHC7K6RlFuXddpFP1xavd26bAjrhvCVV30F65fwlRd9xSEnhq+86itYz4WvvOorWFeGr7zqK6jiwVde9RWCr8BXXvQV1CnhK6/6Cuql8JVXfQV1W/jKq76Cui185VVfQd0WvvKir3jUbeErr/oK6rbwlVd9BXVb+MqrvoK6LXzlVV8h+Ap85UVfQd0WvvKqr6BuC1951VdQt4WvvOorqNvCV171FdRt4Ssv+kpA3Ra+8qqvoG4LX3nVV1C3ha+86iuo28JXXvUVgq/AV170FdRX4Ctfwhi7i07m2Vci8iD4ypcwQW8qLqGJKvgK8iD4yqu+gjwIvvKqryAPgq+86isEX4GvvOgr+H4FvvKqr+D7FfjKq76C+gp85VVfwfcr8JVXfQXfr8BXXvSVhLrtS75iVfYVa+ibr6w8oqbZhkfU+9rwiFpYGx4JPDbhETWUNjyivtCGR+TebXhEXtqGR+RsL/FoTMg8xljJ2aIOm9HxW4b3dWPDIgpY78A6cqUerCOz6sE68rAerBNY78A6crwerCMjfAfrP9/1tVT9wXoH1pFt9mAduWkH1jVy0x6sIzftwTpy0x6sIzftwTqB9Q6sIzftwTpy0x6sIzd9A+s32bVvNXLkmdVHrj6x+gY1g5nVR+1iZvVRQ5lZfdRyZlafoP7E6qO2NbP6qLHNrD5qfTOrj1rfzOqj1jex+ha1vpnVR61vZvVR65tZfdT6ZlafoP7E6qPWN7P6qPXNrD5qfTOrj1rfzOqj1jex+oRa38zqo9Y3s/qo9c2sPmp9M6tPUH9i9ZHvD6x+5UZV6xDzD6x+5V4G6xDzz6w+Yv6Z1UfMP7P6BPUnVh/r+zOrj/X9mdVHvj+z+ljfn1l9rO9PrL5Hre8l9clm9SnqivpWZzuspgN9JT50oI1rHfzh4dLtrp42t/LOHh9dxUTpbiAxUYm7lZhZF3+YHbKYKKzdS8ztzrygCm8mQcyXxNRpF9NUxHQqRypOUTiKuZKO8lQH0lEV6kA6ijEdSEcNpAPpKD18nvSAjL8D6cjMO5CODLoD6ch0O5BOIP3zpCMj7UA6MtL2pFNKMZPu0pH0wsMubWVr8qSeFUL6Kl0h5LrSFUJiLFyhiCxaukJIuaUrhPxcukJI5qUrRFBIuEIoE0hXCDUFUQrZZ4VQU5CuEGoK0hVCTUG4Qgk1BekKoaYgXSHEctcV8hWFNGU7NNn4s0Je0fbTXiX188N6eWJ7evn70McsKEK/wQRFpDiYoAgshxKUFOLQwQRF2DqYoFg5u7Og6VlQLLQNJihB0LEExTLeYIKiUjSYoKgUjSWomXgOVfFE0JWZiSejCjMTj+oVZoYaHinZjRl32CZUZkar7TgXrQ99tKp09gvlc96IDifQpNKzVu/H1Zhvz66UD1XqvgflQxWjb0G5HapcfA/Khyro3oPyoUqu96B8qKLoPSgnUP5pyofK5e5B+VBJ4j0oR/b5ccqRfb5Guc7nqRNVKO93JydZZLYjyUnImoeSExn5UHIi2x9KTlQShpKTIOdIcqICMpScqK4MJScqN0PJiarQUHKiKjSSnA5VoaHkRFVoKDlRFRpKTlSFhpKTIOdIcqIqNJScqAoNJSeqQkPJiarQUHKiKjSSnB5VoaHkRFVoKDlRFRpKTlSFhpKTIOdIcqIqNJScyDvvJKexuy7HLUebnGNdcz+8nCHftWyCVQU5EdkOJSci26HkJMg5kpyIbIeSE+udQ8mJ9c6h5ETeOZScWO8cSc6I9c6h5ByqKuRCvq3Qm/SznDb/MB2sKB/LXXxU09dZ2HGoUsw5h2tnhypU1DpLM3V2qCS31tmhUsBaZ4dKkGqdHSp9qHV2qOC60tmx7uCudXaowGxJA7fOxmB/DsyizswsP+y/RcMrNUPFW22pGSo6a0sNzUuN3+5lj0bFAjVDRX5tqRkqTmxLzVBRZVtqhopB21IzVMTakho31t3ebamZOBquUTNxNFyjZuJouEYNgZozauaNho3eqXH6GzUfXbWqfJruxrofeEyJ5s0ObiPRvFnKbSSaN1u6i0R63qztNhLNmz3eRqJ5s9jbSDRvNn0biQgSSZcI1QXxEqG6IF4iVBfES4TqgniJUF2QLpFBdUG8RKguiJcI1QXxEqG6IF4igkTSJUJ1QbxEqC6IlwjVBfESobogXiJUF6RLZFFdEC8RqgviJUJ1QbxEyIt6S1Q5n9pZRHS9JaocFuUsIjrpEhEiOvESIaITLxEiOvESYb1IvEQEiaRLhLxIvERYLxIvEdaLpEvkREV0q0miIpjVpL4ztq05so52czcdaT+7Yaknrfa7m9vvb25/uLn98eb2p3vb3/ky9T9vv765/ebm9tub23/z+dfffP71N59//c3nX3/z+dfffP4NN59/w83n33Dz+TfcfP7tfG3rn7f/4/Ov1Xa7FMvqpCq/bazfemtsCN8KQGsH/N07EO7egXj3DqSbd+DzN+y17oC+ewfM3Ttg794Bkt4BkztAVFv3qN1N4qL4ebttd8XP8m27Kz4muNbdyvnZUXwE0ba74uONpt1N4qOTtt0VH8u07a74yKdtd8XHSW27S3N1d7CoqtbdwaKqWnfniqrSWFHVXTYOprGiu5vQ7tVYUeZtaB8r2r0N7WNF3behfazo/za0E2jvQftY2dBtaB8rK7sN7WNlh7ehHVlqF9qRpfagXSNL7UI7stQutCNL7UI7stQutBNo70E7stQutCNL7UI7stQutCNL7UI7stQetBtkqV1oR5bahXZkqV1oR5bahXYC7T1oR5bahXbE7e+gvXIyv7eIZN5Be+XIQm8RyXShHZFMF9oJtPegHZFMF9pRb+9CO+rtXWhH3N6FdtTbe9BOqLd3of3zWeqSOW+0m2gqv+10JtJpt3d30e6rA+buHbB37wDdvQPu7h3wd+9AuHsH4t07kG7eAadkd8Do/fA2Y0MtfqicjuWd8Hm7dXeFz/Ktuys8Jrja3Z9P6fCfv0Cnb3eFxxutuys8OmndXeGxTOvuCo98WndXeJzUuLt+sKiq1t3BoqpadweLqmrdnSuq+vy1SG/t7l0+t/JjRXe3oX2sKPM2tI8V7d6G9rGi7tvQPlb0fxfaw1hZyG1oHysbug3tY2Vlt6F9rOzwNrQTaO9BO7LULrQjS+1CO7LULrQjS+1CO7LUHrRHZKldaEeW2oV2ZKldaEeW2oV2Au09aEeW2oV2ZKldaEeW2oV2ZKldaEeW2oP2hCy1C+3IUrvQTqD9DbTXzj5LiGTeQXttM39CJNOFdkQyHWgPCpFMF9oRyXShHfX2LrSj3t6FdgLtPWhHvb0L7ai3d6G9Q5aatoetPRwi9/jt3yZ1uBu1apKWZ9LHYyFSueJBytXel5+eXjtg794Bkt2BZeV4G4OWZTV9+OXVfHdv8/29zQ/CzU9qm5J8MuHJ/Hhv89Otzf/8vWxtzdf3Nl/4zFszX/i8WzNf+qxbMV/6rFsxX/qsWzH/3rOuufesa+4969p7z7r23rOuvfesa+89637+jqW25t971rX3nnXtvWdde+9Z19571qV7z7okftalXKZK7tl88bPuz+aLn3V/Nl/8rPuz+eJn3Z/NFz/r/mz+m6et340Mdki/lFVbq7Y+Gqv1t6dX2gm096Adn4Z0oR2fhryDdhNTpl2ZAu3YwNCFdmxg6EI7NjD0oH2wyzVuQzs2MHShHRsYutCOLLUL7QTae9COLLUL7UiXetDe4aR4bdVGu06qRrs1mXYifRfaazWZDifFg/aFdgLtPWh3oL3H2O5Bew/aA2jvQXsE7T1oT6C9A+0dTooH7QvtGrT3oB1ZahfakaV2oZ1Aew/akS71oP3zx9qaaLfOWqVt5bddcnGjJur9gNiYSg97Cl8Puxj2n07pzvWbZCCRdIksJJIuEUEi6XORg0TSJfKQSLpEARJJlyhCIukSJUgkW6L4+ePjIdFViVBdEC8RqgviJUJ1QbxESF2lS6SHChcobeUu5yj8LJHWalvo0PrQR6tC4WnSmXSincYURNXzoh4qtICcQ4UhkHOokGV4OatzJ0HOkeQcKlqFnEMtykDOoRZwIOdQiz2Qc6iFoenlNKgKDSUnqkJDyYmq0FByEuQcSc6hQiGj8qKXcb4iJ+XNIJrC/nB0Jc6N2X7Z2hh3Hn3J6Lt8UB3tUJET1L+o/lCBFtS/qP5QcRnUvzbv26EW96D+RfUJ6k+s/lBLh1D/ovpDrTRC/YvqD7UwCfUvqj/UOibUv6g+an0Tq0+o9c2sPmp9M6uPas/M6iPje0l9HQ9nyfmK+gvTJj9Nu6+UV4NvsypAyA/hK6/6CrJJ+MqrvoLcE77yYrzikKnCV171FeS18JVXfQVfvMBXXvUVVEzgK6/6CsFX4Csv+gq+vYGvvOorqNvCV171FdRt4Suv+grqtvCVV30FdVv4you+4lFf6e4r2u++omJFfQppM3v5c7fEOvulKKogN1M05rGCjoTsihIUvZmixmZFrSkoiorCaIoi7x9NUWTnoymKHHo0RZHpDqZowHdEd1M093ERVxUUxdc+oymKmtFoiqJmNJqiBEUHUxQ1o9EURc1oNEVRMxpM0Sg81g0mbj8dgqooqr3ZuNHhIJK2Rd512Jzlscm68rTR3mVKbKjwfps9cFF4ZAz936w/Qf+p9RcedUP/P6d/7fuoKDxGh/5v1l94RA/936y/8DVj6P9m/YWvMEP/9+qfhK9HQ/836y989Rr6v1l/1P/m1h/1v7n1J+g/tf6o/8ysf1ITx39K6WxIrD1tbF4ANkT6LvpX6v9JTRz/Qf9F/4njP+i/6E/Qf2T9q/P/xOu/0H/Rf+L4H/ov+k+8/gv9F/0nXv+F/ov+E6//Qn+f9MTrv9B/0R/1v7n1R/1vbv1R/5tbf9R/ptbfDBX/BZU3aQafKorGuJXGtVJV+Yfc/pPMUOEf5L8q/1DRH+S/Kv9QwR/kvzr3E+SfWf6hQn/If1X+oVZ+If9V+Yda+IX8V+Ufat0X8l+Vf6hlX8h/UX6Lqt/U8qPqN7X8qPpNLT9B/pnlnzj0yw/HYGvqj7nfhyaO/KA+TRz4QX2aOO4bX/3avE8TL/ZCfSKoP7H6Ey/1Qn2aeKUX6tPEC71QnyZe54X6hFrfxOo71PpmVh+1vpnVR7VnZvU/H/U5tV15aByl2m/HlEvVyg5TYHcJtHeg3SvQ3oN2Ddo7jO3egPYetFvQ3oN2Au09aHegvQftHrT3oD2A9h60I0vtQjuy1B60B2SpXWhHutSD9liknVTYmjA7SD82VzwTY9N2PZOmQ/3BLk+vTdj3N0Hvb8K9vwn//ibC+5uI728ivb2J8n27502sIM0BGQ6o/E7ZbUCjEAsgugwKqnzxBIVtnKXjiYwxfoECBxQ5oKIrOL3NGs7Yb6DSeti+fSxGfXh6baF88nbTFvTbWzBvb8G+vQV6ewvu7S34t7cQ3t5CfHsLb3+nzdvfafP2d7p8LpSjLe50FJ6Hy/J5Ii5sIE/qGVQ+hqDSUnnzunPbtOs8FUDlUSRuAa9LtgAiDshxQJ4DChxQ5IASA1TeaOqiyqCCTuX9iTWQ4YDszyCvSn0qe0RIGRQLoKJHeL2x520qgHylpdL7VP7Su/ISlj8QroE4r3v5kyRt3NYpbXyBCkc8mOPBPA8WeLDIgyUWrPydRB2meTDDg514SQwZdqhk7DCqwwphvnc8mOfBAg9W9pKl7rLBbGngKdd5q7BynbIO0zyY4cEsD0Y8mOPBTnTzWW4bCrNMLDO5x3jaUeENiCeUpPy+kXIFGNVhhdc0Oh7M82CBBUuKByszSflTUU1WF2DEg5WZJK8yzBcGhRRPYHvfwvMkrNVJ33LtV1O0BRjxYI4HK3sJpXy7x1JiL8ACDxZ5sMSClcs+y9uddXPGFWCaBzM8Iy0PRjyY48E8Z5zU5UpGHRZ5sMSCGcMZubRhjVzaEA/mWLBybuNTvo3HJ31M/IvLYLQvg/kjf19NhPc3Ed/fRHp7E+UtYm2b0O9vwry/Cfv+JuhiEyvKsVCegyov6nqfV3qWPw9rXkvYssIsD0Y8mOPBPA8WeLDIgyUWrBwH12GaB+N5SeJ5SeJ5SeJ5SeJ5SeJ5SeJ5SSp7SaBtxdOHQ2qwwYwq6vZYIPuCPQrVBZjlwYgHczzYyXiX46kyrBx1PyqtGRZ0AWZ4MMuDEQtWXkkKVmUmrSlQUo5M6zDLgxEPVvYSm3eoButCAeZ5sMCDRR4sVWGH4CLD7IlucYelWIBZHox4MMeDeR6sLADlS0QDWfsMKy9S1WFlSqLbQq4QfQlWdi7yMbd2KKPvsMiDJRasnEYEr7MA3hRcuZwa1GGGB7M8GPFgjgfzPFhgwcorQsHF7MouFcaS8hpNCPlL1hALcYkpr9HUYY4H8zxY4MEi6+0ur9FUYeU1mjpM82CGB7M8GG+cLK/R1GGeB0vV963kJVHxYJoHMzzYyTjp8xvgQ2E2Lae0S6aRmVwqWgVYYsHKKW0dpnkww4NZHox4sJMZJ4Ud5gowz4MFDsyqE91cdq7gqADT1VFZf39NC99mU3T7x9mx4MP2JAWO2v80+FvFmg+XJIYHczyY58ECDxZZsJNVlmV9Pa+GaqsLyp2ss9SB5U82XwFqLtBwgZYLJC7QcYGeCyyvznln88qXd4X81paz6VeAiQksX6L2ClCfAIPegbEELOvofY7XtV+KPQVgWUe/DOM7kHwB6LnAwAVGLjAxgaS4QM0FmhNgPOwyLFQsbPmr1VeAxAWeeE7cX2QfdWEkJ88FBi7wzHMOr1XUphYlLAlIfn5JD3Tteefi/g2GS6lgWBJqmFNSDdNSDTNSDbNSDSOphjmphvlehuUB1nmlCoaFRoZZezAs1dO2nPguf+tCXORNJ8Nq+aS3Ug0jqYY5qYadRRfueDJECZiYwKC4QM0FGi7QcoHEBTou8CwutWF3sMK6qw2BC4xcYGICo+ICTxwg7VPJ40i+AtBygSdypH2TxFJSLMyS5bqxDtrkWSzowjcd9mRTwAtAzQUaLtBygcQFOi7Qc4HhBJiXnJe/YyEaOdkAsQDDDky1onDLLzhtStJMIqXkmaTlmWTkmWTlmUTyTHLyTDoZl/aTux5/Py+N0ckWn8eHKzuwMBLSySafF4CWCyQu8GS0N3Yf7Q3ZAjBygSdjsvEHUwsBBp0sDL0A1Fyg4QJPdFzW/DLQGlMAEhfouMCTOMHSAegKb8fJwtALwMgFJibwZGHoBaDmAg0XeOY59gj0BSBxgY4LPPOcvWz1yAoKwMAFRi4wMYGkuEDNBRou8MxzwgGYClMAERfouMATz6HDjEymMHecLEW9AIxcYGICT5ZyXgBqLtBwgSeeQ+oIpAKQuEDHBZ54jon7jLyMaH/UqotW5+epOC260Kghe9h766o1/2rZk1xsZJij3TBf8or0BgZKDXn1qYb0pxoyn2rINmoon725/J3Mn/dST40MSzsDy+BQaMi1Z6DckP9UQ+FTDcVPNdRoJFmS1b0h++e/LqXQaOQhe2CAClF90G9goNiQ+VRD9lMN0acaYowkK9BzgYELjMxqT0hMYFRcILeGFrk1tMitoUVuDS06LtBzgYm3SEdna23qcJ+rUoVk/2ytrQ40XODZCmZSB2AhdD9Za3sB6LhAzwUGLjBygYkHdCfrVi8ANRNYLqIuk/b2cizT6gHm7BeMeLDytQ/RZFi0JZjnwQIPFnmw8jUKcb96IBr1DCuXTeswzYMZHszyYMSDOR7M82CBB4s8GM9LTg5uzp/cL26UQV+30Swg4oAcB+Q5oMABRQ4oMUDl2mINpDkgwwFxPKJcS3R5pe14jPwOchyQ54DKHpE3V/rDAvIOihxQYoDKNbQaSHNAhgOyHBBxQI4D8hwQxyM8xyM8xyPKWakJeeesCaXX8Oyjyv3w2+Ne8x0WebDEgp19TlmDneQwYc+2kinADA9meTDiwRwP5nmwwINFHiyxYGe5bg3G85LE85LE85LE85LE85LE85KT7DapvN8mmRIscmC+nGfa/TZHm2if2B/7fJ7bWBZZ9hPkfTwMq8kVP1Pbng6Hk9yt9V8WmbJFZLJFh11ARYtq0bcvf5XYuA36QBvuA234D7QRPtBG/EAb6f1tlE9eb9yG/kAbH3jP9Qfec/2B91x/4D3XH3jPy9/N2pQvhCJ9OPeh2EbUfv9u+XBdSfky4FoB05c/yO1qUZJmUfkT4q4WaXEWGXEWWXEWkTiLnDiLvDiLxI3ZRtyYbcSN2VbcmG3FjdlW3JhtxY3ZVtyYbcWN2VbcmG0/Px7lT06XP/2zRfTxd62Wi9B737W1DfpAG+4DbTTw8H3jaDSHT/rL6oVE+XTfdKySFp+2+SI+0rvvPWqcz88anbZNssYcLh/LFVEKE/U1TtTXNE9fnZqor3qivpqJ+mon6itN1Fc3UV8nipvcRHGTmyhuchPFTX6iuMlPFDf5ieImP1Hc5CeKm/xEcZOfKG7yE8VNfqK4yU8UN4WJ4qYwUdwUJoqbwkRxU5gobgoDza/G7n2lwtf8caBxuLLnyseBxuFqXwcah6t9HWgcrvZ1oHG42teB8tdqXwfKX6t9HWh+rfZ1oPy12teB8tdaX9NAsYTN3wYu0aIu9HWgWKLa14FiiWpfaaA8J18uuHS7kOekgWKJal8HiiWqfR0pV6/1daBYotrXgWKJSl+DGqgGU+3rQHFTta8DxU3Vvg4UN1X7ShP19fN7OX/eFxTUx/dyxqzV8mcqWPTxvVOVg0iDVuIs0uIsMuIssuIsInEWfXwvZ2VXYNBenEVBnEVRnEVJmkWfPzOlapEWZ5G0PcHh5K5EZfL5dso/nxoaTm5KrMLKZyZqmw/k1BQLMMODWR6MeLDymYnaZ0p0LFFSPsXQ5lNblz9LrSUW7OSewipM82CGB7M8GPFgZd3cfv+5o1CAeR4s8GCRB0ss2MmdhFWY5sHKXuJ8PsfTxVSAWR6MeDDHg3keLPBgkQdLLNjJNXl2P3/VmsL7dnLpXRVmeTDiwRwP5nmwwINFHiyxYCeXoFVhPC8JPC85uW7M5pvftXWFIejk8rAqzPFgngcLPFjkwRILFnkBRuQFGJEXYERWgBHLlbuQjwtdYoJnULlwtBdEkyu0VK7t1ECWAyIOyHGi/1iuNNRhgQeLPBgrIYpG8WCaBzM8mOXBiAfjeYnheYnheYnheQkvbY7l/LcygpSz35QT+2RKIM5gUD7WrdZS4IAiB5QYoHLGWyGCOIM2cQbtcq6bctEghYIblTPdGshxQL7SpyIocIiIHFBigBzHIxzHIxzHIxznzXWcabyc09ZAngO66hHLv+nHk+XwhMK+oLnHoEuh4TfQPJ4sv8FmGZa/kEYne4D+NrT8Bv8IWv7N/ja02MOoTK7V7mOTDoVKrc+BtXf2+OhiVzmUafXj6c/+eNy2aPkY/9uPl8OiSz++FY+C+m758i/0m/miQ+7XucSUXupxypdzp0NiUzRKL1X6fCutVodcQcffhrlzw6pY/3i4vHXE+1yDXv7cv7r4ugq1vAejBgocUOSAEgNUvpypBtIckOGALAdEHBDHIxLHIxLHIxLHIxLHI7RSLJRmoQwLVfaKJbrfUEs17RlVFCuo/PXOMgL6Z1RgoSILlTio8sc8PqX0I8qV26KQUeGZee1ZqMBCRQ6qnBUvC6qZQ2ue2SgnxVVUYKEiC1X2DWvzl3/HeuGGKq8jV1GahTIslK2ivHlGnegVd9Rh5s+owEJFFipxUKRYKHNS9sgeRdY+oxIHVc65Hgnchoq+gCq/leTjXplJzyjPQgUWqqyy15l5b569t7y0V0OVDwWsojQLZVgoy0IRC+VYqLJeLmbvdel53Civli2LMTZ7byHeKC+WVVGWhSIWyrFQnvMul9fJqqjIQiUOqrxIVkVpFoo1HpZXyKooYqFC9f0q+EaMLFTioJJioU7Gw3yBfDjePp1RZZ9fguwNFTQ9owILFVmoxECZctZWRWkWyrBQJ3NKXhV+fL39jCIWyrFQJ3q57FHBFfqVqmOv/v5WFipeFN0Wnix/P/ut0SdjWj6HoDTCG82Z74w2LJRloYiFciyUv4xa/i08nj35OmdJsPavVq1+ki1oHszwYJYHIx7M8WCeBws8WOTByuvPS3U/fx/l3XNeevJ1ThWmeTDDg9kTWNA7LD7DiAc7YdLnQF37oJ7i+3TCZDB7346r+T9Wpusww4NZHox4MMeDeR4snMCi32HPtYhyyFOHJRbspFa9JIf7670sn71arX4BZ5i4M085vDxRm1qUYALl503wuva8c3H/xtil56qHIqF2OaF2eaF2BaF2RaF2JZl2aSXULt3Lrn1vi1fPa3raNLLL2oNdqZ6t5VR3+Vs/1xm1FWpX7GTXz9mt1kmmXUYJtUsLtcsItessnnCH+NIXcJ6JC0xcZOISD2cVE6eZOMPEnYyn0Ybdr0qry8TEOSbOM3GBiTvRPe3zrE/+ucZ8sk+5jjvRIfndzhSe44eT3bxB73tXgy58pXKynbeOi0xc4uFOdvTWcZqJM0ycZeKIiXMnuLwYv/wdn+M6d+Yvu5+F47fC5XnBpxwO+aQPH53G4pFbtB/8cKiaPT4bPf2qoKtFUZxFSZpFXomzSIuzyIizyIqz6GQ82o/pe/z9tKKoT/aCB5OXFJe/C+PfyXJTHaeZOMPEnYzvxu7ju6HCdx2eiTsZhY0/2FmIP06Wgeq4xMNFxcSd6GfzFpnlb/Oc158sBdVxlok7iQcsHXDu+X2IjonzTFxg4iITl3i4k+WuOu7MX+wR9xyXJcPEWSbuzF/2+t7y9/P7kBwT55m4wMRFJi6xcCdf+7yAO/OXcMAl9YwzTJxl4k78hQ7zLRn7jHNMnGfiAhMXmbjEw52sK9RxJ/5C6oh7/ibqpC5fx1km7sRfTNznW7Luj1od0er8PBXmvZPvjhjt5O0Ny9+uug5S/zrMN7LL0W6XL/hDeEP/S+3ED7WTPtOOUR9qRzdqJ/i9nWT+tH8a08iutPd/GROe27Ht+19shz7UjvtQO/5D7TQaP0iHvR3757+uNY3GG7KH/tPzF8YmvaH/hXas+lA7+kPtmA+1wxg/fuOIiXNMnGfVa4wNTFxk4nj1L0OKidNMnGHiLBNHTFxgrb+Zs/UwpfJ8uvztn3GJhztbD6viTtaVU1IH3HNcfrIeVsdZJo6YOMfEeSYuMHGRiUsM3PJv8fH0WZCYP007vBBL5WsdYK5D6DrEXYf465BwHRKvQ9JlyFkw8RNEX4dcV99eV99eV99eV99eV99eV99eV99eV788FZtckDGHYXyD6OsQcx1ir0OK6i/R2wY5hFobxF2H+OuQcB0Sr0PSZUh5Iv8Zoq9DzHWIvQ65rr67rr67rr67rr67rr67rr6/rn75XAaT8+8lRPjvkPKiNbktZKDD6YUbxF5vpax+yHcgH/aubZDyRUl6M+y4cfABKd1Wd3qS4tnexMPP26fBuLwe/SOkvBT9M0Rfh5jrEHsdQtch7jrEX4eE65Dr6pdXl/f7HO3x8MkVcnIP/Y8Qcx1ir0PoOsRdh/jrkHAdUpSSTL6okp6kLC/8/gg52exYwZTH1v3GSmOeMYaBsQwMMTCOgfEMTGBgIgOTrmPKi7k/zpcnG7h+xpQzspaf1ZUTuKYt0NtbcG9vwb+9hfD2FuLbW0jvboHUxRZ+gzQHdPXNe9TQEmpoqKGhhnYRghoaamiooaGG9iIENTTU0F6DoIaGGhpqaKihoYaGGhpqaKihoYb2F/k1tMew8P9OKmIh5EMeH7esHyLRH2pi30CBvoEKoW7agm93sO0RVf/lrILWsgH/7gbCuxuI724gvbkBq97dgH53A+bdDdh3N/DuN9m++022Ld7kfNeyM+lbA8/Phv2q0ZAO28VMLP3yngeQ/n6j8POzZgmktuKCUenb0385q/iO2NE4S0fTJB0lNUtH9SwdNbN01M7SUZqlo26Wjs4SGdEskRHNEhnRLJGRmyUycrNERm6WyMjNEhm5WSIjN0tk5GaJjNwskZGbJTJys0RGfpbIyM8SGflZIiM/S2TkaZaOjjOPGrt3lMx/72gYZ9QN+bpoEw7fRm4dHWfUrXR0nFG30tFxRt1KR8cZdSsdHScfrXR0nHy00tFx5tFKR8fJRysdHScf/bmjcZxR16q8ickeLvDeOjrOqFvp6DijbqWjA2Uv+fLmpc9P2UscZ9StdHScUffnjqZx8tFKR8fJRysdHScfrXR0nHy00lGapaPjREaVjo4TGVU6OkvAcLLZdLF4s/054znZbPozprzZtILRDIxhYCwDQwyMY2A8AxMYGIYflG+Ocvl+T3e4PX3DlG+BqmA0A1P2g7TdEeEPN9VmjGVgiIFxDIxnYAIDExmYdB1T3uRXwWgGhuEHluEHluEHJ+db/VxvOtnUq73P10v4w+1OGWVZKGKhHAt1cthZ2K+DSc/z18ltMDVUZKESB3V2D0wFpVkow0JZFopYKMdCsXzDsXzDsXzDsXzDs3zDs3zj5I77pPKhfckUUJaFKuulckislX8eD8tfU1RRZb2WGWZDLa/7MypxUCd30tdQmoUq67XomFHxmY2T2+htnoiWPwtteRYqsFCRhUoc1Mkd9DWUZqHKejmTVXYUnlGWhSIWyrFQnoUKLFRkocq+4Xweo1x8+nTr7L75GkqzUIaFsiwUsVCOhfIs1MkIsM8p1jy/Xyf3xP+MOrslvobSLJRhoSwLRSyUY6E8CxVYqMhCsXzj5EZ4m09v0taFZ5RmoQwLZVkoYqEcC+VZKE7kcHYjeg3FiRzObiuvocoFctpCtkD+GVO0by8IJ/fcTrl6UsFoBsYwMJYRxZ/dHlxDORbKs1CBhYosVOKgTm4MrqE0C2VYKJZvEMs3iOUbxPINYvnGyW72H0eLcjUpqW1YSqaAYbz55epOpR3HwHgGJjAwkcEBY2T2jJG5XM9JOdFP4dl3ytWcCsYyMFTpTwnjGBx4BiYwMAw/8Aw/CAw/CIz3NDBm6PKOiAqGGJirfvDHY1Hx8Wg5Fo0p1wFiSodDqh+nj/6x/Ov/+ae///Wf/vlv//q/F9Dj//7Xv/3Lf/713//t61//8//+x/Z//vnvf/3b3/76v/7xP/7+7//yr//zv/7+r//4t3//l8f/+x/q6x//EJaS7q+wVJCWnjx0CSH6XyEqWv7d/v7/Vi//n/Rf1iNT/4G80b+Wf/i/rL34h+C0/bX8w/3u1+9uPZ5bVneMfvwn8/hPj58y8ZeN+WfoF6XH/7YZYdwvqx7/ifb/FH5Z8/hPbv/d9MvQ4z/5rQtLyPJrGfi+DPZxMX9rxTyeNrSZahYTzNpGyOiolmb1F9qpX15l9DJkLG9fRi8/vTh8vsT8tzUUfy1F1i/0UuD8pdfmfv/PpUdLcrbhlwWjX8tCTr7A6U/gtdrNN4v5NkOU/rVMwhvEKlr+rz943O+HFr4WVv9YvOn/Aw==",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "notify_created_note_oracle_wrapper",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "read_credential",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "claim_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "addr",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "credential_notes::CredentialNotes",
            "fields": [
              {
                "name": "owner",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "claim_type",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              },
              {
                "name": "claim_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "randomness",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "read_credential"
      ]
    },
    {
      "name": "read_credential_hash",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "claim_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "addr",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ue/HpmeoBpYDhNECCxcAEIkuLOXmeR7RhaKVGyTJNabctWz3QPRQkiSAAkRYAkHgACIAmRIEGQEml5t6PY8SLb8m45zon+KHHi5PfvODk+cmLLie38SZyTc5wc/4lzzh88sm/311/fV++96VszDaLrHGBev6r67q1bt27dWl5VLngjjJ3/l2s/T8A7DpJmT/tvabBQNsQq+eQzZ8hnDvgc63sA5vFZi//56974O0Vpovhxw8JPEV1L/PnSQmsq6A3G/FenANMDfkXwJ/zgl9a1cX4g7MUPiO44peM80b9peOY0Eoe69sV23Prz/2aC7vPjQTdPFH6Q6ERhivCM9abpuV7Ll8XwL2WLwjvC3nIb0a4J/jv94Hfa9Lv84FcE/91+8KuCf2fope4bgv+eNn7Qg12uzs9WK/OzlUqzVWo0Z+eWF6pzpepivbqwtFguVeuV+eZco1oqtaqtpVqpObtQb7YaC/Xq8mJjYVaw36tiV1uL56Hqjdn5xfJyY3a5tFibm682lufmmo3mQq01Vy81y0uz5aVKeXl+vlGvN5bqC+Xycmuhvjzfwb7Lj1w69fo+P/gdvXy/F/xqXfC/A/An7PgvCf4H/OB35POdfvA79Xt3Gz/wIJvvCn3UbbmDf48X/K5NvtcPfsemfdAP/rLgfygM+uq2PF+tVOaqC3OlhflmqVxrLlXmz1u3xVppqdRYqrQWauWF5VqlVl1qLi3O1+Yb5eXScmNpYXn+DXDB/rCCXcoWyvxCsD/iRS7VTr1+FPDt+qpqxyZ/LLtsyknogv3d2bGTQsdWfk889orVRrC/V8GuNKpLpYXlUqM+35hrzdfPd6Ol8w+L863l2Upj8XyHWmmWy+VW7fx/lVaztrDYnC0vzrbmKvXF8+Q6Mvl46ENfykuC/33G+LON84Oh2dk5wf9+Y/zFxdm5xnl5Cv4njPGrS7Ot5epcpw9pGOM36rXl5Xq145stGuPXy6VWvTLX0c0lY/yFxVJ9dn6+oz9NY/zz/mC1udBYFPyWtXwWW6WlZnlBxnzLbXyhEQWhfZ8x7XZYyBG9IOgd/wVEv0C8WvurOaKH/KB8ZAwpsvtk2M9rUYlDG8Nx48o7oaNhfb8h1icMsRqGWIuGWEuGWE1DLGnXfttardOPftILfnVe8O/3gl/qzCt+ygd+uet7fRrwAzv+O/h7AT/nAf8zfuTfwX/Aj3w6Y+F9bXwf2A/aY3f8o4f8yL3j3+33g98Zzxzwg9/xfw/6we/YnYf94C8I/iN+8Dv+3aN+8Dv+6Wf94DcF/zEv+OWOfA4Bvp3drHTs2mEv+NUO/uN+8Du27Qkv+LUO/pN+8DvzNUf84HfsZ+gHv2M/j/rB7/g9x7zg1zvj4+Ne8Gc7+vOUH/xO/3vCD35nHvekH/yO/p/yg9/R/6f94Hf0/xk/+B3/4Vk/+B3/4bQf/I7/8Dk/+J3+8Tk/+B3/4Xk/+B3/4Ywf/I79fMEPfsd+vugFf67jP5z1g9+xny/5we/Yz3N+8Dv282U/+B37+Yof/I79/Lwf/I59+4If/I59e9UPfse+veYHv7kheGMP1De2voG38fy/S9rY97UOvn3vvqVPf+Dhzyy29uOMtIxy5Fl7jyFC3dRFfce+Bw7ubywdfFuzub914AAjTCjIQQxqAVA/2bj/gfc2GS2/MrQPt/YfuH/fA4w2mRJN9nOtg/SGfmtJ9retJ/6QNu51NByTNtOsWyD9AvFqPAYv54ie8MPywXWLXNCtbcxbVOK4DgsKnYJCp6jEsZ87CNZZQ6ynDbFeMMSyLOPzhlinDbHOGGI9Y4h1yBDLUvaWbeilIcU6bohlqROWsrfUr5OGWJZt21InThhiWdroVwyxhrV/lPGDX9+q1JhWaEuQuA1AG30qDuyJI99Rvm9u7eJyOgkbIc+Bxx5Y+sC+g60DgSNDFGSjOb8fNuFNUNzGFGUIgmTB/o8UgmUHHnmbJkzMm1OwtKEYKzPKfH0MD4ghdYWOsOEgopqmHEh/tQYRmpHQBhEinw1+5FPJET7ys0GRD+sw110u6OpjHrAw/QYoI6bHZ8mP7/6k/bcY9Lcj2XyfU+LGlXci32ig/UdUNqwb1lM/9VArp9VToV8IfLabrp5qeqF1ZlNBfz1bbqxKU6+abZtW4gRLJqBQTzH9RigjpsdnyY/v/qr9txj06zTr6bRSHnyHevqX7eepmPLsaf8uDRTm5rR+itsByslyo3jadiD0C4FPveu2A62eNHsisrtE4bWoxPGkzyUKnUsUOkUljh3RQbBeMMQ6YYh1yhDrpSHFOm2IdcYQ6xlDrEOGWM8ZYlnq/TDKy9UPZsWKgqWunjPEetYQy1JXLct43BBrWNv2q4ZYhw2xZKGU/UzBj8JU0N/2rMduSE/Kge+QfoF4teWn6ytpctV8WpHPjB/5dPiZUfiZUeQjdVlU4gTr0vZvHDNg+hkoI6bHZ8mP7+baFVYkzCjwmKGolAff4ZhBBpbslwpeFFajHpCe8I3vkH4h8NluSk690Nr/VNBfz4byKaWpV+RX6vJSJU6wZBsE6immL0IZMT0+S3589y7SU9Rp1tNLlfLgO9TTbyc9xbphPfVSD+Xl1Hoq9AuBz3bT1VNNL2YUOU4F/fVsKJ9SmnpFfqUuNylxgnVZ+zfqKaa/FMqI6fFZ8uO7e0lPUaf547BNSnnwHerpd7Rxp2LKs6f9uzRQqNe0urTDnytPK+XkdoayttPraup2JvQLQb9e+GhnlxE/cXogstus8FpU4lhHNit0Nit0ikocj2sGwTpliHXIEOuEIdZzhljHDbFOG2I9b4hlqRMnDbGOGWK9ZISl2edB+DprxFcUzhliWbbtVw2xLG2hZXs8Y4hlWY+vGWJZ6oSl7K3admBcRkudeMEQa1jthCVfF4PPNOrT1k72lu3xaUMsyzJ+fkj5svQnLMvI6wM4tsy1/04F/W3PcJzdyhE9KQe+Q/oF4tWWn+44W5PrZYpcRXZbFF6LShyPs7codLYodIpKHPcZg2CdMsQ6ZIhlWcbThlhnDLHOGWJZyv5VQ6xRPWbDes0Qy1InThpivWCIZWm/XjLEspS9pa5ayn5Y7Zelrlrq1/OGWJb1aKlflm3IUr/OGmIdN8SyLOOw+nKWZbT0J4a1HofVl/u8Idaw+jmWPubIn3hztCFLO2HJl5V+Rc88rzoIXy8b8RUFS9lb+gDS1/J+N8GPgt85tErqPbY8h+ZlD1bCHJq2t24q6NdDQ/mU09Qz8it1ebkSJ1hXtH/jnjBMvwXKiOnxWfLjuzvbQikSZhR4T9jlSnnwncg32hP2tvaPqZjy7Gn/Lg0W5nk+VGggbZSTod6lukQC6RcCn3rXbQdaPWn2RWR3hcJrMejXHdaHKxQ6Vyh0RljDhfVOIyyXDZP4KEwp+aztLdKTcuA7pF8IvNqFskuumr0U+Wz1I5/OHuWtCj9bFflIXW5T4gRre/s39keYfiuUEdPjs+THd5+m/mgbpOU2sE0pD77D/qg11ls2rBvWUz/1kP6bD6FfCHy2m66eanqhtf+poL+eDeVTSlOvyK/U5XYlTrB2tH+jnmL6bVBGTI/Pkh/fPUZ6ijrNerpdKQ++Qz090P4xE8S3zzTtGXE1u80yxHzcHrzUd7lVStsehH4h8Nk+u+1hW0q5iny2e5FPczmN/iC/Upc7lDjBurL9G9sDpt8OZcT0+Cz58d2z1B6w7XB72KGUB99he3iK7DbWDeupl3oolZbT6qnQLwQ+7WRXTzW90Pq/qaC/ng35aaWpV+RX6vJKJU6wrmr/Rj3F9DugjJgenyU/vvsC6Snq9N1hLw9XKuXBd6inZ2m8y+XZ0/5dGii0ylpd2uE3SlOKrO3wKwtTSn3Z4S/OC/7VfvBnBf8aL/jznfrd6QW/3pHPLj/4TcG/1o/+dPjf7QW/WhX867zgtzr8X+8Fv9bBv8EL/mKn/b7FC/5CR/9v9COfTv3e5AV/uS74N/uRT4f/W/zw37H/twG+5VyE4N/hBb9UFXncHnTDuFImoS++yK2QPhfzV7A4TmgVCMuX36eVDfnncd/twA/KIA7r9oxYU0qcjzq9zVFupD/t4JXLEQU+A2elMonCSUOso4ZYZ42wNN92EL4eN+RrhxFfmv87CNZVhljrjLCiwBcfDsLX1UZ8Rc/XDCnWTkOsXYZY1xpi7TbEus4Q63ojrCjwhVSD8HWDIV8vhnZ8vcWIr+j5RkMsq74jer7JEOtmQ6xbjLCiwHOnw4L1zjaW3/mu2oLf+a5qw+98V63pd76rXvU731Wb8zvfVVsSX31X0A25oFe3sH+zG1fUUn8LKvQLxKstP93x3bXED8uH9+/sVngtKnHcRncrdHYrdIpKHO/lHQTrFUOs44ZYzxlinTbEOmmIdcgQ63lDrFOGWC8NKZalrj5jiGUle63fHhZdtWyP5wyxhrU9vmyIZdmGhlX2zxpiWdoJy77W0kZbyt5SXsOqX5a+iWU9Wsr+YrATrxphRc88hh2EryOGfF1lxJclVhSeCO34utqQLyvZR+GYIZalTuwM7LDWGWFFwUononDUEOtJQyxL/bLky0pXh9kWFg35stRVy3q0tKvDKi9LXeW51WFp25b26zVDLEv/62lDLMs5hVOGWJZjBcu5R/HvZR57J8Tl2n/9rgGUVrwGsNMPP841gJ1Bv1y1/bCG/DTT1DPyK3V5nRInWLKWj3v7Mf1uKCOmx2fJj+9+ql1xRcKMAu/tv04pD74T+UZ7+398vLdsWDesp37qIf0dsEK/EHhtN2WXXlyryFHTC8lbVOLYp09bX1rd8963QbBeMMQ6YYh1yhDrpSHFOm2IdcYQ6xlDrEOGWC8aYlm2Ict6fMUQ67gh1jlDLMu2balflm3I0q5eDLJ/3hDL0kaLLdS+ozL0P0rad06G+J1vDq53yALp814cidf+ChbHCa0CYRmXrewqm2vshn447+3VsK7PiKV9G+ejTq9zlBvp+/0WsF7x+y1gfdbvt4C1ZdH5t4A8cyS7m7zU5Xzqs1SEfoF49dWmbiJ+WD48HrpZ4bWoxPHevZsVOjcrdIpKHPfbg2C9Yoh13BDrOUOs04ZYJw2xDhlivWiIddYQy1L2w6qr5wyxThliWeqXpc15wRDrYpD984ZYlmV8aUixLNv2M4ZYVrKPnnlf7rDo6rD6AJZYo3571G9fKH3HqN8e9dujfvvNKfth1dWXDbEs5WVpcyxl/6whlmUbsuy3h9VGD6s/YVlGS9/Xsh4tZX8x2IlXjbCiZ96fMwjWdYZYVvPk0fP1RlhR4L3Hg/BVNOTriBFfUThmiHXUCCt65vWvkezdZeRvJwbBusoQ62ojrChYyutGI74sdTUKlm1oWPV+WMv4ZreFlnxFYdR3XPh9RxRCI6zo2XLPg5W8oudrDPl60pAvq742Cpb9o6W8hrHviMJrhliWY76nDbEs13Qs5wEs5ycs9+fw9224NyzX/qudFx/R2dP+XRosNHNET8qB75B+gXg15qfskutNily18+4N+VnKET7yc4siH6nL25Q4wZJzMvH7Nkx/C5QR0+Oz5Md3k/k3/hYJMwr8fZt2Vjq+E/lOCqGgf0+i4EXBbz1UUn/fJvQLgdd2U3bphdb+Nb2QvFp9cb+ftr40rNOGWC8ZYp0wxHrBEOsVQ6xThlhnh5Svk4ZYhwyxXjXEOmyI9ZohlqW8zhhiWbbHc4ZYlnpvaQst6/FpQyxLm2OpE88bYlnK/viQ8vWiIZalTlj6Jpb9tmU9Dqv9stQvy/Y4rDbaEstSv54xxBLZT7fjcHyTa//1fAdcLUf0pBz4DukXiFdbfrpjPU2utyhyFdmluV8sera8s8nqHq8ovGCIdcIQ65Qh1ktDinXaEOuMIdYzhliHDLGs7kaKwnFDLMv2eM4Qy1K/LOX1nCGWpX5ZtiFLu2qpE5Z2dVjbtmV7tGxDrxhiWbbHi0G/njfEsvQBpK+dacehv7076KWT1efH/JJuWsmXa//1e4fvQurzOoR+QZGJD5//9pRyFdndofBaVOJ478odCp07FDpFJY77pkGwXjHEOm6I9Zwh1mlDrJOGWIcMsV40xDpriGUp+2HV1XOGWKcMsSz1y9LmvGCIdTHI/nlDLMsyvjSkWJZt+xlDLCvZR898Xsew6Oqw+gCWWMPab1vK3tIHsLTRlv7EsOrqqN9euz5t5JNnwxr55GunXyO/cO30axj9wihYymtYdfVlQyxLeVnaHEvZP2uIZdmGLPuOYbXRw9qnWZbR0ve1rEdL2V8MduJVI6zomfc4DcLXE4Z8XWfEV679zgrLcn3IUl7XGPJ1zIivKBw1woqe+Zv+YdCJKPC3zcMge8u2bd0erdpQ9Hy9EVYULNvjxaBffN7QIFhXGWJdbYQVBUt53WjEl6UtjIKljR5WvR/WMr7Z+1pLvqIw8k0u/L4jCqERlqU/EQUreUXPlj75k4Z8WfW1UbDsHy3lNYx9RxReM8SynFN42hDrtCGW5TyT5fzXSUMsPm+oCHG59l/Z54u2LqKzp/27NFAopz5vSOgXgv6+yo6f7j7f7UG/XIuKXEV2OxRei0ocj413KHR2KHSKShyv+Q6C9YIh1glDrFOGWC8NKdZpQ6wzhljPGGIdMsR60RDLsg1Z1uMrhljHDbHOGWJZtm1L/bLky7IeLfmytBOWOmFZj88bYlnae7Gr4luxT7Cn/bs0UKjXxTdBX0Z8qqmg3zcx9Ovmc0RP5ITvkH6BeLXlp+vXafWG8mG/7kqF16ISx3V4pULnSoVOUYnjtjkI1ucMsSz5esEIK3reENhgWZfxkCHW84ZYLxliPWOIZSmvc4ZYXzDEetEQ65QhlqXsTxtinTTEsizjq4ZYhw2xZJ6PfYso7Gn/Pd8dVudnq5X52Uql2So1mrNzywvVuVJ1sV5dWFosl6r1ynxzrlEtlVrV1lKt1JxdqDdbjYV6dXmxsTDn13eoL0wF/Tbe0DcpC/5VfvArgn+1H/yq4F/jB78m+Nf5wa8L/vV+8GcF/wY/+HN+zz4ozwv+HX7wO+2r5Ae/IfhlP/hNwa/4wW8JftUP/rLg17zgV0qCX/eD37Gfs37wO/Zzzg9+x37O+8Hv2M8FP/gd+/lWP/gd+/ktfvA79vNb/eB37Oe3+cHv2M+/4we/Yz+/3Q/+ouDv8YO/JPhv84Pfsf9v94Pfsf/v8IPfsf/v9IJf7dj/d/nB79j/d/vB79j/O/3gd+z/e/zgd+zne/3gd+znXX7wO/btfX7wO/bt/X7wO/btO/zgd+zbB/zgd+zbd/rB79i3u/3gd+zbd3nBr3Xszz1+8Dv2514/+B3780E/+B3/80N+8Dv+54f94Hfs50f84Hfs50f94Hf8z4/5we/Y5+/2g9+xz9/jB79jn7/XD37HPn/cD37HPn+fH/yOff5+P/gd+/wJL/j1jv/Z8IPfsf+LfvA79n/JD37H/jf94Hfsf8sPfsf+L/vB79j/+/zgd+z/J/3gd+z//UE3dLGrrcXzSy31xuz8Ynm5MbtcWqzNzVcby3NzzUZzodaaq5ea5aXZ8lKlvDw/36jXG0v1hXJ5ubVQX57v8P4pFXuQ0F0X+bQPuZSXO3ZhL+DnzPif7+B/xku9dvEf8CKfZscu77Ou23KpFN3b+WJ7MXAGeJdyTFGdtK/47NxJGoXPhL3llnhMf7a9STqi93Kb3jTlEYwg6K5T5n3I9PxaR47oBVTugOgXgn7Z+NiHlCd+WD68D2lS4bVIcVHgdelJhc6kQkfDes0Q65Ah1ouGWKcMsc4YYp00xDptiGVZxmcMsYZVv44bYp01xDpniGWpX5byes4Qy1K/LNvQC4ZYljphaVdlv+JU0N8X2vXNsw3pa9G3liBx6BtPUNxeSP/esJuOwzj9xjKtP/8vv62Ly+mYH/SbPg34cT5DFLR955Y+juBP+cGvik6tD3plymWaipGVxGt/BYvjhFYh6Je7D/9QKxvyz+1lPfDDe9E1rPUZsaaUOB91us5RbqQ/7eBVK8ckyUSzR5r/LemnHHxh+hmFtuQVGRYgzlCGFZcMsS0K/Y3AZ7O1+PB97993X0BhnOQgcttK6d4XduXAOrg+Biug31vp3TjgYfA7ZlzbfkDKlLUfQNl+muJWaveiwLaBZR6FSCf+2jG3gHlQh9LOLUj6X53u0vubNj3RBamDKOxp/y1lCxV+4bkf6+hZIegPEofftkzAMwdNl4TvSJe2rNCn2EBxaEc3Uhy2+WmKQ3t4Sft5RikX68oElZHfufRzwkFnckA6kwqdaSXfoO1Nk43vdj1JdCYN6aDc1hGddYZ0tP7Hsw+zIOVAXyGgMmLfz3qDbZ3reiPEcf1MQxzL9BLg4cGwm46DZj9ETtHf2RT242KWb/SMPiOHkXy7cWnkuxIZPpihj8O6KlBaKVee0kbh7rCbDss5oeSPwqfDXixJP7u+y/cz27rlY5uv8Z4jfrW/gsfv2E5i3N6wl47Wv/idgynV05QD6a/WeFwbL2rjP80XkrzcN0VBZJ5T4saVd2MXMJZvfyKNf+R57iu1/gr91dJf17wKyjXLvEoUWE9WOtd0IWD59lOz6K8nHyC1/g7rfCj7MJi3SHFRYD3R5vmmFDoXIha3bcHX/godfueaK86iv57mVFLrr9BfLf1NO3+s+dlTJHP0V9kfLSh0CgqdCxFLG58Mqr+oh1n019Mcfmr9Ffqrpb9a/bn0d4PCa5HiosB2boNCZ4NC50LE0uZ7B9Vf1EPWXxwvy/x65C9/bn03D+abCPS1MMnLY9jDMB9/Zn0vbW0O1O+6Tfq2w3v9Jvzw49zrp80tu+ZRRm0n3iavtO1oawVp9BfrZy30V+ivlv5q9efS340Kr0WKiwLryUaFzkaFzoWIxW1b8LW/QoffxbWTrPqL9bMW+iv0V0t/tfpz6e+0wmuR4qLAejKt0JlW6FyIWNy2BV/7K3T4XVw7yaq/WD9rob9Cf7X0V6s/l/5eovBapLgosJ5cotC5RKFzIWJx2xZ87a/Q4Xdx7QTrQ9trkKM4pDdJcdr6+Az9jp7XU5y232yGfkfPBYrTxg8z9Bv7mpmgv+/ZSHHYrqcpDmWWo+esdiqXks7kgHQmU9JZNyCddSnprB+QzvqUdKYGpDOVkk5hQDqFlHTyA9LJp6SzYUA6G1LS2TggnVE7HbXTUTu9MNupX1+4WRNeNd8rp/Aq72eU9JOO9EUl/TpH+kuV9Osd6Tcp6acc6S9T0hcc6Tcr6fOO9FuU9Bsc6S9X0mtzD+LfXgFxUk+iK1vhvaGupB43Cf0C8WrLT3fctFWR3RWK7PA7iPtaBz+w72DrAPKNWP8K3mM8BkmDbSEX9O4ji37zGEHaGr+fiXlfjHl/acz7TTHvL4t5vznm/ZaY95fTewl3hr2/P0O/3wm/2ZZyyNE/fh+3d27Q+MAjtnW8vBuPec7Re3mH+qm1F/nGRxvHjlG+CQe9ccrDvI878JnniQSe7wp7edZort2aVb2cI3pSjoDKP+xrVmnPp5D9sDklzuUvaFh3G2LtHVK+hhVrWOU10q+Rfo30a6RfSVgj/Rrp10i/RvK6ULFG+jXSr5F+jeR1oWKN9GukXyP9GsnrQsUa6ddIvy40eQ3TNxST8N5w/WLF50f4Xk/R6s+1npL2/AjWuUHOaRh2rKTv2v7tVC9NkVseaGJeWZfmc+b+1cYu5p+2MbX1Q94vi3qG6ZiuxguXn9c748rP7cqPHtfm0rYrob9a5+hPpJQr2z7My7YsCnHn/CAd13msGLfXEMuSr2HFuhjkNdKJkbxGOjGSVxLWSCdG8hrpxEheSVgjnRjJa6QTI3klYY10YiSvkU6M5JWENdKJtZeXdpYEzqdiHNJx3VuB+Vfr3oo089crpaOtBbjWuTyvPy2mKQfSv9DPL8d7ezgu6zrPCGuEtRpY2lk72P7i2otrvR3zS7ppJd+g9k7j2ee6fhTYruaUuIivHyt0cVH2+aArQ8zL66+S/mOw/vqTbUztDCTXmUvjFIdlnqQ4TabaGUh8bkjWPn5dSjrjA9IZvwjKMyw6/xuk83KOQFqdl/TvBZ3/Kuk8ngPDdkp+49m9mJ7vspH0/7BNI0r7uW3JmNrdaYz5NcA8A3fx+Kwn2e/m09ZGIa0+/HMjffjHG7qY/7LQS3sM8guW+LV+9ltUFtLIEOkXiFdbfrp+7Tjxw/Jhv1azS6Ox9HBhjeQ1ktdIXiN5XahYI3mN5DWS10heFyrWsMtrGPbb89+A+GE6PsbBWvm1+Uhe50FMHLvesaGbBzG1sSvi5in9czB2rbSfte8nXHN0eYqbUMqao7gg6J+vCAJ3XU/EYOWBH5yDHod4TP/Wdjmj8fvZbTom8odjVD5Xb9zBXz4Bi8+70+6PF6zJBKx7CQvzTxLWugSsewgL86+LyceyS/Nd2bDd6+r7uzJN7q7vytYrvBaVOJ6zXen9qVp7HQQrb4glOjgV9OvrnvbfUrZQ4xfDdmc71gWHcfqNfEd/t2S4Xx31p0BxWIcbKA7twkaKc527rvUr3I9JGfldmn7V9f3fSunkFTquOd40Nkij49u3Wat1GtQX32ut64gO5kMfah/5UElroNIv5in9E+BD7W8/+/3GszTH7QyD1n+wzvKdvhjnuqcSz9FHmXPQ7JPIIuLrwQz2CXVCyrQhcPcrWr8q6bX7fddTmiho69iSd1j7Cq2euH7xjgKuX+2OD4nDu6pQJhyS+qbZFHXPbVJwuU2KP67piuTFtp5mbKPtMZD6nqF8e9q/SwOFckn4Lwb9QeIuVcomcZsgjseQl0GcZl8laPUm5Y3q7eUMbRbbxaUUh7ZnE8WhTl9GcajTmykOdXoLxaFOX05xqNN4xwGWPa4/4PVgSf+jML786jYdcyxw9zHC83jYzS86K/KbgDjL9eOI79+hPQGol/mwt0zaPR+Ynu2vds8H6rbIqBj06zbbac2Pw7sI0D68nibs5hce10Ke2GexPLV7WVz3plzqkAHKqBj0y5rvI9L6Rm3+Q5On8LgW8kQe08hT8/UlfVFJj/KU8hUpPdsvrrfxoF/GLnmuZXtHHlmehYQysTw1+aOcREbFoF/WfCcxjgW4HlxzXpqdSOtHSF5t3tW1Zwj74jyl/68wZvinNGYY+Rhvfh8jCPp9DLYXsobC/sU3wL/41+RfSP6JQLfpe0Od3r9TMIOgX8e5/d8dg/fNDHgbUuD9hwx4G1Pg/WVGGaI+xsnwP2Xg8ZIUPP6VghfZi3dv7OVX67O19bM09hvbr7anlfu3KSiX5quwjyzp/zuU7Y/aZRP7h/2pof0rs43DoNk4tn9o49j+bSa5BPAXg2b/pLxZ7d+w2ziJw/4M77XDsuN4CPXnYNibXhs7uHw57Y5ArGOhL7qO/R/3aRpt7EvfR7xuzsirdt8g6tUm4hX525KR17vCZNouXrW7Drc4eMVyXJ6R13vDZNouXq9Q0l/u4BXLcUVGXu8Jk2m7eHXdg6jxiuXYmpHXh8Jk2i5etynptzp4xXJsy8jr/jCZtovX7Ur6bQ5esRzbM/J6IFxdXosKr9Lfij27oW3Yp4J+G2g4b11CXOY3IJ7YJ0Cbxvzf1OY/6hv+mPy1zvgY3mH/tzmG3q0KZkBp2EdF+8B4d2TAw3728hi8SgY87JuviMGrZ5Qh9ulbYzDnM/CIfkAxBu9bFLyZoF9P8jH5/w58m/WOjfH5eX6gAHiaTxw3Bno78Psn2/ppa3vjHgh74yYVOpqfr80l5eCdaw4DceO+e4qbk2YfTBs/uOzZBiW9Nv+j1ZPk5Xr+TqjnD1M9u/aguNb+ovC+mLJOBvpaIeu4pP8g6MWftfVCm6eaCvrLYV3fvxHzrW/a+k6aE846vhT6rvElj4W/H+r791PICdcN4+o0bXks9Dctr+yXb8jI60Yl/QYHr1iOjRl5Zb98Y0Zep5X0Gx28YjmmM/LKfvl0Rl4vUdJPO3jFclySkVf2yy/JyKs2336Jg1csx0xGXtkvt15rYV6xHMWMvB5YZV7XKbxqNo/PRuD5f42HvMJDFHi+TdKH0B/9+TYdcywGU+S2dmt+tTltjQrn8fJhb5lca8xSVkyfdp6oSOnZ3sfpoTZPpMlTeFwLebrW/DTdd635ucbIKCNtjZ/nmLX+WvPZNHnifq0oTECcb3m61viLCWVKs8avrTtra/zsg2j+HMp47df4dXkijyxPl48WhTS2HOXkWuNP4yelXeMXHoetvW9IKNNK/c5i0C9D9uXejO19Q0KZssqT27vL3xy192R5cntHefLZS9qeVG3PGduHyUD3G3HfOab/LcccAu4rZ10YV7A1n5TP1kozb5J1nfcfKX6npmfCl189Ky363uuUdq6gGOh9Mz5rejbIXBXrmaT/Fw49w7lJ134r3GvN8zNWe7j5zDrXnWGIk6f0/wbmkhandV7HFMwo8HiX+/4o4BwO2w6c79PS8zyzpP9jpY6YZ61tYv/K3638CWB+NWY9IAj61yGjkHXOzzU2jttTEgR+52j/wiHTpPWA6RjM/9chU802uGSats9yzeW5fAfRba18SXaMvx9KW3dx85tp607S/7Wj7pL88XtS8OBa+5H0f+PgAdctXPOFzDP261gHcnYe+wh/Czz8R1ov0+aYXDLS/FHN35B0mt+bi/krdPid65tf3mOlnfH3ep2RDddkj3n5Oz5J35ruYk62n7VvgtiWIc+8rphVzhodWbNHv97OJyrPi3xx/4cEidsWU0YO4/Qb+Y7K859XuL93G8Vh+9xOcWjrdlAc+vVXwjOWC8/SxH5NdG4s6LeHqF+e93Fnri/+phv3s2T9jg/3av/vDHWJOsN1iXotvGl+Ao9JpFxxvpqsY67deKNe1sYbOFbMh71lcq0xSFkx/UrnBaPwANHW/PS08wTC41rI0zVPUEwoU1Z58jkcOM8a16cjlrYuvXbzgro8kUeW50xCmVa6ZqbNs6b5Ni3tvOBatnfXvGDSXGfWb6l4jK59S+Vq72nnrVdnXlCX52rO13B7Rxlm3S+x9vPW2dt7IaFMlvNfWc5piMLF0N7TjsM1efJYRDtD7EJo7y791HTEpZ9J81R8fw7K+hKKi5v/5DlFTe7op/L857jCT/T337YZ1fZDse+hzR1pc7k5KttkTHrB4+/XPtUuqzYHcgnk0fZ3TcdgfgYw485PwHK55tCS/A/hx7W/SGsPInvP6xV1rT1g3abxzzYOIB9uD+ifcXtAHeS+UbNj2C64DaDu9czPUduSNohjdmxbMmbPU/onQcfO0ryZ9h251uZyVJ6NCs+5oHd+FHVeqx+em5L0TyltQtNLPK8mChNhLx972u9LgwVVL3EegPXStX8yCln3MIrMikr6d4a9cahLQlOra/ze83W6YTduJNfud88S5zrjD+WK88Wv0w27cSO5BsGhsDdOW7vT5CoyG8lVH+9OUJy2fqfJFedLX6cbduNG+tpvX9FH5r1cfJYk+wLvpHII3UklPeLxd3RfUfzQImBwfva1oyA+SET7c+1GqO2R53loXpdh2fN69QyUcVxJw36xpP8tKOPXt/eWEXkSfvyuQ8w2RIafCvqDxH0aaPN63l5I/96wm47DOP3GMkWyyGdYh8B6RN4QE30zrNu4evknUC+/u73LM9PDNsrlkN/3K/S0/e5SNr/f85bLOaInZcN3SL9AvBrbxc5Z2mn390f2QezH3n2N5jsaDx54eG9rjETJn5IIfJHgJA2mxVAEljA9H4M+Q/m+K+zPx0FEqX0mcinxpJl3bRlJW8bAZoCy+a+wPP6H7WdtSYtV089xLqWltKop9AuBT3PYVc20S3giH09NZTEX9DeLcYUmTnOwKeF2gZ/njyvpL4UyYnp8lvz47t+39Yk/B4kCX0uiNX18h8e1/VvaxoHl4U/dtHrTjrHUXE2WIbZj2bqjbWO5m+LWOeLWO+KmlHJpy6OfoXzaUVkRf2+9pIsXJxvUK3FfNNsUZ1vjsPhaDMy/ibAuS8DiazEwPx/vszkBi6/FwPx8/NOWBKyHCAvz81E+lydg7ScszM9H7VyRgHWAsDA/H4WzNQHrIGFhfj6qZlsC1sOEhfn5KJntCVh3Ehbm56NediRgPUJYmH8HYV2ZgPUoYWF+3qp0VQLWZwkL819FWFcnYN1PWJhf8k4rWOwHXAPv18IPEPoF4tWXH3BN0C9XlM8YyW6nwmtRiWO7tVOhs1Oho2FtNsTaYoh1uSHWFYZYWw2xthlibTfE2mGIdaUhFtutpP76g+Ebf139teRD3cV045BG66MRI84fwDEbvr86RXnwHcvm6hh6cfyhbGS86fI/ZiifxvOlCXRcPPORvegzy9ZEbTmQ/VvtmAX2maNnPiJzSikX+8xYr+wzo9zQZ85Teb6t/d7vdJx+9BrLiucltL9B0N9/RoHrEtNMrAKdKHx36J+OVp4ZQzqI9V4qz+pP8ZVaacqB9H1P8YksNjtkscUL7Vrq6c4tJIvNnmQhdjZp3JbmGFGtL8Hp0ftaB9+/7763P/bBxn04DYFmldmZpnR80uNlMWztoXRb6Le4f8wHYmFgPtgscPo9CenxOe5rF21Yy9OwWrVpu5W0adgrHHQ2D0hns0JHmha6uJaqLPjb/eBXRRZJp9Ly10J8Ir/2V7A4TmgVgv468mEGtLK56hmHGGmmXLZlxJpS4nzUadKpyPxFkcarVg78ghzt3J+2XbYo/lOX9GJrtmIq6LcVdnKozqbVR6FfIF596WPSzlae4tBOn+DdRFEIw246jhtX3o05sF4wxHrZEOuMIdZJQ6xDhliWZbSsR8synjDEsizj84ZYLxpiPWeIdcoQ65wh1mlDLEudsGyPlm3IUics5fWMIdZLhliWsn/aEMtS9mcNsSzlZWkLjxtiWcprWG2hpbwsbc7F4DNZ6oRlv20l++g5zRfSa6H3lrJ/1hDLUu8ty2hpJyx9AEt5vWqI9RphpR3XS/q0p8VpJybhl+/Rbz6dbE/7d2mwUHHJCZcChf5G4LPZWnz4vvOT4wGFcZKDyK1O6WR73FjQb3PWx2AF9LtO78YBD0PEw1+3CfB8WADp/c7HVis5osdlDIh+gXg1rv/OnJXrdq0g6J+z2qHwWlTiboRnjEM6OxQ6RSWO++1BsJ43xHrREOs5Q6xThljnDLFOG2JZ6sQZQ6xDhliWOmEpr2cMsSzl9bQhlqW8XjbEstTVk4ZYF0M9njXEspSXZT903BDLUl7D2g9ZysvS3lvql6XNsWyPljph6TNZyT565jmYYdF7S9k/a4hlqfeWZbS0E8Pqf71qiCVzMNqnRPwJgzaG3e6gg/m3p8DSxsOSXvv0yDXXo316JHMPnj7BqbjqQ/t8aSVzPSK3MqXjuR60bVfGYAX0u0zv4uZ6eN/Sve29xSJfT/vR1K3mvF+xCHG8L7IIZRhX3rH+ap8ra3Q2D0hns0LHryyzn6LBn03shTj+xOEzgCWf/uYUOuP0G8sbtYvf297F5XTMK9bHp2Mw80raCYqTtK2ZLh9/1ObD777D1asTvA2Dg1YnUt5IFn88YJ3w/lfkW/tcGjEwTnjld9y2MP8mB52bBqRzk0JnWsmXi/krdPgd09F4ds23r5QOYkkb9jt3n13/Wc6o/7w39zMQN0VxD0AcrgNx0NqGyCJqGzt3dHE5nQS/602rJ8MixaEMsW1z0GQoskgrQ+3mIW7bRaUcWrvnW6CytnuNh2HrJzZTHNbxForDOr6c4h4AOvxJ3D7Ix5+xPQhx6yjuIYjjG372QxzfJnIA4rCuOST1Zx9IoW/aETVp+jPtCBXB9ftJWbWaxu4j/QLxastPdx1U+0RYO4lcZHe5wmuR4qLwZNhNx3HjyrsxB9ZpQ6yXDLFOGGK9YIj1iiHWKUOss0PK10lDrEOGWK8aYh02xHrNEMtSXmcMsSzb4zlDLEu9t7SFlvX4tCGWZT1a2i9Leb1oiHXcEMtSXpZtyNKfsJTXc4ZYI7u6dnbVSvbRM6+DDoveW8r+WUMsS723LKOlnXjGEGtY/dXHDbHEX5V8OMbHNUvP5xhUBH+HH/zOOQmutVykz2N6idf+ChbH8b7ty/2Uzblv26UHODee5ojQ7Rmx1vI8E5Q1n2ei8aqVY4uhTNLcNOe65S5t3bqObPXcxjp7CrY45IT0B/l+pELpZJ1wLOivu20xWAH9rtC7uD0F2o3nUzF8Cl1+x7qi3bCn0SkMSKeQks6lA9K5NCWdzQPS2ZySzqh+eumsZf2IHcYzi2TdNkrzrUWdJh6pj2c18Z4JSX+g2MX89mJ8Gcep/Ggn5ChCsZ1+1hyyr5OxLPcq5ckpWNoak5Qp600x+I0e3xQjmHE3xayDeEz//mKXl6t265g5wMRvFfkWIWmzcbcIMQ+S/m7gQW4RYsyJmHKtj8FcBl28t6hjBgqmVq4ClYt5mCIeJP1HoFx/Bk4TppHfqCf7wl7eNiq0gph3bNM2xsS56CbljZ7xFiGOY11heWH+OJmyrkj6Tzh0ZZ3CA5aX65V54DSFGB6aCg94bOXSvgcfa9/qE1DgW3cm6TdXJVfBOgUnLogYIhrLRR0H00lg9cOueL1CoxDDI+aNytERX2tv62ArRkBjBDYZQ2ws0MNUoOvCnvbv0kDBT7+h7a9A28tB61OkvK/vk9ndxeV0EvCb7JFftTK/irE0fykK94XdeEx/BOwI3yo9CXxomHKNjKtP0/YmSXptzOjyuVEfeZyu0dZuUpb0l2fkNWm+YYp41caiaXm9a5V5nczIa0GhjX3PeeN6/yOt/R/Yd7BzinagsBHQM/c73E9xf7E+hlXur4r0m49VZvN+Gf3eqPCnBeEDA/MyHiQHaaIiqzPQRO8g91gzIdhE+QJxHEJJXhx+iUo8Cul4GP1ZKg+mR5qS/jGgo7k4j1K5Jf3nFRdHG5oLP1OU37bbnet0u4eC/iBxh4E2bzN8HNK/J+ym46B1rVKmSBb/Y2sXl9MxP1iPyBtiYpeBdRtXLz8O9cIXeyK9zwbx5ZDf6xR6LEuJj4LU8ePw3q6O640c0ZOy4TukXwj6Zetjmv9x4oflo5lhx8Weh+AZ4T9GcJIG02L4GLCE6dl0c7XvUPJxEFHmieevwaj6Z8lsYdPn7gF5GFfesbe1XuFfo1MYkE4hJZ0LuTxpLoDMK2XVLofkyxofhDi+APIhpVy8e1vDPODAPOiIe9gR94gSF5XrbZu6PHL3ojV1vlQS6y6uXcdh8aWSmP9xwnoiAYsvlcT8TxDWkwlY9xAW5n+SsI4kYPGlkpj/CGGFCVj7CQvzh4R1NAGLL5XE/EcJ61gC1kHCwvzHCOt4AhZfKon5jxPWUwlYdxIW5n+KsE4kYPGlkpj/BGGdTMDiSyUx/0nCOpWAxZdKYv5ThPV0AhZfKon5nyasZxKwPkhYmP8Zwno2AYsvRsP8zxLWaQdW9Cxfe88o+U8T1ucSsK4iLMwveacVrFz7r7iTz8F7O/etnPorF6FfIF5t+em6k88F/XJF+fBXLs8rvBaVOOyLMA7pPK/Q0bAOGWI9boj1hCHWk4ZYRwyxQkOso4ZYxwyxjhtiPWWIdcIQ66Qh1ilDrKcNsZ4xxHrWEIv7MpdfHz3LqSsuv17yoT3j6a5xyoPpESNu3DAe6OOBz6UoD75j2Xwuhl4cfygbufh50HFK9HwdYa10nBI9X09YKx2nRM83ENZKxynR8+2EtdJxSvR8B2FhfrbtxxKwSoSF+bOOUx4Le7EGGad8nLBWOk6JnstUxpWOU6LnCmGtdJwSPVcJa6XjlOi5RlgrHadEz3XCWuk4JXqeJaxBxilzhOUapzyXgDVPWJj/OcJ6PgFrgbAw//OEdSYB662EhfnPENYLCVjfQliY/wXCejEB61sJC/O/SFhnE7C+jbAw/1nCeikB6+8QFuZ/ibDOJWB9O2Fh/nOE9XIC1h7CwvwvE9YrCVhvIyzM/wphfT4B6+2Ehfk/T1hfSMB6B2Fh/i8Q1qsJWO8kLMz/KmG9loD1LsLC/K8R1g8kYL2bsDD/DxDWFxOw7iQszP9FwvpBB1YUPhL2YmH+HySsH0rAej9hYf4fIqwfDtxlfE/Qi4X5f5iwfiQB672Ehfl/hLB+1IEVhU+GvViY/0cJ68cS+LqL+ML8P0ZYP56A9T7Cwvw/Tlg/kYD1fsLC/D9BWD+ZgPUdhIX5f5Kw/m4C1gcIC/P/XcL6UgLWdxIW5v8SYf29BKy7CQvz/z3C+ikHVhTuC3uxMP9PEdZPJ/D1XcQX5v9pwvr7CVj3EBbm//uE9TMJWPcSFub/GcL62QSsDxIW5v9Zwvq5BKwPERbm/znC+vkErA8TFub/ecL6cgLWRwgL83+ZsH4hAeujhIX5f4GwfjEB62OEhfl/kbB+KQHruwkL8/8SYX0lAet7CAvzf4WwfjkB63sJC/P/MmH9SgLWxwkL8/8KYf1qAtb3ERbm/1XC+rUErO8nLMz/a4T16wlYnyAszP/rhPUbCVgNwsL8v0FYv5mAtUhYmP83Ceu3ErCWCAvz/xZhfTUBq0lYmF/yTitYufZfWef6bXhvt65UK+eInpQD3yH9AvFqy093neu3g365onx4nesfKLwWlTiec/wHCp1/oNDRsJ4wxHrSEOuIIVZoiHXUEOuYIdZxQ6ynDLFOGGKdNMQ6ZYj1tCHWM4ZYzxpinTbEes4Q63lDrDOGWC8YYr1oiHXWEOslQ6xzhlgvG2K9Yoj1eUOsLxhivWqI9Zoh1g8YYn3REOsHDbF+yBDrhw2xfsQQ60cNsX7MEOvHDbF+whDrJw2x/q4h1pcMsf6eIdZPGWL9tCHW3zfE+hlDrJ81xPo5Q6yfN8T6siHWLxhi/aIh1i8ZYn3FEOuXDbF+xRDrVw2xfs0Q69cNsX7DEOs3DbF4zjFpn5wci+HaJyf5cN6JP80cpzyYHjHi9uGNB/r+uq+mKA++Y9l8NYZeHH8om+X2s8W+v/sIa5B9f58kLMwfEtbRBKwdhIX5j1Ic5uN9oocddKLg2id62EHnqwPS+apCR/tO8YGwNy6vlJW/U4ye+dvHByHuEMU9pJRLu2XmcYrDW2aeoLiDEPckxT0McUco7hGIC9vP+J2ifI8rMnpn+/0UlU3S7Gn/Lg0YtNsVWY5Yb7mYv0HQvzYRBdYPTDOxCnSiwLcWrVZ5DhnSQSw55kBrv3ii2EraL+Y/HIMlRxtEAW96xNNyMP2H20oWfX98dlsvprZHPQ/v3ucoq+SVNsL9257279JgoSz4R/zgV139I5aJbQrKLot+Ia0CYVnLzlU25J/1EPvrNH7EkxmxppQ4H3X6hKPcWh+i8aqVI65tIp2Nikwk/REHX5je5T+JDEOIM5RhxSVDzQdbySnIIrcdlE7szljQr4NPxmAF9HsHvRsP3KcgY51Ox/ApdJPsOOZnP+ww8aX9FTr8juloPAsdPM8CT6U9SGcziN7hkTn4HdWVEI/p/+nWLuajbUztO6+4tpIDeq5TzYRe3FFLkzH8PQ79Hp9oqZ0sd6WDZ8GcCPrpRkHO/WAejpIf6amPVP1IoaWdiMbfNGc9te8xRQ5xso0C+inox2D6Uxn9FNRv9lOQJ8mrjfkvCZLpuPrJSxQ6g/oHGh2NZx67RQHb+YvUzkUfUOcxr5yHkKf0vwrt/JyjnfP+IfZp2PZxOxd6ce2c9UbSv+po55rP/F1hPM+Cie0ceeZ2Lul/iNq5J79GbedCS+vHuJ1n7cc0O67RmRmQzoxCx3d/OUN0njCkg1h8DlNce/0Zaq9Sr1p75X4b0x+D9vrz1F5R3131yX3HEwpdbjNBkG6O0vVtMtuoKLj6jo6NcvQdrjFAFFxjXNecMKbDNK5503EHDdQnfC8+K/ZpfLznk5T2CUfauPFc9CynL/sdc8+XpC2EQX+QuKMKzxJ3DNJ/KOym4zBOv7FMka5UdndxOR3zg3I6GoPJMo0Cn/4uP8cU3COEizaA5SXnrXH7/zftthDV+z/fpOOxnkRB5un8jivny1y/GLh+WT4ctPoN289R/TYy1C/W4TGKQ5stPgCPsxAjkv03yScYtra0kvbSGLC9aPLktQiUp2CgPPOEMXFZN82/J32XNNxfREHaj7TZUPCU/FFg30/S/yX0PT+7W6fvam9BoNsFlAOfNXo00HnRytyp+7acRB+xjdnpY63Tvo8Tz0j7KU+0c0QvCPT5V6E/rfAjfBeUuIkBeK2X5+Yqs7VmfXlxdr5eb+UIX3jldzx3eEJJf5mSXmR90ousq02xAeNhF/8EyDUKExD3FMXlIU54jNrQl3f38n/CE/9p5I/0i0p6PtU+bV0WFTo8VhsE64kVYm0KetuA1heib8N9IfoveB7sTlBQzS66bF0bps/uYznZDl5Ftu4o5DHUoZrmj7KtO+6JdlpbJ/Sng/i6LShxg9i6Zr1Wri0v1Beby9VWc245F/T3CePKO7Z1mt5qt0R4thUlzdaxPZuAuOMUh7ZOeNRsnZ9+sVpKI3+kX1TSs61LW5dFhQ7bukGwnlghltg69IOOtp81W8d+6hGlPGjreFy2m2ySnysd9DlCtqnIbxRwDH0E5MTyZRx8h34z5uE5G0l/C/jtN16m8ydluFvhT9u7hOW67bL4dEeUdNH6pcwJ3tc6eO8nG/tbzXtbS/tbB8cDnT0uIhefh1MBpYvCBL07SL95+iZPONIFp725TP4illZ1iM1db7ktssiE/SaZsEmitaf9tzRg0IaO3NX6WV6rpB5WCP1C0K9yPrZ1aFObKB/uHv0sS1RK0WVhvGQQhU+F/bJhPlyXi6H8uC2kWabMK3S06xdyMX+FDr9jOhrP8ttlauNM43eBaXz7Zd30bGvSbNlKsxSP7zD9XorDJbqcA5+nW94D9uLP6GJWdKmkHJ3LSSHOsj1HfPwO8MF6i+5aXDvTrguR9K6tZFGQJQ3X1iJNt1CXREe0ena1KR9L/xodHxcQ+m67lxKduKW6j8e0ybiluhrEY/oDsFT3CarPONv1ernCbtwqtZlK1jaj2SlXm0n6dENkqC2xfjTsjdP0neUaheWwl4e8woPWnxaV/JIujZ+C/NnVUTm1nyL0V8tPmUwpV5HPYT/yKbl087AiH94awHWHthvbvjb80Zb7sJ/g4eKhtj1wbSlwtR1tCf717X80LPLtB3HbGgce64Al1yP53vaB9pLrw1D3a1LuI45yM/3oXwhl0Lbbcnoe8zB+SOklP178rukW6+Pz4JM+fZmOGQRun5RlMhno/SUve0v6zyl+pFbHuGz4PPWrKEveavSkIofXt9Kl6O+1ZXzu7+dwKx3xpdkfza9iHz6rX6XRYay0WwQl/Q9AvfCFy0nXoqXZGo+yFX402cRtw5C2EQWxM9x24vQS28Y9VH5J/2NQ/q/T7aEh0IjbDhT3SeN44NavHP3jqbvo32aFvrYsEv3b0/5dGjCwLZsAGkcVfnj55mepvR0PemWaZBOPKXRxyngz0T1GdKN6/O3dvZhhO82GoL+daXXC29K5Lbwj7I2X9L8EdvYXqK+O29L/65fptAuBrodx7QR5xXZ4KOyNl/S/CvL6h7t1XpEfjVetjeIl7Fnb6L3Eq6T/qqONunRJ8+l4K4/WRpnvHL1PqxeS/v8CvfhHDh8O9eIPSNa8pTDJPoRUhj3t36UBA9clttNQ4Yfr8veoXNJ+x5WyanV6VKGLy0BsH44SXc0+4Cd9wsdnADNOj/MKz1HgNifpf9/R5iaVMmt6oPWxrk86QsDS0nNZJP2/STnvJ/6A3zmMsjrvh20nH/aWW7smWPOtWE5BjJzEdykGyTYZt3Fp4yU5jp/XZv4L2IlvxiyBCZ0oeF6OXMgRPZENvkP6qzUnkbVuDyv8y/yPll5rY9qcRzTnyHO4RcASunjV9RF6p81T8HxU3Njmv5Ft0ObAUO9kLKd9NrEc6jQRF2lqc51sJ7PMySXJQNP/NPqp0XGtLT1mSEfbDusaM8bpK79zzd2gPWbb5GOOJAQ+04x3jkIZ0vi32ien2vZkbrsTMbLjORJJX207Dq/3k5t7MUNHGaOA41LmSRu78jyA+C+TMTzz2FXSr2/zmebzOSxHFHg+QNJvAEyeD8Ctcmns7nElPfpqYftZaxM8bsQxINe5ho3px2NwjhEOlzPO1xYMbeta9G9P+3dpwCB4srULfd4TCj95Sr+N9PgUydQls+jfSYUuHpPNvvZJoqv52sIbjsWx3rlOeF2a9YrHXJL+GmjPV7Wfta2u2J9ev1mnjeOCpxy8Hld4xTbD4wJJvxvkxeMCbc4TedV8cmmTa+GTo93Kh73y0eyHaz4xrf3QthYeoTjs89McAZKmj5mMSc86K+nLUM88B67txYjwpV/SjhPh/QCPQRlc/RTXFeaNaM5t1nGxL0GZ3R/2llfS3whz5m+lNhg3H/atMW0QaWPeu4i2pP/TK7qY304y1NaUXGv3OSUujT87mZLO4Rg6QUo6Wnks/WZtvv5y4jnrWgbmX609IpcTnScVOp795tRjaqFfCPrbvY8xtetYSJSrpA+V9E840h9V0mtHT+GYGm14QHRxTH2U3mntnOcRs46xXPu8tPXPJDv3vRnt3MGwG4/pvwJ27vvJzg3bvrIrBqRzhULHt824gspz2FGerDqF+Vfr6IwriE7cPrmHSD9XegTNy6CfB1eon67jLlbrmBQfczQXQ3nezG3kWaM2chzayHPURrT9aK7jTlYq57R03gz1+aQhHW1uPklvvkh6g2twafRG0n8a9OaHU+iNJpu4ozKR7mrpmwvL5Vtq+5Rc85KuNVRMrx3PIbrg9/Pk9PuBhX6BeLXlpztO0OZwQkV2G4Pu3FSjdaBcmX9na2n/Yw8e5MoQwGLQK+SjBCjpA/rN+SKmJijNYYVGFPA8OVSkIuXngQjjp+EpKW1SvNYIw0AvZxCka4SYP64RilGKAm5ePgrxmP4rMMmV5jyvEN5lOc8rzoCMK2UoxOTDSX2MwzK/z1FmSf+bjjI/mVDmu6jMcefl4m9Op22eWR/oE+yuhcitQS/vWfUJ869W576V6MR1ul+nTjfpjL4HIB7TfxQ63d+lTjftGX18Dl9WOWt0fMuZz2J90lGerOeMa+d6u+rpAUgTtzlrQsGMAn8YLen/qF2Xns/mVr/xF1ra9+744eY3jHT4LtDhf+dYYHDpsI8JtSxtJResvK2sVnlcWFp7yBHPmP6CdmjLrVIaG4T0L3iH9k9yvUI+SoCSPqDfnM/l0HJaNoaiSIM6tBpPcWmzOrQ4kxRS2qwzxJgfV8GxQdgqUqXvy0RcfT0KNHlm73Eog+aoxc3K52Lw2VDi4S6a7HgnlKT/W3Bmv7b7jWetrrbF8BcE6eoK86/WbP42ouNjt18U+CvPJN2oEV9xTuy6Lb242gUQ2spyntL/r8u7mIU2Ztav2fjrbNdpFdqOXa2D0hzPuF0OSXrNMppQMKMQdwHEDW25+D2hpl5au9XoeupOmQ9u0r66KShxAx26ObdcLs3OzlWXK435Vn2W+y7hld+lWanepaT3O6NXUw/dDEGuUZiAuCMUl4c44VE7iC70xH8a+SP9opI+7mtiDSsKYx6w5PA41xdfvOMpCq4L2yT9TW2bkfYilMNKeVwXdIzTb7ZlbKuisKf9N6mGlxNCQHJbp/DCX8hJ2hLI5eu7e8uiHVIntmPcQSNQ3uWCeNkxjXEF78Nhb9yTKXjTJuwQ47EYPiMMbdC9k8qSdTJlp8KPz5UvpJnkv3w7+S9JK1+fDbvxmP4/gv/ydvJftN04Qk+bPEDfgW0KfomnTQizHZD0d6K+J1xgheVkHhEz7QVWkv795L942tGmTmgJrdU6GY6xJoLurnW0j98R9spK0m8BfbpnSzbMD8RgHtnSxfxQRszvjMF8EDA/6tD77UEvvaw7SjE/n7rC49A97d+lwULnstCH/OB3LpZ8UJEFlknoD7qDFmmt1peRWtlc9YyXQHNb0rAezIg1pcT5qNNJR7mR/rSDV60c7FdodLYrMpH0+x18YXppw6j7kldkeADiDGVYcdU3XvYt9FdyWajI7QpKx5eFouwfisEK6PcV9G480C8LjXh4pm3ntX6pGMOz8JDUL2F+1n8/NnOuqX3JK0H7khd55DBOv5HvqL6/ubWLy+kQg/WYLxN02dw4DG3uM6ndRwEn72Wx/8DBfftbd++//5HGwda7Hmk9cFDR3/VBb/km6PdB+o28Il/TlI4XZx+k3w/T70cUfjiwTDBMK+niQlL7uAWeV9I+ML9rXnH3gHR2K3RcWLcoWC77vVtJf7HY792UTsZ2g9jv3fQuzn4zLzh+wgsOeM5b0v8ojYf8+CQL1emg36ZJWYT2fk+0c0QvCHS/VOhPK/wI3wUlbpD53Mp8tVyeP78U3CrVSo1mydXG8B23yQNK+tuU9CLrhwMvslYvFjkAco3CBMTtp7g8xAmP2nyuH7uxkEr+SL+opOf5krR1qWHdtUIsmc9F2ytt229bz+5/8deZrhMtQ8DCuWcOmt8m5Y306fe2d3E5HfOK/SWfKOZnXL56MkRd5aDJUMqbVYaoayxDP2159WSIbZSDJkMpbyTDP84gQ9Q1nsNG2yR8D5t8JygO16HeG3bTcUiSYZ5OYsN0zI82Dz4e9Mspr2DxOOR+hR+x048Evfxj/UWB17Uw/yOE9VgCFm+WxvxpvpxDrHsJy7V/4YkErHsIy/WlzJMJWA8Rlus0xCMJWPsJy3UyU5iAdYCw4k6+jf4dTcA6SFiY/yhhHUvAepiwMP8xwjqegHUnYblOx3kqAesRwsL8T8XkQ/sWhWnlnbR1vxfPlTNfyKqNF3zMcWty1/xCkd0JhdeiEof9NsYhnRMKHQ1r0hDrcUOsA4ZYjxhiPWaIddgQ6wlDrCcNsY4YYoWGWEcNsY4ZYh03xHrIEEvmkbV50P1EJ+s8KOZPMw+q2dCN7X9ReH3e/B2NBw88vLcVUEC/NcLi+fKHY+gXlfwB5c3RuzTrNHl4x3MUYucnA32tkPd0SPqN7blxPL1rSslvOO5Y1D7qkiBx2D/wuAP9Vhl3aOMV1A8O2phEyhvJYufuLi6nk6CtLaBOXAvPGCf0+R3rOuaXdBqd3QPS2a3QcWFdq2BJem1M4Vpb0PaReb4Jp7O2oI3xtHHJStYWRG47KB2vLWhjPcYK6PcOepe0tiC8xH0AzGsLkn6urdtTCq929TFfdX234Hef+nzqtQWhP63wwyeF837IPSvkdXm+UlqqLrdK9eri4lKp6WpjWU+SeIuS3u+eunl1bQHnwaIwAXFPUFwe4vDEcV5b8GM35ktp5I/0i0p67rfT1qUllqwtoO2Vtu23rQ/v2gLuScgyL479JR9CgDK8CZ4xTvjhd1zvNym8Tiv5cjF/hQ6/Yzoaz9r3a7j/+T2Xd/OgXuH+Z8z7aNiNx/T/Gvarvs+xZ4PH6KyrqBtR4HaCp8Km6Q8l/d3gK/P+Z+3bikfDeJ6FRtrvtyT9h6hP9tMv6vufhZbrpDuWRxB068T1bZz2DZ7fMs61tO8HJGj2hvfQhhDHew+OQtwBisO53+8Oe+OOQz4e9+Cc6MMUp82tSdxJiONvUvHkc9RRDprNxENZPrCji8vpAqKp3dTDY0KUr7YP6WZ4xjjhld+xvmH+h2LysR3xvOep7LlNd/YVa99sYZnY19Xm6dP0L0hrtebRtbK59mrgPAPPI2tYj2fEmlLifNTpAUe5NZug8aqVg+cFtXZ2syITSf+Egy9Mrx02tNrzAZoMreYDRG63UDreK446+HgMVkC/b6F3cfMBmh2djOFT6CbZ0bTfmKC/eOJynWba7/0l/VfBX3wannlOjucxMQ5le6j97Hl/1YI23xGQ7A4BbR4D8fd+8swhaQ/V/0ix913bQ4W8ISbW32chTdzc8yvgT1+1W8fMBfoYgn160Ym03zRK+tccPr2kmYgp14MxmF8GXfzBGF0PFEytXPupXMzDQ8SDpP9RZV4/CPrtL+pQFPaFvbwdUGgFMe+4zzkQE+eim5Q3en4UnjmOdYXlFf2T9ak4mbKuSPqfduiK9i2Ha08p88Bp9sfw8HMKD1F/tKEdv7TvwcdilrN4+Yo/AeSq5CqYVHDigoghyiPNgXEwnQRWP237K+bdH8Mj5sUzrpqtva2Dcet9YwSWjyE2FujB83dRZW0PvgRtHyH3GzxuwbiDEIe2l4PWp+D3VGnXzV5c98bzavkkaXyNKNwXduMx/T+Cdsc3yD0EfGiYeHs0NyzX3IikTxqvCX2Rpeb3u2hr+xol/RMZedXWGtCHPkC8ug7JTOL1rlXm9aGMvGr7GNBWnzdG9z/S2v+BfQdb2DyYjYCep+hd3LYE+b0/htWNlI6nkfmIEe4f+DO/gwp/WhA+MDAv40FykCYqsvoDaKJ3kDupmRBtO4W2zRhdyxM0tNCWUFzqmOZYDjRNiMHHhkj6bzhMU9pLfyV9qKTHKVCeAsZmIHm1ZT6c0o3CBMQZDuWb2uV9KIN8mL68mnyOKulDSMOf3R+FOF4WRH3haVDswvCs3PeQ/mlHlrnK5tpCJLzmlbJFgS/Ek/R/5dA/bZuzdt6spD+upMctc2H7WdsWLXk1/cNPKqIwAXGG+tfS9A9lwPrnKq8mH22bMC4ZSP0WKT3KSjvqSGhq9i9sP+NRR9oybi7mr/DK71xL23eHvXR8XW4iy2xsLzVXLnqWIy3F1UfZWy6/cfvBKYjjCj95Sr/+it5ynQD5aHa9FvSmf0qhi0tMeaL7FNHFS3J5yjkKOB1YIF6PATZPu7vKfAOc/z3dfna5mXmKKwLvv7s7Pj/3geir8REArotNtWPCUDfZ3kr6y4HPP6dPp9Dm4fR5FCYgzlBXl7P2uVqf4Opzk/oE7lexffDwRxtKoczjhj+TSnrEY190F9QRX4qLfTtf6PtYRt7T+rCPQzn4uF1XfWh8HAcsLT22X0x/syITxsS2gHV8NAbzNsA8mxHzgRjMEmCyP6P1vyG8Y93VttFrl21rn1OdoDjknfvdp4A+p91H9LXPvwKFbuDgl/vsJH7Z5krcnWCzv6X9rF1A72PJVKvLW5XypK3Lxx3lZyzt8nuse25DTynyevsVOmY+I+a7lH5P85UeCLu074zps6PAfXYU2DY9rvCFvoA2vuFlQOHtO5T2umZjgHKrpPWHKEfuD0OI0/qkrGNQHgNg+r1hb5zrrhBteixtf4NHjH4jxV0sQtM1XxE9X0npw/ZvtPGoM5+GeEz/cYeN1+Srbftw6f5RSMPHhoYQh+Ou1/OH3Tg8ZiEKExDnW19d/psmnyMDyIf1VRvva/rKnwta6evXSV81G6TVJbeftO2U5TQZk17wuA99KIVfhTy4PhVIO7+g9XFPBTptbJsoE74AVNI/Okz2vFQua+0D5crtwyXDKGT1EUVmrs9JtfZxnOK0udo0djcKrrYjeSO9/WKKC1uztlfmURsva7Ze0j/tsPWhwoPL1ie1af4EAG2H5F27sbquy2G3SKlsfeiQzyC2nsfC2lbgJNv9rEP/eFk57f1iLl05opQt69rIWtb9aq6NxPmlLCuUCWJptsE1pzKovxkFvku3/TPW3+S5SUn/pYz+pksPL2h/cwV6qMlnLf1NzQbhPOFDDhvEPp+mfy7/LFTSo/7x9VWaDRpX+MK+WPsMNAp72n9LAwbXmo7ne0rrOaIn8sB3SL+gyNGQn7KrXrU5AL/XOZVqlwb6etynwn7ZxNkdtuGylhaFewBHdFU7DgLXh75Gc02aH4h5hQb7gb8Lc2dfJ0ztWDW0wez/aseqRbjf6xg7sv8RKjRd/vJRoKOlFzxen/+XjvGhZitdc0/aePKYwrNrfZ5pa/sNtL5U0v/hUI0PK+W1XvMP289p1vxRB48RHa0v0j6j1T5DwDHg12LaFq6pY9viYwa1z7/jeIyCrJNyu+Q2oZVJjuxjf+0vMvprW+BdVn/ENafEdaTRdn3qrM0pYb0JHrexv0phM+LmdVimkv6/OWSqtQmXTJPahPCTZp4qSaa8zVRb/3TJVNL/Tcb1T5dMJf3/yrhW6ZJp2nko11plWpnylmihk1amHb62dsvPMsX1ojQy7XySD5irLVMs8wnKhzYjhOfxoN/eFWLybXZgHovB1OxXqJTBVZehQofr8hJHXYZKuY6lLNdxo3Idz1guSb/ZU7kOx5TrcMZyJa078LqrpN+eolzaPEkUeO5f0l+ltL1hm6sIu8UI8mFvuY9CnMV8Kc+Jar62doVgSHSsxjffSuMbTMe+mrafHflgHZD0t6bUgdXZU67rgGs9X/OjXWOqUEmvrTkWlfQyTtZ0gOdUtSNZ0vr3eGTO3ObedCFg5GL+Ck1+N5aibNy2cByBcpVxxDDszUV+2G6+fWtvubS9uUcVHO5f4/bm8l6rp4iutjc3bu7lncSr5vsfTlHmj2ztYt7ZftZ8Ht4/i7YwDHp5CRVeUB/i+pj3p7Qvwtew9TEuvyUKlvtnjxKW1o9o+2e1+YZ2VJ8N5T7mxcuS+T+q5OX2MRm4/UFuH9/j8Gdwb5023qzHYH4C9P77tvaWH+tR9mVF6T651Yb2kmMco41LXGtOJ5X0aHOEnxniAfNyubmuPkl2QZvjYpmg34zp2W/GuCzjnKeUMrIMJ2PS83hA0u9T9KyolJPnfjT+0vbf6OO/M4X9FZquq9+jwHri8n2iZ14jx/lrXF97PX/YjVsdW1yprLWvx2uTIcTxsf2aLU67Rs7XD6HfiLb4421bzD76U6DDvO9e8/u1NXXGPOWwV2HQX1aXHh5V0oeQxrVX46gjn7ZOirT2tP+WSssDBaEn7XadwovQZV/rDMjx67t1XnN9/A4WXGOBqUC3uza0K6Uc0QuC/rEG0i8osjQcH5Rd9jqEd7ym62e8Ul7GNV3UX1zT1b4JQX3R9mngOOFV8lk0G4B2rgrxmP6HwV/6YgxmELjtXdIesZ/Z1IvrshVRGHT/jfadrTa+4XUgrBO2/dp6AabnvZCS/ktgG1zfDgpffveeL6/53lreP6uNo136h7oQ9z39ZOAed/F6/S86/EPX/t4nMvJ+ROGd2zm3nVfJd0Saj6egOcj+3ishHtP/1ir6DaP9vf3p0YZl2d+L+hIGvTzH2e4X27Zb+y47zfWG2py3q89C/b4K4jH9v3Do37CcvyJy8qx/lbXeYyz1m+b8FdfeTu1amkj/Drb1z6cc5+ZLHZ9W6lB0ksMExGP6P23rZAHKIX8nBuBzea5RXq42lhv1RrNZW2rwMfFRkDqLjrmK9OEbW7syEzlZyywKfq+t6n43PAFlHVfKJPRFl8YgfS7mbxDoYxahVSAs47KVXWVD/nm9ZoL4kec4rImMWFMxcXtsyt2p03FHuZl+XHqtDcj7SQc+pteOLJ4kWazzI4uKq95w7kjor+QYbPl9JaXja7FQ3vkYrIB+X0nvxgP9GGy2S9NBf7klj2ebUklrB4R+IfDaHjp2IE/8xLVdPM5w775Gs32yKps8rjoUJ8JxsbnqOt0ivWN1GKN84uppXSjzmVMwNBHwDeA5hb5mSsZj6AZBV13ZfCRhyfO4g5c4jBxhTDswRk1n1HSUMGo6K286Wv159pRraZuOvFst79PlhQXwzGYH87I3GQU5TTCnxGXxTH1haZdRsJ5pshl30NF0fVrJxzrnyTym/vKORzye2oBzxKPJVZuZmiCZo+lnPdG6BW0m6ELBQjvnsnts55L0UUYCmmshp3WyLdUuCRRMicNRE4/mZBSD79cpdPOU/tvowuwpor+n/bs0YNAu45uiMqyDMvCoLQr3Uhkk/UfaZYjS7tnWKzPeDYJxKE8eva4nOWAc8s31ILNVOAMrWFoZJP2dbb6TdvThSDoKE2Evn3va70uDhZo2Cyq8vs5/2FvuDRA3rqTnvmCjkn4DpBGZFSm91n619o8y51lykeGkkh7x8pT+HqgjXtVCvS4Q71j2dRSnzbpps0lTwPM+arN+LusozU0H/XZEwrQiN7al2E7YlhaIZ4xDPUAZcNB8abzI4/d2d3E5nQRLOzER9NIblnaLtxlwu8U2Oq6k53ab1M55Nz/WJeu31hdkaTNR4B1iqC9SN9hm4vpdzSdie6HN6EWB+1ZJ/wi1U0+znmrfKrQ8T2HM8mn/GKaVcrONwPbDNoJ9EYxD+5HVRogsstoIzW/U7AfbCK73KGhtgNsHtgG+lQH7DW4f6G/Kiac5wgwC3cdKM68RtSHrVblSpbk026qcXzicmy1XFppJq3LW9Bulem25stSaX5pfWppt1lebfq212JitzLVq5aXlUrXcWm36rcXawtziwlK91CwtlBeqWVZFc0Gv3qHvi+3vzrAbj+lfVXxfxhyLwTwQ9qbXfEGtDGzbMb3WF2jzG+wzJE2bsh+6LiOv65X0aFt4RzDytz4jr3xiwPqMvE4p6dc7eMVyTGXklb/En8rIq8sH0njFchQy8spfwhUy8uryvzResRwbMvL6UJhM28Vr0hiPecVybMzI6/5wdXmdUHjV5on4snpskwWKQ1seN7+EbUXzryYoTvOHtXlA0RMffctSfXZxqVZvlFrl6GclqW+ZaT9Pht14HEtFYV37t8wVcXrBy1P6r8Fc0T+meZa8Qi9K94eOdLmYv69jKO8mwt53U2F/+vGwP73QLoT9PErcBojLE52N7d8oL8QSPvKU/v+B+bQorIc8kr+o0F9P9Hv4Vt5hm2GsceWdpI/q55+1eezMvQFt6/n212kSPr5j3v4Qxp3W7Wp2vrI4VyvPLy+cd5znFudW22dszlZmG9XGQrVUmq9U5pdXm/7C8sLs7EKzXjtvX5aXarVVp19plWYr9bm5SquyVGmuuvzPm9S5pcZcubxQK58fOKz+mGV5rjG7PFeqV5q1VqXZWPUx21xroTZbrSxVlxca86X5lYxZtDVJzM/j4bj1d/ZHNKy7CGuc5ID58g467P/E+Ucafo7+JY2X7iWeNZqSZzIBi0/J03YIWq3DJflCQpv1guPzRDMKsv6YJ15/q32Z+etl2d6bpoMHaca262WOwrvD3jhtfil69+ttjKmgXzbRvz3t36WBwlxDm0e0w680tbWGjo8U9Pqvtv16bSlH9IJAX9cX+gXi1YefgfSEH5aPa76U189wTHw07KbjONcagIb1giHWOUOsU4ZYhwyxnjXEOm6I9ZIhlqW8LMtoxZdmZ4dFV88aYlm2bUudOGOINbJfI/vls4yWsj9hiGWp9y8bYlm27WFtj5Y2elj7Wst6PGmIdTH0QxdDGS35srSrw9hvR888bh8W/bKU1+cNsU4bYln6JsPap43a49qVcVj77YthnGapE08ZYg2r3r9oiDWscx2vGGL5tNGSVvs+KQqyd5TXQH6F1hz87C2uNXmPsNBA2lOeaOeIXhDoawJC3zUHX1DiBln3XCwvV1ulxcVaZbFZn52dzaobkl7be6atL4isN/iR9aL2vQTujYrCBMRNUVwe4oTHSPZf3t3Lf8ET/2nkj/S1tvmZsJsuS11uCnp1Ddujtq4op3Rr+/ZlXRPXFbV11Rzh47oqflv1te1dXjEf8ojlm1Tic0Bfe4/POXqPdJHeu8LefBiXU3jh8o4rfGqyGFNkkWavH7ZTwfOxf6IyPz+7UFks1eaaS8vNWnW1928sLc4u1lqLS7Pl2my1Vmpa7zlHWfKe899v14d2+vOYAzMKnw17MSX9vwLMuH3sQaDvjWDb7Nrvivxo+1Li2j+m81Gfc435xYWlhVqjNltaKs3NrqQ+XftYovBI2Jte+5ZTa5/8bdY3oa74poRJyCNYnw37MZlnzQ5Ggb8Pk/R/Djz8R/pmj21SFKaCfttkuO8g9T4IoV9Q5OFjH4TrG40osJ/iaV9Gp5/XvttYp8hH+8aN+xXp07XvxRF3jNLjs+THd3/d1q0iYUaBz0/Q9pngO+zH/or6MaybXMxfweV3PFbR+n/tDAXxlaL0/9/23rJgex9X8or94LZY2NHF/Ns2pvYNHNcf22S2xew3Cb04e8X9VUfP2/y9fiI+lZn7Kywn84j0NF8lCmyvJH2+zYPfcZ/+PSt/f8H9pSaPIOivkyDo1zutf0zyxVx7GF12wnXaJH6vrKUXPD7DYwZ0g/uy9ZBHG+OxLyPpNwEm+zLa2ERr1/I+6fsq4cf1fZU2RhTZC9YExFn2i9o39SjDfJgsH21cnVY+fEYP+m28z0875ZJtD9LRvk907ZdFm5t0fg2XU2sPk0o5Xe1BKx/r7g2O9qD5do+G/ZjMQ1rfTtLfDDzkr3vjWfPtsC+7dYebV7Y3OPbB9FXoy+5oP2t7zqXNanZwnOKwLkVGaAdd52do3/i72oo2l8FtJe7sFvSnMP2CQye0M3uwjthnkPTf6rCR2veHOI5hOVh+K7lBKQ/K+VEqj6R/u1KeNTzLpKnZXZQr212XDKPAMp9W0qMspXxFSo/y19rOBopDuvwddtLYxnUjDI59b4W64/MZUQbC55RSXru6WyrniJ6UD98h/ULQr/M+xpJpdUTkM+1HPiWXDk4r8hF+LvHCT6kqulJUaAuvl7Z/o13B9NMgQ0yPz5If3y21dVd4mIF8gl+kuCjwOBbjxpV3Y2uEVVSwUG5Sp1E7/ijJAvU1F/NXcPkd84j1KTrvshErpYNY4t9o7Sn6t6f9uzRQqFakHJco5RDaqFd2bac+l9bWCf1C4LUtl106jPLhsW5R4bUY9OvwE2E3XZJ+Ix0N69yQYp0yxHreEOtFQyxLeZ02xDpjiPWMIdYhQyzLMr4wpHydMMSybI+W9XjSEMuyDb1kiGVZj5a6+oohlqV+nTXE+oIhlqXeD6vNsSzjq4ZYhw2xXjPEspSXpW9iqV+Wfo6lnbDUe8syWvZDxw2xnjPEuhh8uWHVe0vfZNSnZcM6YYg1rPKy1HtLX87SFlrWo6W8htX/etwQa1j9r6cNsSzbtmUbspSXZT9k2YaGVfaW9styXm5Y54Ys9cvS9x1WH3MY+47omdesLPoOba0X9yhOKXxYrvcK/iZP+CKrSx2yQvq89ivx2l/B4jihVSAs47KVXWVzrRHjejjKIA7r0oxYU0qcjzotOsqN9KcdvGrlmDaUSd4Qi/e2aXs2tHVVSb9JSa/pyYxCW/JK3V4GcYZ1W3HVLdoIob+Sm9NFbh+mdHLG7FjQ3zYujcEK6PeH6d044GGYCfp1bX0Mn0KX37GuYP5p4qPzjWr7N+6BlX0ia7d3Ybaa1ra+WfYuHAm76Qbtyz9viGU5d27pD58wxLL0FS3LaLmGO6zrKcM69/Q5Q6yLQSdGaw1rJ3tLeVnO1VmW0XKeYVjXSi3nniz1/llDrGGdh7fUiZH/9eaw0ZZ97TFDrIvBFg7rWtZThlgvG2JZtiFLeVn2aaP1gWxYF8O6vmUbGtY9YaO+483Rd4z2QaydTozmFNaujJbfCgzreMhS9pb7nId1vtDSzxnZibXzJ0Z2Yu1kP6x2QvwvXiOOwp7239JAoVqbVujmgl66nvabtHJET2SE75B+gXg15se570erM897rJo5wkd+Ninykbq8TIkTrM3t33jGB6bfBGXE9Pgs+fFd8ar2XwVzhni4TCkPvhP5RvtyCm3cDG2gsrRcrtZbc/XSbKNWb85WK83KXKlZqy+Xy/PlykJtvlpdXqrNN+cr1eXKXGWJ9zEJr0jXUx3X0rYBoV8IvLbJskvntP1Ums5JXtaFKOwLu+my6IKlXml8yTlvHm1tfTroly3rmc/9X0hPZITvkH4h8Kr3ZVedoXxYzzYrvBaVuBnKN7PqMq8urlTmvve1ajLX9itmkXkUwrCbjuPGlXdjDqzjhlinDbGeM8Q6ZYh10hDrkCHWOUOsFwyxLMt4whDLsozPG2K9aIj1siGWpX5ZtkdL/bK0hZZ8nTHEstT7i0EnnjXEstSvlwyxLMtoKfunDbEs9f6sIdbITrw57IRlGb9giGXpTwyr7F81xBq1oWxYxwyxRm1o7WRvOXa3HCPz2gzOqexp/y0NFjrfcG8eHLvKLwR7iz3fNcG+fHDsZimG7yvs+V6W+S68rwXv7/iJ9lqE6E/7GP6etRS8t2EM4jH9xNVdzC+1MbW7POV5ivBygeW8YKWUI3pBoM9TCv0C8WrLT3eecoz4YfnwPOW4wmuR4qLwZNhNx3HjyjsX1mlDrJcMsU4YYr1giPWKIdYpQ6yzQ8rXSUOsQ4ZYx4eUr3OGWJZ6b8mXpeyfM8SyrEdL2T9tiGVZxlcNsQ4bYr1miGUprzOGWMPati37DvEntDs15a4Y7d64DURPu9MyCp7vKy4L/no/+J3zjpLuLRT6rrub+a9gcZzQWq27lbWyaXcrFyk9yyAOa11GLM93OHfq1HXvGtKfdvCqlYPvsMx67/t6B1+YfkahLXlFhniHqKEMKy4ZancxruSsKJHbNZRO7sMbC/p1cF0MVkC/r6F344CHgcfcaCO1+4GFLt6LuQ3i+ZypbUBrXHnH7QXzb4vB0uYaonBf2I3H9IX2XIN2h+V2hT+X7u5Q0m+HNMKPJhvJO63QzmJDka+iwsP4KtGZWCU661eJztQq0ZlcJTps33cY0tkBafge+ysN6VwJaTYSnasM6VwFadj3uxri0N4IH2xroyD90054b93HIz3hl2Ug9AvEqzE/HV9rJ/HD8uG+ZZfCa1GJ4/5ul0Jnl0JHw7qaeLga8q1S/VVWWn9X++HHWX9XK3LNUn9ReDAMeuS6y0s5Kp07Mq8N+oPE7QbarAvXQRy2FQ7j9BvLFPVX6+E+dE7H/OyEOOFtJuivb0zH9eKqq6KSX9JNBf0yMayPGss1UMp/PdDeDM8cNJkL35HMt9B93oGCxW0e6bM9j55voDjU27dQ3LUQd2P7eSaI17kcxUkZ+R3XI+bf7aBzzYB0rlHoTCv5cjF/hQ6/Yzqu9ni1IR2U2zVE5xpDOii3XURnlyEd1MVric5WyIfrt4tXd/NgPhxTYV45tzhP6Qu7u5itNqbYEmzPhrZkVsp2Q9AfJO4tQJt19kaIYz27CeJYN26GOJQ5B80+iSwi+/RgBvuE/RDbGZe/4sm/S+2vCP3V8leuIX7i+kDNfkterT1toXwuH3/XGst8F8nct4+/i/hh+bDMdyu8arZf9g+JrZF2chz2ihy5uhcbbZV8v8h+VRTuprhrlbjX8Xd1+UH+JqCsU5D3nrCXZ0n/g6tiE2fnNJvI+vkWT7TT6ifbL+RH+C4ocRMD8Lq8NF+qlmZnm63Z2mK9tpwjfOGV3/F8341Keu2MdpH1TX5kXZG2MB528W8EuUZhAuLeQnF5iBMeoz7py7t7+b/RE/9p5I/0i0r6e6EMWepSw7rHCAvtgQXWuhVibQp62xPbHPyNWLgWI+sO2liCsW5IwLqLsDD/DSnKiFj3Ehbmfwth3ZiAdQ9habo3rWCxTfXTzkv1tDZV6BcCn+222+ffFPTLFeXDff7NCq9FJQ51DOOQzs0KHQ3rekOsGwyxRMf86k6lMa3wJUHibgHaqDMctLEM9hv/OcNYBuv4ForDOruV4rAObqM4bLe3t5+HTb48/rwV4njO6TaI4zmn2yGOfak7IA7XiTkk1eeVGeYrUW+kvFNBf/kNZb/EMgwUvm6DdzwWQBni2JqDJicpUySn/51B71EPWX/RPrD+op4YyrCpyYl5Rjmx/qKusf6WII71twxxrL8ViMuqvyKnrPqLOorlxXJNwDvs+94dvvFX80V4XlfzkfCda35S0ml0rhmQjja/LeNXKf9fwJj7P9CYexfkF1lG6R68pjfd6o9J06+LCv1C0C9fH/6T5uNqdaT1FZK3qMTxHYC3KnRuVehoWFKXmm/Mup11jHO1Up5h6jOQR80Won5wSOozsqwFosyFtzTjnqw2QJuDkfrAchvWxzL3I4FSfuxHsq4FCt9Z1wJRriWKQ90sUxy2nQrFoV5V288zgVuvME7KyO+4HjH/7Q46twxIR+szp5V8uZi/QoffMR1NNq7+ZKV0UG48JrnFkA7Kjcc3txrSQV1kXxPnfXAtcMc13TyYD9cCMS+vBUr6v7m2i3l1G3Mq6G8Ha2lLWGfRJ2U9Q5+UdaMKcShzDpp9EllkXQtEW41lQt6T/NU8pb+V6slPH1wqbaJyaTJ1+Yme+ErtJwr91fITbyF+4vpxrQ+SvJpNwPEm256sfqLoo+Yn8tgkq594jUJn2PxE3h8w8hNHfuLIT+zPP/IT09MZZj+xYeQn/gfwE5vkf/iZD7ow/USRRVY/EddS2D7tgjhJh3N23D/E+ZPvCt/4y/7kw22cCPMAzQMiX8JHlO5/Ujr0C6R8w+oHepq/dPqBmt+U1Q+0nC+UuryQ5vGw3jhY+mfY3tg/Qx4wHddxGn8Z87O/fLH5Z9o4ebX8M/azs/pN2nr2m8U/i9v/Z0EH5fZm98/Qr0X/7Esp/DPMG+ef/T74Zz99Ac7judaWh2EeTxs/st1P63dJ+l8bonk8l//mab9cav+N98v59t+0/XIu/+0WhVfN9vA8nuYn3qLQ0bB4PmdY9k3x/Jo295i2reIepyz+mzbu1/y3NHtZXf6bNlc3bPuAsvpvuC9npf4b23nUzTsoDttEGr9vJnDrFcZJGfmdyw+51UHnpgHp3KTQ8e2HrJb/dhPRucmQDsrtZqJzsyEd1EXuH3dBPvTf/hP5b5IP/TfMy/6bpP9t8N/+ivwCP+tW2W0J6yzuKWQ9Qx+JdQP9PpQ5B80+iSyy+m+7II7tU9o5rjXYE5f6jtFh3RO3MejO6dzXOnj3w4t77196X+uxA297oHl3Y//B+xt739Zs7m8dOIClYY3i0rK2cBp53q28R4ybEkrBX9VoFk+wbk7A4q9qNKvGViQOi7+q0SwX90haa2OvE9MjP7cm8HOPg59bCeu2BKyHCEsbVQvW7QlY+wkL899O+e6IoYNp0BreodDW8FlvSwk8Hwh7eUa+eORZTsA6SFiYv0xYlQSshwkL81coXzWGDqbBEX4V6OSUdxo/d4bx/FQJq5aA9QhhYf4aYdUTsB4lLMxfp3yzMXQwTR3ezwKdnPJO4+ezYTw/kjdND4e8GvYozRzRk3LgO6S/Wj1cklx5FmBO4bWoxPFoZU6hM6fQ0bBuMsS6xRDrZkOsWw2xbjfEusMQq2SIVTHEKhtiVQ2xxCZqqyxFopN1lQXzr9YqS5Ho7IJ8ONq8c2c3D+pg3GhT+qI8pf8ZGG3e1cbUdqC5VrN87GqSvgZ12M62d28wxz5cgsRhP3c5PHPQRqfCd9bZM5Qr98loZ+YoDu3GPMVh211oP88E/fJlm6j5gfjOpccVB507BqRzh0JnWsk3aLvUZOO7/fOs6B2GdLTxA+uPBR1tbJFkz/bu7ObBfHH2THzZPKX/ItizfW3MqaC/HaylLWGd1fwSiZuHONaNBYhDmXPQ7JPIYpDVT7ZPWpuYCvp1by1WDoV+Iehvcz7GDNqcgNYHavZb8mrtiftabQ6hpNDRsGrEg2vM56n+KiutP99jPq3+XGO+tPV3Bcm15KUc1TL3/Ri0nRW8KxZ9dJ6/Ckg2GLBMWVdrtX5d80XZf8j6NQTm59VzT/5mleUaKOXH+Zisq7Ur9TdRrmwPsN7rFId6y/0A9rPSt2l+INuyrH4g5nf5mz78Wt/+5mp9DbFafu2w+Zu/uLObB/OlXa2V9M+Av/nLbUyxJdieh9XfZD1Df5N1YxB/U2SR1d/EfmgW8Fm/MJ22Y5J1Owh024A43OZKMfSj8LHwjb/a/MilRCPr/MilCr9pfG4/fVl6n1vor5bPXUkpV023KiRzTQ9YR5BOVaGjYbEddPncfnzDUi1t/Qn91fK5tbHMpYpcV0O/4+r5dgc/fux99xazpPVG4SeS2WTQr0PaOivzjeuS8i6ublz7I7S+39VOXfsj4soQV0eu/RGaDPIU97c73/gbyfCbO3vT3NZO89eQ5t+3n7V+mdu0p7XT1G2a107rfvhxrp2ifFBn1wVu3cG6i9tXcptSVtblWxN4Yl3OuocFsViXs+5hQSzWZW2PiTau452S2lcT2hhU8CMd/5ud8fi3O/BLDvyKA38XpGMfFcfvVYrDsWcN8P//nfH4Nzvwb3Xg36bgMyafKI+085R2rB0R+civXqfzKxhR8HvrT3qbIvQLQb9sfdiU3cQPy4f9PO2kYm2nL+/HGOS04DR7AtNirc7prNWKNqchQWvbWeeo8CvcLSs8eZjbO9YZz19hHfD8FcpX+omZoF++SBvjpIz8jusR89/ioPOWAemsxReUu4nObkM6KLc3+5cLcV+E3rKrm4f7FJevy/3KYzBHdXsbcyrobwd2tiT71/6ss2lPME7ztUFa+ySyGGRNVMoU7XaXtZ77Wgff13rsw4299zcbB+/f98A9rYcebh04OEGw3HxYzW+KYRdxAge7URijuBsoXi7RGQv0kGbaYnTYm81hb3wRwiCHfIiuaBd5bCI62gUj1zvobFJ49mxeFrWuTYIm500Uh6Yn62FvaCayLG9qlyRoy5tpLmlxLW9ql7R4PgCgpU1Hc/nRbGd1HYXvQZY3B/3gVNMrXnaM0yuMkzLyO9cy3W0OOjcPSOdmhc60ki8X81fo8Dumo8nG9/LmWn0kulqHluyCfOg6PrCrmwd9i7TLm5J+GVzHh9oZPF82nNmWsM5q26W06RvWDe2gkbT2SWQxyMeobJ/wUsQHwt64nZCPL7y6FuIEP6o/uRRRuxhse9Abtx3idrSf88TXK6QPOyCP4bREk/tPoYG0b/BEO02bddkz5FvzRwe5HLHSWlyabTSWq0vLpaXGciurvyDptQ94Z5T0fi8XrDakveDliPzp7wTE3UBxeYgTHrXLEf18oF1tpJE/0i8q6d8HZchSl1rfx1NXabHkEkL0I6Vta7aJ26IfO5B+/Cf0C8SrMT+d8d+OoF+uWxW5atOZkleb9kIbjHFIZ7dCR8Pa2X72W0eVumarAyo/6igf8ohtE+uNg9YHS5myjstQzsLbjMID18dW4ieu3otKfkk3bJetZx2X4cXoWcZlKFeewkPdZN8GLyDi6VrUd9d8B9JmXU0z34H5r3fQ2TEgnR0KHZcvlMY+anQ02bjs/ErpoNy4P9lhSAflxvblakM6qIs8Rb0L8uG47J/s6ubBfFnHZffCuOyftTN4HpdltiWss+g3sp7hVD3rBo6zUeYcfI3L2D6NfJ+V+z5XK7xq7Qkv9+R2O668c7VNqcspJW4tfR8+IHEQ30fKlNX3QX11+T7cl2X1fTA/+z6e7FXm+sjq+6BtWanvw/MG2gWLEoeX6rBftAvixJZq8zzs+2QdU2D+3Q46Vw9Ix9W3+tpmsFq+z2r5JGxfrjGkg7q4i+hsh3zo+6y7tpsH86Hvg3nZ95H0e8D3KbSfh21cyzqr2XbNL2LdQL8IZc4haTycxffRxsPMe15Ju43iJO0VUF/f1n7W+pgrg964bRB3FcVpY+mZoF8HEANpoM6hD3Nf2FsGSX91m+9Iln++Tccci8EUPdbmN6UcU+2/ExBnp79L5Yjv3wEdQJm+Xt6wt0yav4XpeQ75GiU92iKRkWY/2NfbrmBdCe9kjlSTp/C4FvJEHtPIE9NnlafISJPnTsK6SsFCGbvkKTyuhTyRxzTyxPRZ5Sky0uR5LWFdqWBhe+c5fMGeVNKzTcL0bwWb82fbevnT5iUlbpuCjbY3RxhYjoJSjmmKw7wR7k9c1cv/rnbc28Hu3020tbkwlCHXn7Z2gfNWvH65C+J4D8ywzLWyj5B2foR9BJwfYZ8P17FRJhyS5nZnU/gPWj3vIhou24NxmBd9R54H+xDo2BLRviGBdpp10BsUfrTxDh/672c9ujI3rfAqQdMjnoNDPWIdQz3iOTjUI9Y/3A+FMuGg6ZjIKYuOcT1rY0vUO9axXQq/ODfLOvZJ0LFHiLamM9qcvqR3XSiSpGOS1/Nli0O1/0bi8LOTrDqGFzGm1bFHPOkY78u6NQGX9ec2JT22P57D0/b2DdvFJFzXdyiy03SL58dQt3htMO7TUQ6a/uBFKGn0J0d0BBfrJwqsM9q+RfwMhI8eOQ126VXSV+2zaDzSivVKOxYb25zopHbEtuSdUvIZ7q+pTSu8SpA4/JyZjz3BT6/ZLqU9go/3CeORKHy8OQZNr0ROWewS17N27PsueOeyS2XA5eNwkj6rZ/3RjiZIqz+S17P+DNUxjRL3VojzrT/WOrN35xvP2vUEfKxOKSVNSZ90RATrn6avaPNd+sfHUUs+nCNE/vnoUUn/FRivf5XqA+dURE5+51RKLW1OBeWaD3vL7ZJhFLK2eZFZMei3zWWKcx2xtkvBjPTvzp3tcgS9fsTvQL/4L8heav6TS6+0IxlugzSsV9rFrMP27Q1/Q2DpU2n+eta99CKnLP0i17P2Td4ueOeycbcArlzqxce//AHo2DeJ9h0JtFnHNNuoHVGpffsjef0e01otTSu8StB0hftH1BXWMU1X2NfT9BbtCcqEg6ZjIqcsOvbNjLbE5d/fBrhfitGxvwAd++8pdEy7oDKtjvE+xgtdx9i/v1B07L+n0DGcX2Idu17hN8JtxOjY/wQdW7e7l/ZIx96cOsb1bKVjO0jHZN1s4+5umu1E+zqF9k54xzqmrRvh+jHvBcC1O/42HfMN614RnmvHuX1e68G5/V0Uh3NeKBMOmo6JnLLoGNfztUQD6yoKrGNbFX4j3MW2QApEN/o70Ld0zWarXCvPLcy3arXmQp0vSo+C6OKGtiy+sbW3PBOQB+U4rbwTXNHFPOXds8JycLFyRC8I9H3DQr9AvBrz09k3nCd+WD68b3hS4bWoxEkdzATxdZKjOORhQuGhqOSfSIGllWdj+18UDhzct7/1jsaDBx7e2woosK7k6PdYDP2ckj9wYGGeSK+t21W9uThfmqs0FppLs81qfSlLu5oO+mWbi/mLZdawiwrWvvCNv9IGUY8s26DgryP+jPA7Vz3kFTkJ7fVeyra8nNa+CP1C4NXedezLeuKH5cPfNE/5kU8rOtZUdA/b7KQiG+ZjHfFY8MSjNkcpPEncBMQJH1GaL17Xy+OYJx79ttHlptZH91y3R/6M1A3OEaPej0E8pn8/+MJ3tZ9ngl67jHZqA8SvU+Llt9TXmJIWn/m38M5yxfSik5MxZZ2kskr6e9rli3j7+nYdE+WHfI3FYH4IML9K+3Bx75qrzUv6DUp6bGPCz0zQ3zY3UD7kfSroDfhOq58cpeU+WPopzBf3e0rBieNhvYLD/SRjMk3N12Ffflyhg20K+/wphb5h/1DX+koJmq+Zozgs+/eE3XQctHGUlCkqb2V3F5fTMT9aW7P0jeR9Ht4zXfZHJykt9ucss7wBj0WFziThrnPwnyOcCSXfdKC3R+1vWn5zCr+u8eBK6SDW94a9dLCesU87TH0a2vFxJe9jYTce04fQpz2Zsk9jW4Jl+HjYfcc2m/1YbpO8jsx9F6fBfhzTn1D6LrYPiBW9O5XCR9D8PvYRvgTyfJbkqfkAM0G/bFiHp4gW+sfSv7AMzgIfZ3bH0xK5TjvKGL07t1tPhzxgOsbQ+k7B0Nq15JtR+OK2x7Zj0kFD6880GnmKG7R+tH4bfQ3Nh9HisT9HOvxuTEmf5H8UYrA13EkFR7Pz6ykup8SxDcPyog1j30Qbk6Ft1NpdXN25fG+N9zR+1aSDd01+aIes53JK86VyaWmuvrxcbs42FmtJcznyfl3YW67X/8K7PJQrCusxPcVNQdxE2Eu/0P49AXQQS/jIU/rfgLqOwiTkkfxFhf4k0e/hW3mHusZY48o7SR/V6S+1efQxR1epL8w3FhZL5cpypVKdn02qV2v6s7XZ8vx8Y35pdml5oba0uNr0lxZmlxeq1cVydaHZWiivevlbtericnl5YW6xulyqzpdXm369Uaq0auXFxXq51VhYWF718pfL5eXZ2uL87FLl/FTMiuaIcYyBPu7/ncLHxbz8zbmk/0vwhf6A+gZt7KP5A2MUp/m+mq8gPo2UFfv0ji0J+vtfy3FzjugFgT7PK/QLQX8f52OeV5vzwT6T53k3+OGnJvxsVPiZUviJ5oUvCfrrDPkTLBzj3xO+8VfTL/YnJlPKpqjkZ58X65jX38YUHly+sstX3xC4/XX2lbR2zHnjZIHtXnwrHov9F2j34+25bpdPqLVfbvfcJjAOdYHXGDXdQh+bx8rTSvqNkIbHJ6h70ymw1jloX6Kkn3bQRr4wL9OOayOuNQzP+6zr2j5rnFvOh72y0eoR06eRpVaPRUqPstPaMbdHpLuB4rD9cRtHPRX9xfbCfTS2R+yjrf2KxebsUmmhWm42GnOludn5LH5FjsoWBF3ZY36+KjDrHoExB1bOgZVPwOJrBzG/5NXmB9mf8LROm/pqOd6X4md90b0vBeWz0n0p3H9l7Zu1NQkLLPYtETtpv5O2XodYLr3ysx+hNJtWr3g/gm+90vYjuPRKm6PT/DTWBdd8H9LRsNYZYo0bYk0YYrHtQz1hHeX1rz3t36XBwlxaHZV3haC/rn3o6LgiV62v5LVHzOvaZ+XqB1377kZYg2P5XHNEPdHWdnA+5h3X9eaRfNoaWRQeCrvxmP7UdV3Md9O4jG05xiHP7Gdr+j/uKL9GZ0rJt6f9t5QtzPILz33ngja/JEHiCkqZc0r6cfqNfGc9L1UbX2hjig0Uh37ORorDvk54SOPDZ9URzUZqdPID0skrdHy3efYdfezT1fps3/tJNBs2KB1trU7zQdBW3k+2Upvzwrz7w248pn8UbOXeVdmvWZrT9ksFVG7XHgLN/9NsEOsGzg2hzDlo9klkkfW8VNQJnMfM0Tuhi7SCoL8f0vxbbe+ANg8peYe1r9DqietXm9uSOJxD5PaK81681x5DUt+U5SwNbc0e0/GafU7hEdu6NvfDfpbmD2r7BFw8uvRP01dtz422/sV6qtks5D/OZp1pyyPpLA2Rk+c53jltjhflmieeXDKMQtY2LzJzjWlday6aTySY6Jdbz8HOVZbqjWp9obTUqs81ZueS5mA7+/XCbjrDeux8Dyf1NR505TURdnkS+tqeFEnXsbV+eC0Jr7JPRdoQ0sSyjFF6fuZ9Lz8H/gWWEXXItX9lA8Rp+3qER21fzYYwG9Z6wlo3AJbwVVTSr1shXxoW7w/Kst/nR9p1E7WJ/wPFWTYdmcEFAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "read_credential_hash"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "CredentialNotes"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "claim_type",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "claim_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PrivateRegister"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "root",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "credentials",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateRegister::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateRegister::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_root",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateRegister::update_verification_root_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateRegister::update_verification_root_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "claim_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "siblings",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "indices",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "expected_root",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateRegister::verify_note_in_merkle_tree_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateRegister::verify_note_in_merkle_tree_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "flag",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "claim",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateRegister::add_credential_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateRegister::add_credential_note_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "flag",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateRegister::init_credential_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateRegister::init_credential_note_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "102": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "103": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "104": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "106": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "108": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "109": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "116": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "117": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "122": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "124": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "127": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "130": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "131": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteType;\nuse dep::protocol_types::traits::{Packable, ToField};\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteType + Packable<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "133": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "147": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "148": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "149": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "151": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "152": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "153": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "154": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "156": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "165": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "179": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "182": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "183": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "185": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "186": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "188": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "190": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "191": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "201": {
      "path": "/Users/ouyildiz/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "218": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "220": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "263": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "280": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "281": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "282": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "295": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "297": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "298": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "307": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "318": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "354": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/ouyildiz/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/ouyildiz/Desktop/noir/react-box/src/contracts/src/credential_notes.nr",
      "source": "use dep::aztec::{\n    macros::notes::note, oracle::random::random, protocol_types::{address::AztecAddress, traits::{Packable,ToField}},\n};\n\n#[note]\n#[derive(Eq)]\npub struct CredentialNotes {\n    owner: AztecAddress,\n    claim_type: u8,\n    claim_hash: Field,\n    randomness: Field,\n}\n\nimpl CredentialNotes {\n    pub fn new(owner: AztecAddress, claim_type: u8, claim_hash: Field) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { owner, claim_type, claim_hash, randomness }\n    }\n\n    pub fn to_fields(self) -> [Field; 4] {\n        [\n            self.owner.to_field(),\n            self.claim_type.to_field(),\n            self.claim_hash,\n            self.randomness,\n        ]\n    }\n}"
    },
    "51": {
      "path": "/Users/ouyildiz/Desktop/noir/react-box/src/contracts/src/main.nr",
      "source": "mod credential_notes;\nmod root_struct;\nuse dep::aztec::macros::aztec;\n\n\n#[aztec]\npub contract PrivateRegister {\n\n    use crate::credential_notes::CredentialNotes;\n    use crate::root_struct::RootStruct;\n    use aztec::{\n        macros::{functions::{initializer, private, public, utility}, storage::storage},\n        messages::logs::note::encode_and_encrypt_note,\n        note::note_interface::{NoteProperties, NoteType},\n        prelude::{AztecAddress, Map,  PublicMutable, PrivateMutable, PrivateSet, NoteViewerOptions, NoteGetterOptions, RetrievedNote},\n        protocol_types::{ traits::{ToField, Serialize}, hash::poseidon2_hash as poseidon2},\n        utils::comparison::Comparator,\n    };\n\n    global AGE    : Field = 1;\n    global STUDENT: Field = 2;\n    global WID    : Field = 3;\n    global SOCIAL : Field = 4;\n    global EVM   : Field = 5;\n\n\n\n    #[storage]\n    struct Storage<Context> {\n        root       : Map<AztecAddress, PublicMutable<RootStruct, Context>, Context>,\n        credentials   : Map<AztecAddress, PrivateSet<CredentialNotes, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {\n\n    } \n\n    // A function add_claim\n    #[private]\n    fn init_credential_note(flag: u8) {\n        let credential_note = CredentialNotes::new(context.msg_sender(), flag, 0);\n        storage.credentials.at(context.msg_sender()).insert(credential_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n    }\n\n    #[private]\n    fn add_credential_note(flag: u8, claim:Field) {\n        let mut options = NoteGetterOptions::new()\n        .select(\n            CredentialNotes::properties().claim_type,\n            Comparator.EQ,\n            flag,\n        )                      \n        .set_limit(1);  \n\n        let old = storage.credentials.at(context.msg_sender()).pop_notes(options);   \n\n        if old.len() > 0 {\n            assert(old.get(0).claim_hash == 0);\n        }\n\n\n        let credential_note = CredentialNotes::new(context.msg_sender(), flag, claim);\n        storage.credentials.at(context.msg_sender()).insert(credential_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n    }\n\n    // Update_root\n    #[public]\n    fn update_verification_root(new_root: Field) {\n        let current_root_loc = storage.root.at(context.msg_sender());\n  \n        current_root_loc.write(\n            RootStruct {\n                root: new_root,\n                owner: context.msg_sender()\n            },\n        );\n    }\n\n    #[private]\n    fn verify_note_in_merkle_tree(\n        claim_type: u8,\n        siblings: [Field; 5],\n        indices: [u8; 5],\n        expected_root: Field,\n    ) {\n        let mut options = NoteGetterOptions::new();\n        let notes = storage.credentials.at(context.msg_sender()).get_notes(options.select(CredentialNotes::properties().claim_type, Comparator.EQ, claim_type).set_offset(0));\n\n        let rn = notes.get(0).note;\n\n        let leaf = poseidon2(rn.to_fields());\n\n        let mut node = leaf;\n        // Iterate through the Merkle proof up to MAX_DEPTH\n        for i in 0..5 {\n            // Only compute hash if the current level is within the tree depth\n            if i < 3 {\n                let sibling = siblings[i];\n\n                // Determine the ordering of node and sibling based on the index bit\n                // If indices[i] == 0, node is on the left; otherwise, it's on the right\n                let (left, right) = if indices[i] == 0 {\n                    (node, sibling)\n                } else {\n                    (sibling, node)\n                };\n\n                // Hash the pair to move one level up the tree\n                node = poseidon2([left, right]);\n            }\n        }\n\n        // Return the root computed\n        assert(node == expected_root, \"Merkle root verification failed\");\n    }\n\n\n    #[utility]\n    unconstrained fn read_credential(claim_type:u8, addr: AztecAddress) -> CredentialNotes {\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.credentials.at(addr).view_notes(options.select(CredentialNotes::properties().claim_type, Comparator.EQ, claim_type).set_offset(0));\n        notes.get(0)\n    }\n\n    #[utility]\n    unconstrained fn read_all_credentials(addr:AztecAddress) -> BoundedVec<CredentialNotes, 10> {\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.credentials.at(addr).view_notes(options.select(CredentialNotes::properties().claim_type, Comparator.LT, 8 as u8));\n        notes\n    }\n\n    #[utility]\n    unconstrained fn read_root(addr: AztecAddress) -> RootStruct {\n        storage.root.at(addr).read()\n    }\n\n    #[utility]\n    unconstrained fn read_credential_hash(claim_type:u8, addr: AztecAddress) -> Field {\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.credentials.at(addr).view_notes(options.select(CredentialNotes::properties().claim_type, Comparator.EQ, claim_type).set_offset(0));\n        poseidon2(notes.get(0).to_fields())\n    }\n\n}\n"
    },
    "53": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "68": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "83": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "84": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "85": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "89": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "90": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "97": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    }
  }
}
