{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"PrivateRegister","functions":[{"name":"add_credential_note","hash":"1688553491178404190","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"flag","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"claim","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"855401245733623969":{"error_kind":"string","string":"Obtained invalid key validation request"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"H4sIAAAAAAAA/+x9BZgcx9LkWrS8FtiSzDJbxqrhMbNlZsZBMzPLzJYtmZmZmZmZmZmZ8Sqfe62ZUY20q47sy/Q/fV+d9ffzqxdRGZmV0d01mqLpn+uq4U1N1077z5+ncKNv8M8+boyoudf9z8o/9/f8e+2ee52ee1N67g3y3BvqxuI192by/HsjPPdm9tybxXNvTs+9udxoaaq+pgj+uXjwz7hJJRKldKxk4zZnYtl8JmkSyXwqYzM2mUkWY5l4vJRJZNLZfDZtsjYRL9lyMhsvm3+uv/qMn8uEumIFTpx/Tz7OeO0NwjbYjX4VWGkd/qpY9+4/j6z489/Bv9P936NATeFGHzf69q24H1x9atbAhLvsnMD17NcXh6tSszTvCOZ1qMQedh36M61D/2Ad+tWsQeU1BXhdpsDNZTxwUXNnfXPDC8YAXGBjnDib+/IEDY2zZfJxxmpv+AowxeuvCtzdf26uuN/St7oAt7r/u82Ndjc6ggJMY1DFPBNbExPusq3A2FXi7ezLCPjfyYHi6Bdg7WjSt+jDm/wXCq+yeQ3PvDGmecevA1pnczVJX9PGvI15G/M25m3M+1+fFzj3/1ziVE3+C/S/0YhjY97GvI15G/M25hU1r5K5rUrcNpZs4I4Qd9DL0UX/HB38ucs9H5vSjYFuDHJjsBtD3JjKjandGOrGMDeGuzGNG9O6MZ0b07sxgxszujETvb1wY2Y3ZnFjVjdmc2N2N+ZwY0435nJjpBtzuzGPG/O6MZ8b87uxgBvGDetGzI24Gwk3km6k3Ei7kXEj68aCbizkxsJuLOLGom4sRs/43FjCjSXdWMqNpd1Yxo1l3VjOjVFuLO/GCm6s6MZKbqzsxipurOrGam6s7sYabqzpxlpurO3GOm6s68Z6bqzvxgZubOjGRm5s7MYmbmzqxmZu5NzIu1Fwo+hGyY2yG5u7sYUbW7qxlRtbu7GNG9u6sZ0b27uxgxs7urGTGzu7sYsbu7qxmxu7u7GHG3u6sZcbe7uxjxv7urGfG/u7MdqNA9w40I2D3DjYjUPcONSNw9w43I0j3DjSjaPcONqNY/o2Vb9CJjHUvjInYbTU3JvKc2+o57873PPvTe+5N6PnvzvC8+/N5rk3h+e/O5fn35vXc29+z3/XeP69hOdeyvPfzXj+vYU99xb1/HcX9/x7S3vuLev5747y/Hsree6t4vnvrub599by3FvH899dz/PvbeS5t4nnv7uZ598reu6VPf/dLTz/3jaee9t5/rs7eP69XTz3dvP8d/fw/Hv7eO7t5/nvjvb8ewd77h3q+e8e7vn3jg7u9Q3G6KZ/rkZB/z9e0Jv+eavZp2n8S47KDb+p4h5diwf/NOEuS7oDzWW4ME6pAONABRgHKcA4WAHGIQowTqUA49QKMA5VgHGYAozDFWCcRgHGaRVgnE4BxukVYJxBAcYZFWCcSQHGEQowzqwA4ywKMM6qAONsCjDOrgDjHAowzqkA41wKMI5UgHFuBRjnUYBxXgUY51OAcX4FGBdQgNEowGgVYIwpwBhXgDGhAGNSAcaUAoxpBRgzCjBmFWBcUAHGhRRgXFgBxkUUYFxUAcbFFGBcXAHGJRRgXFIBxqUUYFxaAcZlFGBcVgHG5RRgHKUA4/IKMK6gAOOKCjCupADjygowrqIA46oKMK6mAOPqCjCuoQDjmgowrqUA49oKMK6jAOO6CjCupwDj+gowbqAA44YKMG6kAOPGCjBuogDjpgowbqYAY04BxrwCjAUFGIsKMJYUYCwrwLi5AoxbKMC4pQKMWynAuLUCjNsowLitAozbKcC4vQKMOyjAuKMCjDspwLizAoy7KMC4qwKMuynAuLsCjHsowLinAox7KcC4twKM+yjAuK8CjPspwLi/AoyjFWA8QAHGAxVgPEgBxoMVYDxEAcZDFWA8TAHGwxVgPEIBxiMVYDxKAcajFWA8Boix8m/R2yH487Fu/jFuHOfG8W6MdWOcGye4caIbJ7lxshunuHGqG6e5cbobZ7hxphtnuXG2G+e4ca4b57lxvhsXuHGhGxe5cbEbl7hxqRuXuXG5G1e4caUbV7lxtRvXuHGtG9e5cb0bN7hxoxs3uXGzG7e4casbt7lxuxt3uHGnG3e5cbcb97hxrxv3uXG/Gw+48aAbD7nxsBuPuPGoG4+58bgbT7jxpBtPufG0G8+48awbz7nxvBsvuPGiGy+58bIbr7jxqhuvufG6G2+48aYbb7nxthvvuPGuG++58b4bH7jxoRsfufGxG5+48akbn7nxuRtfuPGlG1+58bUb37jxrRvfufG9Gz+48aMbP7nxsxu/uPGrG7+58bsbf7jxZ99/YvhX339iOjCI6d903wV7Cjf6uNHXjX5u9HdjgBvNbrS40epGmxvtbnS40elGVyCSKbv/pr6+wT9JJLU/RDvOc+8kz73TPPfO9Nw713PvAs+9Szz3Lvfcu9pz7zrPvZs892713LvTc+8ez70HPPce9tx73HPvKc+95zz3XvTce9Vz7w3PvXc899733PvYc+8zz72vPPe+9dz70XPvF8+9Pzz3SOQjau797blHwq+9N4XnXh/Pvb6ee/089/p77g3w3Gv23Gvx3Gv13Gvz3Gv33Ovw3Ov03Ovy3JsyuFd5BTUFtoEBfxy46oc0w/5NpAP74XA1NeE3fvpRPMJYO29Y3oNwvE2llgZ5tNQHjH1GYPwHg+P/fy1/hvTDNs9a8meJobJ5k66HMPBecijeLPnyJSzOqYB5DYy1Ba4fy35DPzI4FYNupmbab6aOYL+ZA1gvh0a034TFOey/nz8sdZcrf5YSzpt0PYyB99JK9pvhwHwBxtouLXy/oR9tHM6gm2mY9ptpIthv5gfuN9Mq2W+m++/nD0vd5cqfZYTzJl1Px8B7WSX7zfTAfAHG2i4rfL+hH8GcnkE3MzDtNzNEsN+kgPvNjEr2m5n++/nDUne58mc54bxJ1zMx8B6lZL8ZAcwXYKztKOH7Df2o6AgG3czMtN/MHMF+syhwv5lFyX4z638/f1jqLlf+LC+cN+l6VgbeKyjZb2YD5gsw1nYF4fsN/UjrbAy6mZ1pv5k9gv1mWeB+M4eS/WbO/37+sNRdrvxZUfp7K8d5TgbeKynZb+YC5gsw1nYl4fsN/ejtXAy6Gcm034yMYL9ZBbjfzK1kv5nnv58/LHWXK39WFs6bdD0PA+9VlOw38wLzBRhru4rw/YZ+RHheBt3Mx7TfzBfBfrMOcL+ZX8l+s8B/P39Y6i5X/qwq/TsJx3kBBt6rKdlvDDBfgLG2qwnfb+hHmQ2DbizTfmMj2G82Ae43MSX7Tfy/nz8sdZcrf1YXzpt0HWfgvYaS/SYBzBdgrO0awvcb+pHrBINukkz7TTKC/aYM3G9SSvab9H8/f1jqLlf+rCn9uzzHOc3Aey0l+00GmC/AWNu1hO839KPhGQbdZJn2m2wE+812wP1mQSX7zUL//fxhqbtc+bO2cN6k64UYeK+jZL9ZGJgvwFjbdYTvN/Qj7Asz6GYRpv1mkQj2m92A+82iSvabxf77+cNSd7nyZ13p34E7zosx8F5PyX6zODBfgLG26wnfb/73o/Ycv//EtN8sEcF+sx9wv1lSyX6z1H8/f1jqLlf+rC+cN+l6KQbeGyjZb5YG5gsw1nYD4fsN/SUBS3P8HgfTfrNMBPvNocD9Zlkl+81y//38MT6tmHDXv/mDmo/0shxDPv7Vl6eOo9fzL2DuTQmsQW6qpsEVfCsvgbGy3X/wwIXNXbkWo/r988/l+zVV/1j3qEDMlfeW7zfpH/BGLuJkzhUL5rKj+uFwLd8PF4DeiNKEu+zfgAJS/ueKTJQrBKJcsVaUK3hEuWIPRGnCXVWLGFaUKwBFuWI/bHDR4qMEXIHj1wX6YXfFBu9w+Er/aChLeULcwd1F5m9gd7EScA37VNSaygsZIw59rtRPPsaV0Rj/L4p9FaDF0Sr2VRSIfdWG2AFnpHCLGNMq9tUUiH11LWIH2wiI2AOMZaS3XQMXkLjWxFlDQeKs2Uic0BhLyMRZCxeQhNbEWUtB4qzdSJzQGIvIxFkHF5Ck1sRZR0HirNtIHFmJsx4uICmtibOegsRZv5E4oTHmkYmzAS4gaa2Js4GCxNlQauL8+zcpOIAr45+EVb2sNuGuqmfnYflyrOGxfcd/YICcd2PhX3sS51XxRdceC3yKCnwUbbnjEZbrGCYdbqpAh6sz6HAMUIfAp8R2U+avEcNyPS7QITK+azLsUccB44t+mImOyfEMMVmbISbHA2OCfk6Grqtjmep1SUG9XpehXo8Fagf4qMiWhNfrcQy1YX2G2jAOGN/1hdfrExhisiFDTE4AxmTDfrLrVrfPa8LOy4J1jCKsxynCerwirGMVYR2nCOsJTFiVnu6xHriouasOUmwUrPnGtQcpNlZ2kmcj4APNjXEneWyUJ3mawIc9ohDgJoEAN60V4CaekzybRnCSp6kfTpSbAEW5qfCTPJSAmzA4702Ed7BaeYd9PUx5shHD995NwJzZrHGSx27WTz7GnPRvITSIPd84yWPzCsReaIg9vNiLjZM8tqhA7CUtYkd/5YYQe/dJHqS3LTdO8tiygsTZvJE44U/yIBNni8ZJHruFgsTZspE44Q8kIBNnq8ZJHruVgsTZupE4shJnm8ZJHruNgsTZtpE44U/yIBNnu8ZJHrudgsTZXvpJHhJljuELr42Aj2pzwMShOfqA1/DEvv8UH+TaFRhiciLwqzv0I150TE5iiEmJISYnAWNSEh6TkxlisjlDTE4GxmRz4TE5hSEmWzLE5BRgTLYUHpNTGWKyNUNMTgXGZGvhMTmNISbbMsTkNGBMthUek9MZYrI9Q0xOB8YEaSh8H25y/FIA/RwGek2Rv5kJ+Kg08r+zYIfgo9Idaz8q3cHzUemOFR+VogPc/Rsq/ZQEOOwHrzsAzeiOTMJDF1ok552ABdunZxPu+t+RN9+TREQhRM2FfJK4s/B4kF527oevWzuDmxuuuip549xF+Ifr3Q/mmrDzsmA9SRHWkxVhPUUR1lMVYT1NEdbTmbD6DFT3JfjoZcwDl8Wk7Bqs+W61JmVXj0nZrcKkdF+Sj2PuCmzCdsMZgVhvRGnCXXYKQAMQ9XHM3QNR7lEryt09otyjB6I04a6qRQwryt2BotwDHFy0+CgBd2dwBrsL72q18g77jQ/lya54R5SZApgzewLXsE+Tzu9y9uwnH+Ne0j9o0yD2vYGPjrSKfW8FYt+nIfbwYt8Xt4hqj2Puq0Ds+2kRO/pTZYTYu49jIr3t/riAqD2Oub+CxBndSJzwxzGRiXMALiBqj2MeoCBxDmwkTvhTZcjEOQgXELXHMQ9SkDgHNxJHVuIcgguI2uOYhyhInEMbiRP+OCYycQ7DBUTtcczDFCTO4VITp1tIJMq9GL762hX4qHYvYOLQHH3Aa3hG33+KD3Lt9mGIyRnAL/HQj3jRMTmTISb7McTkTGBM9hMek7MYYjKaISZnAWMyWnhMzmaIyYEMMTkbGJMDhcfkHIaYHMwQk3OAMTlYeEzOZYjJoQwxORcYk0OFx+Q8hpgczhCT84AxgRuK4ELHBml2j2A+MYQ4abURw/dxRwJ5+z7SRcf8f1+8AzHTfLsw5CPyR7MBHyRHfpT3qOCD5KNrP0g+yvNB8tH9+I7yNjElzhHC/2bRbmHDC8ZQns1hAJg/VwKG/Zj9KCCuo4GFEKhnC9BIJEfAkbE4hrmBMOEuSw3OkQz14Nh+susgxeVYBby5NH4EUONjwBrvvvqBY46s/cf9d2vsvxdH3tGLgDH9xsdYMtYzFWE9SxHWsxVhPUcR1nMVYT2PCavvYUP3JfiYetwDl8WAHx+s+dhaA368x4CPrTDg3ZfkY+rHAzf4sbinK/HeiNKEu2wfQGMS9TH1cYEoT6gV5TiPKE/ogShNuKtqEcOKchxQlCeAg4sWHyXgOAZXNU64m9TKO+y3j5Qnx+Mfk2f6AHPmROAa9mnS+b3iif3kYzxJ+oe+GsR+MvCxhFaxn6xA7Kc0xA747XjcIqo9pn6qArGfpkXs6CMcCLF3H1NHetvTcQFRe0z9dAWJc0YjccIfU0cmzpm4gKg9pn6mgsQ5q5E44U/bIhPnbFxA1B5TP1tB4pzTSBxZiXMuLiBqj6mfqyBxzmskTvhj6sjEOR8XELXH1M9XkDgXSE2cbiGRKE9iOApwPPBR7UnAxKE5+oDX8Py+/xQf5NqdwhCT84HHpdCPeNExuYAhJqcxxOQCYExOEx6TCxlicgZDTC4ExuQM4TG5iCEmZzHE5CJgTM4SHpOLGWJyDkNMLgbG5BzhMbmEISbnMcTkEmBMzhMek0sZYnIBQ0wuBcYEbiiCCx0bpNm9EHwCB34qNjhlhv5OE3k8/0hgPC4CatD38TA6/2gdpwCuJX3ZfxzD95CAj5sjP/J+cfBx8yW1Hzdf7Pm4+ZJ+9Y+8m3DX//7urSMYgnKa8CNnXGI8nenIe38wTuTH7BcDi+QlwIID1KA9XckxdWQsLmVuIEy4y1KDcxFDDl/WT3btorhcpoA3l8YvBGr8crDGuy/0ibgr/rt18d+LI1fo4f3l/cbHRTLWCxRhvVAR1osUYb1YEdZLFGG9lAmrz4h3X4KPlic8cFmM7pXBml9Va3Sv9BjdqyqMbvcl+Wj5lcBG5CrcU4xEb0Rpwl22L6Axifpo+dWBKK+pFeXVHlFe0wNRmnBX1SKGFeXVQFFeAw4uWnyUgFczOKGrhTtArbzDfq9IeXIl/lVTpi8wZ64FrmGfJp3fGF7bTz7G66R/nKtB7NcDH0toFfv1CsR+Q0Ps4cV+I24R1R4tv1GB2G/SInb0sQuE2LuPliO97c24gKg9Wn6zgsS5pZE44Y+WIxPnVlxA1B4tv1VB4tzWSJzwJ2SRiXM7LiBqj5bfriBx7mgkjqzEuRMXELVHy+9UkDh3NRIn/NFyZOLcjQuI2qPldytInHukJk63kEiU1zEcp7kS+Kj2OmDi0Bx9wGt4Wd9/ig9y7W5giMllwCNO6Ee86JhczhCTmxhicjkwJjcJj8kVDDG5hSEmVwBjcovwmFzJEJPbOPYTYExuEx6TqxhicgdDTK4CxuQO4TG5miEmdzHE5GpgTO4SHpNrGGJyD0NMrgHGBG4oggu+rwB79nvBp2bQHqr7ZBj6O03kkfqLgPG4D6hB38fD6PyjdewDXEv6sv8Khu8hAR83R360/P7g4+YHaj9uvt/zcfMD/fiOllOAL2QIyuXCj5xxifEKJUfLkR+z3w8skg8gCw7wCOUVSo6WI2PxIHMDYcJdlhqc+xhy+KF+smsXxeUhBby5NH4vUOMPgzXefaFPxD3y362L/14cuUIP7x/uNz4ukrFergjrFYqwXqkI61WKsF6tCOs1TFh9Rrz7Eny0POmBy2J0Hw3W/LFao/uox+g+VmF0uy/JR8sfBTYij+GeYiR7I0oT7rL9AI1J1EfLHw9E+UStKB/3iPKJHojShLuqFjGsKB8HivIJcHDR4qMEfJzBCT0u3AFq5R32e0XKk0fxr5oy/YA58yRwDfs06fzG8Ml+8jE+Jf3jXA1ifxr4WEKr2J9WIPZnGmIPL/ZncYuo9mj5swrE/pwWsaOPXSDE3n20HOltn8cFRO3R8ucVJM4LjcQJf7QcmTgv4gKi9mj5iwoS56VG4oQ/IYtMnJdxAVF7tPxlBYnzSiNxZCXOq7iAqD1a/qqCxHmtkTjhj5YjE+d1XEDUHi1/XUHivCE1cbqFRKJ8iuE4zaPAR7VPAROH5ugDXsNr+/5TfJBr9wxDTK4FHnFCP+JFx+Q6hpg8xxCT64AxeU54TK5niMkLDDG5HhiTF4TH5AaGmLzEEJMbgDF5SXhMbmSIySsMMbkRGJNXhMfkJoaYvMYQk5uAMXlNeExuZojJGwwxuRkYE7ihCC50bJBm903wqRm0h+o+GYb+ThN5pP4+YDzeAmrQ9/EwOv9oHfsC15K+7H+E4XtIwMfNkR8tfzv4uPmd2o+b3/Z83PxOP76j5RTgexmCcofwI2dcYrxTydFy5MfsbwOL5DvAggPUoL1TydFyZCzeZW4gTLjLUoPzFkMOv9dPdu2iuLyngDeXxt8Eavx9sMa7L/SJuA/+u3Xx34sjV+jh/fv9xsdFMtbrFGG9XhHWGxRhvVER1psUYb2ZCavPiHdfgo+WpzxwWYzuh8Gaf1RrdD/0GN2PKoxu9yX5aPmHwEbkI9xTjFRvRGnCXbY/oDGJ+mj5x4EoP6kV5cceUX7SA1GacFfVIoYV5cdAUX4CDi5afJSAHzM4oY+FO0CtvMN+r0h58iH+VVOmPzBnPgWuYZ8mnd8YftpPPsbPpH+cq0HsnwMfS2gV++cKxP5FQ+zhxf4lbhHVHi3/UoHYv9IidvSxC4TYu4+WI73t17iAqD1a/rWCxPmmkTjhj5YjE+dbXEDUHi3/VkHifNdInPAnZJGJ8z0uIGqPln+vIHF+aCSOrMT5ERcQtUfLf1SQOD81Eif80XJk4vyMC4jao+U/K0icX6QmTreQSJSfMRyn+RD4qPYzYOLQHH3Aa3hL33+KD3LtvmCIyS3AI07oR7zomNzKEJOvGGJyKzAmXwmPyW0MMfmGISa3AWPyjfCY3M4Qk+8YYnI7MCbfCY/JHQwx+YEhJncAY/KD8JjcyRCTnxhicicwJj8Jj8ldDDH5hSEmdwFjAjcUwYWODdLs/go+NYP2UN0nw9DfaSKP1L8FjMdvQA36Ph5G5x+tYz/gWtKX/R8wfA8J+Lg58qPlvwcfN/9R+3Hz756Pm//ox3e0nAL8JkNQnhR+5IxLjE8pOVqO/Jj9d2CR/ANYcIAatE8pOVqOjMWfzA2ECXdZanB+Y8jhv/rJrl0Ul78U8ObS+K9Ajf8N1nj3hT4RRxsACqewuvjvxZEr9PD+737j4yIZ662KsN6mCOvtirDeoQjrnYqw3sWE1WfEuy/BR8vTHrgsRneKwLj06d9UbWrpP6g1uvQvjagBJflo+RT9cbj69McFtzeiNOEuOwDQQEV9tLxvIMp+taLs6xFlvx6I0oS7qhYxrCj7AkXZrz82uGjxUQJ2x6xy3rC8+/aXvZtp5R32e0XKE+IOftSdGQB0lP2Ba9inSec3hv37y8c4AI3x/6LYm4GPJbSKvVmB2FsaYg8v9lbcIqo9Wt6qQOxtWsSOPnaBEHv30XKkt23HBUTt0fJ2BYnT0Uic8EfLkYnTiQuI2qPlnQoSp6uROOFPyCITZ0pcQNQeLZ9SQeIMbCSOrMQZhAuI2qPlgxQkzuBG4oQ/Wo5MnCG4gKg9Wj5EQeJMJTVxuoVEohyAfxJW9bLahLuqnp1LPFp+d99/ig9y7VoYYnI38IgT+hEvOib3MMSkjSEm9wBj0iY8JvcyxKSDISb3AmPSITwm9zHEpIshJvcBY9IlPCb3M8RkIENM7gfGZKDwmDzAEJPBDDF5ABiTwcJj8iBDTKZiiMmDwJjADUVwoWODNLtTA2NMc6A9VPfJMPR3msgj9b8Bv0wYCtRgFEfLaR37A9fyf1/2M3wPCfi4OfKj5cOCj5uH137cPMzzcfPw/nxHyynAvzIcU3xL+JEzLjG+reRoOfJj9mHATWs4cNMCatC+reRoOTIW0zA3ECbcZanBGcqQw9MKP1hAcZlWAW8ujU8N1Ph0YI13X+gTcdP/d+vivxdHrtDD++n6j4+LZKz3KMJ6ryKs9ynCer8irA8owvogE1alR8szHrgsRneGYM1nrDW6M3iM7owVRrf7kny0fAZgIzIj7mh5Jsqj5c0Kj5bPFIhyRK0oZ/KIckQER8ubgW58JqAoR/THBhctPkrAmRic0EzCHaBW3mG/V6Q8mYHhAGIz8DH/zI2j5Xbm/vIxziL941wNYp+1cbTczqpA7LM1xB5e7LM3jpbb2RWIfQ4tYkcfu2jGHbsoI73tnI2j5XZOBYkzVyNxwh8tRybOyMbRcjtSQeLM3Uic8CdkkYkzT+NouZ1HQeLM20gcWYkzX+NouZ1PQeLM30ic8EfLkYmzQONouV1AQeIY6UfLSZSzMBynmQH4qHYWYOLQHH3Aa/hQ33+KD3LtZmOIyUPAI07oR7zomDzMEJM5GGLyMDAmcwiPySMMMZmLISaPAGMyl/CYPMoQk7kZYvIoMCZzC4/JYwwxmZchJo8BYzKv8Jg8zhCT+Rli8jgwJvMLj8kTDDExDDF5AhgTuKEILnRskGbXCj9a3n0yDP2dJvJI/VBgPGJADUZxtJzWEfF3UnXPR1/2T8/wPWSzwqPl8eDj5kTtx81xz8fNCcaj5RTgqRmC8rXwI2dcYvxGydFy5MfscWCRTACLN1CD9hslR8uRsUgyNxAm3GWpwYkx5HBK+MECiktKAW8ujVugxtNgjXdf6BNxmf9uXfz34sgVenif7j8+LpKxPqwI6yOKsD6qCOtjirA+rgjrE0xYlR4tz3rgshjdbLDmC9Ya3azH6C5YYXS7L8lHy7PARmRB3NHybJRHy1sUHi1fKBDlwrWiXMgjyoUjOFreAnTjCwFFuXB/bHDR4qMEXIjBCS0k3AFq5R32e0XKkyzDAcQW4AHERRpHy+0i/eVjXFT6x7kaxL4Y8LGEVrEvpkDsizfEHl7sSzSOltslFIh9SS1iRx+7aAEeLUd626UaR8vtUgoSZ+lG4oQ/Wo5MnGUaR8vtMgoSZ9lG4oQ/IYtMnOUaR8vtcgoSZ1QjcWQlzvK4gKg9Wr68gsRZoZE44Y+WIxNnxcbRcruigsRZSfrRchLlogzHabLAR7WLAhOH5ugDXsMn+/5TfKBrxxCTJ4FHnNCPeNExeYohJksyxOQpYEyWFB6TpxlisjRDTJ4GxmRp4TF5hiEmyzLE5BlgTJYVHpNnGWIyiiEmzwJjMkp4TJ5jiMkKDDF5DhiTFYTH5HmGmKzEEJPngTGBG4rgQscGaXZXZj4ZhjghFGM4Wo48Uh8DxmMVoAajOFpO64j4O6m656Mv+zMM30O2KDxavmrwcfNqtR83r+r5uHk1xqPlFGDLEJSmYdiCi+bNJcYphvFsNP3BOJEfs68KLJKrITctXCwsIK6RHC1HxmJ15gbChLssNTirMOTwGsIPFlBc1lDAm0vjKwM1viZY490X+kTcWv/duvjvxZEr9PB+zf7j4yIZ61OKsD6tCOszirA+qwjrc4qwPs+EVenR8pwHLovRXTtY83Vqje7aHqO7ToXR7b4kHy1fG9iIrIM7Wp6L8mh5q8Kj5esGolyvVpTrekS5XgRHy1uBbnxdoCjX648NLlp8lIDrMjihdYU7QK28w36vSHmyNsMBxFbgAcT1G0fL7fr95WPcQPrHuRrEviHwsYRWsW+oQOwbNcQeXuwbN46W240ViH0TLWJHH7toBR4tR3rbTRtHy+2mChJns0bihD9ajkycXONouc0pSJx8I3HCn5BFJk6hcbTcFhQkTrGROLISp4QLiNqj5SUFiVNuJE74o+XIxNm8cbTcbq4gcbaQfrScRLkBw3GatYGPajcAJg7N0Qe8hi/0/af4INduI4aYvAA84oR+xIuOyYsMMdmEISYvAmOyifCYvMQQk80YYvISMCabCY/JywwxyTPE5GVgTPLCY/IKQ0yKDDF5BRiTovCYvMoQkzJDTF4FxqQsPCavMcRkC4aYvAaMCdxQBBc6NkizuyXzyTDECaFVGI6WI4/UrwKMx1ZADUZxtJzWEfF3UnXPR1/2r8XwPWSrwqPlWwcfN29T+3Hz1p6Pm7dhPFpOAV6ZISiDhB854xLjYCVHy5Efs28NLJLbAIs3UIN2sJKj5chYbMvcQJhwl6UGZyuGHN5O+MECist2CnhzaXxLoMa3B2u8+0KfiNvhv1sX/704coUe3m/ff3xcJGN9URHWlxRhfVkR1lcUYX1VEdbXmLAqPVqe98BlMbo7Bmu+U63R3dFjdHeqMLrdl+Sj5TsCG5GdcEfL81EeLW9TeLR850CUu9SKcmePKHeJ4Gh5G9CN7wwU5S79scFFi48ScGcGJ7SzcAeolXfY7xUpT3ZkOIDYBjyAuGvjaLndtb98jLtJ/zhXg9h3Bz6W0Cr23RWIfY+G2MOLfc/G0XK7pwKx76VF7OhjF23Ao+VIb7t342i53VtB4uzTSJzwR8uRibNv42i53VdB4uzXSJzwJ2SRibN/42i53V9B4oxuJI6sxDkAFxC1R8sPUJA4BzYSJ/zRcmTiHNQ4Wm4PUpA4B0s/Wk6i3I3hOM2OwEe1uwETh+boA17D1/v+U3yQa7cHQ0xeBx5xQj/iRcfkDYaY7MUQkzeAMdlLeEzeZIjJPgwxeRMYk32Ex+QthpjsxxCTt4Ax2U94TN5miMlohpi8DYzJaOExeYchJgcyxOQdYEwOFB6TdxlicjBDTN4FxgRuKIILHRuk2T2E+WQY4oTQVgxHy5FH6rcCxuNQoAajOFpO64j4O6m656Mv+3dg+B6yTeHR8sOCj5sPr/24+TDPx82HMx4tpwBvyRCUWYQfOeMS46xKjpYjP2Y/DFgkDwcWb6AG7axKjpYjY3EEcwNhwl2WGpxDGXL4SOEHCyguRyrgzaXxQ4AaPwqs8e4LfSLu6P9uXfz34sgVenh/VP/xcZGM9Q1FWN9UhPUtRVjfVoT1HUVY32XCqvRoecEDl8XoHhOs+bG1RvcYj9E9tsLodl+Sj5YfA2xEjsUdLS9EebS8XeHR8jGBKI+rFeUYjyiPi+BoeTvQjY8BivK4/tjgosVHCTiGwQmNEe4AtfIO+70i5ckxDAcQ24EHEI9vHC23x/eXj3Gs9I9zNYh9HPCxhFaxj1Mg9hMaYg8v9hMbR8vtiQrEfpIWsaOPXbQDj5Yjve3JjaPl9mQFiXNKI3HCHy1HJs6pjaPl9lQFiXNaI3HCn5BFJs7pjaPl9nQFiXNGI3FkJc6ZuICoPVp+poLEOauROOGPliMT5+zG0XJ7toLEOUf60XIS5ViG4zTHAB/VjgUmDs3RB7yG7/X9p/gg1+4Ehpi8BzzihH7Ei47J+wwxOYkhJu8DY3KS8Jh8wBCTUxhi8gEwJqcIj8mHDDE5jSEmHwJjcprwmHzEEJMzGGLyETAmZwiPyccMMTmLISYfA2NylvCYfMIQk3MYYvIJMCZwQxFc6Nggze65zCfDECeEDmU4Wo48Un8oMB7nATUYxdFyWkfE30nVPR992X80w/eQ7QqPlp8ffNx8Qe3Hzed7Pm6+gPFoOQX4EIagxIUfOeMSY0LJ0XLkx+znA4vkBcDiDdSgTSg5Wo6MxYXMDYQJd1lqcM5jyOGLhB8soLhcpIA3l8bPBWr8YrDGuy/0ibhL/rt18d+LI1fo4f3F/cfHRTLW9xVh/UAR1g8VYf1IEdaPFWH9hAmr0qPlRQ9cFqN7abDml9Ua3Us9RveyCqPbfUk+Wn4psBG5DHe0vBjl0fIOhUfLLw9EeUWtKC/3iPKKCI6WdwDd+OVAUV7RHxtctPgoAS9ncEKXC3eAWnmH/V6R8uRShgOIHcADiFc2jpbbK/vLx3iV9I9zNYj9auBjCa1iv1qB2K9piD282K9tHC231yoQ+3VaxI4+dtEBPFqO9LbXN46W2+sVJM4NjcQJf7QcmTg3No6W2xsVJM5NjcQJf0IWmTg3N46W25sVJM4tjcSRlTi34gKi9mj5rQoS57ZG4oQ/Wo5MnNsbR8vt7QoS5w7pR8tJlFcxHKe5FPio9ipg4tAcfcBr+Gnff4oPcu2uYYjJp8AjTuhHvOiYfMYQk+sYYvIZMCbXCY/J5wwxuYEhJp8DY3KD8Jh8wRCTmxhi8gUwJjcJj8mXDDG5hSEmXwJjcovwmHzFEJPbGGLyFTAmtwmPydcMMbmDISZfA2MCNxTBhY4N0uzeyXwyDHFC6DyGo+XII/XnAeNxF1CDURwtp3VE/J1U3fPRl/2XMHwP2aHwaPndwcfN99R+3Hy35+PmexiPllOAz2UIytLCj5xxiXEZJUfLkR+z3w0skvcAizdQg3YZJUfLkbG4l7mBMOEuSw3OXQw5fJ/wgwUUl/sU8ObS+J1Ajd8P1nj3hT4R98B/ty7+e3HkCj28v7//+LhIxvqZIqyfK8L6hSKsXyrC+pUirF8zYVV6tLzkgctidB8M1vyhWqP7oMfoPlRhdLsvyUfLHwQ2Ig/1xwU3yqPlnQqPlj8ciPKRWlE+7BHlIxEcLe8EuvGHgaJ8pD82uGjxUQI+zOCEHhbuALXyDvu9IuXJgwwHEDuBBxAfBa5hnyad3xg+2l8+xsekf5yrQeyPAx9LaBX74wrE/kRD7OHF/iRuEdUeLX9Sgdif0iJ29LGLTuDRcqS3fbpxtNw+rSBxnmkkTvij5cjEebZxtNw+qyBxnmskTvgTssjEeb5xtNw+ryBxXmgkjqzEeREXELVHy19UkDgvNRIn/NFyZOK83Dhabl9WkDivSE2cbiGRKB9jOE7zIPBR7WPAxKE5+oDX8Ju+/xQf5No9wRCTb4BHnNCPeNEx+ZYhJk8xxORbYEyeEh6T7xhi8gxDTL4DxuQZ4TH5niEmzzHE5HtgTJ4THpMfGGLyAkNMfgDG5AXhMfmRISYvMcTkR2BMXhIek58YYvIKQ0x+AsYEbiiCCx0bpNl9lflkGOKE0F0MR8uRR+rvAsbjNaAGozhaTuuI+DupuuejL/sfYPgeslPh0fLXg4+b36j9uPl1z8fNbzAeLacA38kQlLWFHznjEuM6So6WIz9mfx1YJN8AFm+gBu06So6WI2PxJnMDYcJdlhqc1xhy+C3hBwsoLm8p4M2l8VeBGn8brPHuC30i7p3/bl389+LIFXp4/3b/8XGRjPVbRVi/U4T1e0VYf1CE9UdFWH9iwqr0aHnZA5fF6L4brPl7tUb3XY/Rfa/C6HZfko+WvwtsRN7DHS0vR3m0vEvh0fL3A1F+UCvK9z2i/CCCo+VdQDf+PlCUH/THBhctPkrA9xmc0PvCHaBW3mG/V6Q8eZfhAGIX8ADih42j5fbD/vIxfiT941wNYv8Y+FhCq9g/ViD2TxpiB/xdSI2j5fZTBWL/TIvY0ccuuoBHy5He9vPG0XL7uYLE+aKROOGPliMT58vG0XL7pYLE+aqROOFPyCIT5+vG0XL7tYLE+aaROLIS51tcQNQeLf9WQeJ810ic8EfLkYnzfeNouf1eQeL8IP1oOYnyI4bjNO8CH9V+BEwcmqMPeA1/7vtP8UGu3ScMMfkZeMQJ/YgXHZNfGGLyGUNMfgHG5DPhMfmVISZfMMTkV2BMvhAek98YYvIVQ0x+A8bkK+Ex+Z0hJt8wxOR3YEy+ER6TPxhi8h1DTP4AxuQ74TH5kyEmPzDE5E9gTOCGIrjQsUGa3R+ZT4YhTgi9xnC0HHmk/jVgPH4CajCKo+W0joi/k6p7Pvqy/x2G7yG7FB4t/zn4uPmX2o+bf/Z83PxLxcfN6CBTgJEJ0x1k9IkA5MfXPwOT+pf+POKDP2wBcv6VeWMx4S5LG99PDIXmN+EfnFNcflPIG/Eg8cf++PX8ua9s3r8w8f5FOO9fmXj/Kpz3b0y8fxPO+3cm3r8L5/0HE+8/hPP+k4n3n2De3Rea/0b9ZPdXNN+ofvgefwogxrG4WNvSUKxxH9JU/eUAWj8UmzF98XEfw5Q/TVCcMb657T8a7Y7ZiODPv7ta9Ycbf7rxlxt/k6kf4P4dN/q40deNfm70d2OAG81utLjR6kabG+1udLjR6UaXG1O6MdCNQW4MdmOIG1O5MbUbQ90Y5sZwN6ZxY9oBTdUPCwhMS829Pzz3/vTc+8tz72/PPSJXe28Kz70+nnt9Pff6ee7199wb4LnX7LnX4rnX6rnX5rnX7rnX4bnX6bnX5bk3pefeQM+9QZ57gz33hnjuTeW5N7Xn3lDPvWGee8M996bx3Js2uFd59Qv+uXjwzzCff1HK/dkfMdc/6ftX+Ln+fYj0N/CBytZMv0cIiUXiX5yW8j7EXKaCs50izFyxqvWzfQbgYrGNzFiYGpy272RyTpUn4Gz7Td5cGc/62f7AWGwrLRYZL047oPec03U42+bezpWuu362BRiL7eTEIjYRnLa1N5zTE+Vs23o+V2ES62fbgbHYXkIs0pPEaTt6xtn0gLPt7MlcpkfrZ7uAsdjh/28skj3EaaecFOdEjznbgROdK1HuxfrZQcBY7Pj/KxbpXuG0g+tzzvSSsx1SZ65sudfrZ6cCxmKn6GNhJgOnndrH2UwWZzt0wrnsZK6fHQaMxc5RxqI42Tjt8GrO8RCc7TQVc8XKodbPTguMxS5MseiqiYUJd1U97Av9Agfi4f/3A3X2D+DHB5viHuxaoIe3QA9qgR7KAj2ABfawFtiDWWAPYYF7oAXWcIusQbQHDGoa/7Kh8kK/gEDU4X/qSNFW4p1uACNgmhz1NVc3+OkG4DBOD9zcuNaQMGLPPhereJuQV5S/5TstDHeR9U1Z5VrMECTYjLVvq2YYMOHnrjN63iqgvxHHVRJjZwAm0IxMwUV/TorkPBOwmDU14ROOXqdTsUB/7jAK+KuHyCI+Qng8SC8jgBsCA+9Iu6JpYLUsW6zEO/MARsAzw7uibHFmoHBnEd4V0RrOAu+KssVZgEnAwZuK5gjhxXgEUDuzgotx94VuCJD5MhuQc5Sd+TQw3NmCBy5LZz57UOTnqO3MZ/d05nNE0JnjdjNjZweKcg6m4KITEcl5TuGdIBXH2Rg6wbmEb4IUl7kU8ObSOHKzHilc4yOCWKMbHmSTMhdwrrnBm39ULmw4bN/KxyvxzjOAEfA8cBeWj88DDOC8wl0YreG8cBeWj88rfAOiojk3wwY0n5INCKnL+ZW6neEw3PmYBy6L21kgKKam1u0s4HE7JgK3g9s1jF0AKErDFFx0IiI5W+GdIBXH+RmKbkz4ZkNxiSngzaXxGFDjcWaNI1yJz+2YcJdFvtNCup0Ec+4h9JIYIFvTSaWOcRhs78+UK/GmBjACTsEdY6acAgYwLdwx0hqm4Y4xU04rcIxJhk08o2QTR+oyq9QxDoPhzpQ8cFkc44JBMV2o1jEu6HGMC0XgGHG7hrELAkW5EFNw0YmI5LywcMdIxTHLUHQXEb7ZUFwWUcCbS+OLADW+qHCN13MoJtxlkQ5lMeEuj2K82ADZOlxcqcsbCtuvY6YS7xIDGAEvAXd5MbMEMIBLCnd5tIZLwl1ezCypwOUtzrDxLqVk40XqcmmlLm8oDLcte+CyuLxlgmK6bK3LW8bj8paNwOXhdg1jlwGKclmm4KITEcl5OeEdMBXHpRmK7ijhmw3FZZQC3lwaHwXU+PLCNV7PoZhwl0U6lBWEuzyK8QoDZOtwRaUub2rYfl2scnkrDWAEvBLc5RXNSsAArizc5dEargx3eUWzsgKXtyLDxruKko0XqctVlbq8qWG4C5G5vNWCYrp6rctbzePyVo/A5eF2DWNXA4pydabgohMRyXkN4R0wFcdVGYrumsI3G4rLmgp4c2l8TaDG1xKu8XoOxYS7LNKhrC3c5VGM1x4gW4frKHV5U8H261TV78+tO4AR8Lpwl5ey6wIDuJ5wl0druB7c5aWqeJuQFwdvcnnrMGy86yvZeJG63ECpy5sKhjsV2W8NbhgU041qXd6GHpe3UQQuD7drGLshUJQbMQUXnYhIzhsL74CpOG7AUHQ3Eb7ZUFw2UcCbS+ObADW+qXCN13MoJtxlkQ5lM+Euj2K82QDZOswpdXlDcO/yMpV48wMYAefx7/IyeWAAC8JdHq1hAf8uL1NQ4PJyDBtvUcnGi9RlSanLGwLDXUx74LK4vHJQTDevdXllj8vbPAKXh9s1jC0DRbk5U3DRiYjkvIXwDpiKY4mh6G4pfLOhuGypgDeXxrcEanwr4Rqv51BMuMsiHcrWwl0exXjrAbJ1uI1SlzcYtl8nspV4tx3ACHhbuMtLZLcFBnA74S6P1nA7uMtLZLdT4PK2Ydh4t1ey8SJ1uYNSlzcYhjuR8cBlcXk7BsV0p1qXt6PH5e0UgcvD7RrG7ggU5U5MwUUnIpLzzsI7YCqOOzAU3V2EbzYUl10U8ObS+C5Aje8qXOP1HIoJd1mkQ9lNuMujGO82QLYOd1fq8gbB9ut81RebewxgBLwH3OXl7R7AAO4p3OXRGu4Jd3n5Kt4m5MXBm1ze7gwb715KNl6kLvdW6vIGwXDnI/tic5+gmO5b6/L28bi8fSNwebhdw9h9gKLclym46EREct5PeAdMxXFvhqK7v/DNhuKyvwLeXBrfH6jx0cI1Xs+hmHCXRTqUA4S7PIrxAQNk6/BApS5vIM7lFSrxHjSAEfBBeJdXOAgYwIOFuzxaw4PxLq9wsAKXdyDDxnuIko0XqctDlbq8gTgjkPfAZXF5hwXF9PBal3eYx+UdHoHLw+0axh4GFOXhTMFFJyKS8xHCO2AqjocyFN0jhW82FJcjFfDm0viRQI0fJVzj9RyKCXdZpEM5WrjLoxgfPUC2Do9R6vKmxH2xma/Ee+wARsDH4r/YzB8LDOAY4S6P1nAM/ovN/BgFLu8Yho33OCUbL1KXxyt1eVPiPurLeeCyuLyxQTEdV+vyxnpc3rgIXB5u1zB2LFCU45iCi05EJOcThHfAVByPZyi6JwrfbCguJyrgzaXxE4EaP0m4xus5FBPuskiHcrJwl0cxPnmAbB2eotTldcH260zV36Rw6gBGwKfCXV7GnAoM4GnCXR6t4Wlwl5cxpylweacwbLynK9l4kbo8Q6nL64LhTpc9cFlc3plBMT2r1uWd6XF5Z0Xg8nC7hrFnAkV5FlNw0YmI5Hy28A6YiuMZDEX3HOGbDcXlHAW8uTR+DlDj5wrXeD2HYsJdFulQzhPu8ijG5w2QrcPzlbq8TiaXd8EARsAXMLi8C4ABvFC4y6M1vJDB5V2owOWdz7DxXqRk40Xq8mKlLq9Tocu7JCiml9a6vEs8Lu/SCFwebtcw9hKgKC9V4vKQnC8T3gFTcbyYoeheLnyzobhcroA3l8YvB2r8CuEar+dQTLjLIh3KlcJdHsX4ygGydXiVUpfXAduvc1W/sXn1AEbAV8NdXi57NTCA1wh3ebSG18BdXi57jQKXdxXDxnutko0XqcvrlLq8DhjuXGS/sXl9UExvqHV513tc3g0RuDzcrmHs9UBR3sAUXHQiIjnfKLwDpuJ4HUPRvUn4ZkNxuUkBby6N3wTU+M3CNV7PoZhwl0U6lFuEuzyK8S0DZOvwVqUurx3n8hKVeG8bwAj4NrzLS9wGDODtwl0ereHteJeXuF2By7uVYeO9Q8nGi9TlnUpdXjvOCMQ9cFlc3l1BMb271uXd5XF5d0fg8nC7hrF3AUV5N1Nw0YmI5HyP8A6YiuOdDEX3XuGbDcXlXgW8uTR+L1Dj9wnXeD2HYsJdFulQ7hfu8ijG9w+QrcMHlLq8Nth+Xax6l/fgAEbAD8JdXjH7IDCADwl3ebSGD8FdXjH7kAKX9wDDxvuwko0XqctHlLq8NhjuYmTv8h4NiuljtS7vUY/LeywCl4fbNYx9FCjKx5iCi05EJOfHhXfAVBwfYSi6TwjfbCguTyjgzaXxJ4Aaf1K4xus5FBPuskiH8pRwl0cxfmqAbB0+rdTltcL260KpEu8zAxgBPwN3eYXSM8AAPivc5dEaPgt3eYXSswpc3tMMG+9zSjZepC6fV+ryWmG4C0UPXBaX90JQTF+sdXkveFzeixG4PNyuYewLQFG+yBRcdCIiOb8kvAOm4vg8Q9F9WfhmQ3F5WQFvLo2/DNT4K8I1Xs+hmHCXRTqUV4W7PIrxqwNk6/A1pS6vBbZf26p3ea8PYAT8Otzl2ezrwAC+Idzl0Rq+AXd5NvuGApf3GsPG+6aSjRepy7eUurwWGG4b2bu8t4Ni+k6ty3vb4/LeicDl4XYNY98GivIdpuCiExHJ+V3hHTAVx7cYiu57wjcbist7Cnhzafw9oMbfF67xeg7FhLss0qF8INzlUYw/GCBbhx8qdXnNsP06X+XyPhrACPgjuMvLZz8CBvBj4S6P1vBjuMvLZz9W4PI+ZNh4P1Gy8SJ1+alSl9cMw52PzOV9FhTTz2td3mcel/d5BC4Pt2sY+xlQlJ8zBRediEjOXwjvgKk4fspQdL8UvtlQXL5UwJtL418CNf6VcI3Xcygm3GWRDuVr4S6PYvz1ANk6/EapyxsA268zmUq83w5gBPwt3OVlMt8CA/idcJdHa/gd3OVlMt8pcHnfMGy83yvZeJG6/EGpyxsAw51Je+CyuLwfg2L6U63L+9Hj8n6KwOXhdg1jfwSK8iem4KITEcn5Z+EdMBXHHxiK7i/CNxuKyy8KeHNp/Begxn8VrvF6DsWEuyzSofwm3OVRjH8bIFuHvyt1ef1h+3WiyuX9MYAR8B9wl5fI/AEM4J/CXR6t4Z9wl5fI/KnA5f3OsPH+pWTjReryb6Uurz8MdyIyl9fUHKxFc1O1o6P/oNbl0b/E7fJwu4bruppxopyimSe46EREcu7TjIvr/0QG1goVx78Zim7fZtmbDcWlb7N83lwa7wvUeD/hGq/nUEy4yyIdSn/mfEHEmDBK1uGAZmzTE5XL6wfbr7O2Em9zMyPg5ma0y8vaZmAAW4DC4lrDlma0y8tW8TYhLw7e5PIGMGy8rUo2XqQu28AFLyqX1w/m8rLGA5fF5bUHxbSj1uW1e1xeRwQurx/Q5bUDRdnRzBNcdCIiOXcK74CpOLYxFN0u4ZsNxaVLAW8ujXcBNT6lcI3Xcygm3GWRDmWgcJdHMR7YLFuHg5S6vL6w/TptKvEObmYEPBju8tJmMDCAQ4S7PFrDIXCXlzZDFLi8QQwb71RKNl6kLqdW6vL6wlxequyBy+LyhgbFdFityxvqcXnDInB5fYEubyhQlMOaeYKLTkQk5+HCO2AqjlMzFN1phG82FJdpFPDm0vg0QI1PK1zj9RyKCXdZpEOZTrjLoxhP1yxbh9MrdXl9cL++UvU3KczQzAh4BrjLy5dmAAZwRuEuj9ZwRrjLy5dmVODypmfYeGdSsvEidTlCqcvrg/uBjsj+JoWZg2I6S63Lm9nj8maJwOX1Abq8mYGinKWZJ7joRERynlV4B0zFcQRD0Z1N+GZDcZlNAW8ujc8G1PjswjVez6GYcJdFOpQ5hLs8ivEczbJ1OKdSlzcFbL+OVb3Lm6uZEfBccJcXM3MBAzhSuMujNRwJd3kxM1KBy5uTYeOdW8nGi9TlPEpd3hQwl2cje5c3b1BM56t1efN6XN58Ebi8KYAub16gKOdr5gkuOhGRnOcX3gFTcZyHoeguIHyzobgsoIA3l8YXAGrcCNd4PYdiwl0W6VCscJdHMbbNsnUYU+rymnD7daESb7yZEXAc7vJMIQ4MYEK4y6M1TMBdnikkFLi8GMPGm1Sy8SJ1mVLq8ppwvxqT98BlcXnpoJhmal1e2uPyMhG4POCuYdNAUWaaeYKLTkQk56zwDpiKY4qh6C4ofLOhuCyogDeXxhcEanwh4Rqv51BMuMsiHcrCwl0exXjhZtk6XESpy/u7P2q/TlV9sbloMyPgReEuL1VaFBjAxYS7PFrDxeAuL1VaTIHLW4Rh411cycaL1OUSSl1eZcEzoa5UZF9sLhkU06VqXd6SHpe3VAQuD7drGLskUJRLNfMEF52ISM5LC++AqTguwVB0lxG+2VBcllHAm0vjywA1vqxwjddzKCbcZZEOZTnhLo9ivFyzbB2OUury/oLt17bqNzaXb2YEvDzc5Vm7PDCAKwh3ebSGK8Bdnq3ibUJeHLzJ5Y1i2HhXVLLxInW5klKX9xfM5dnIfmNz5aCYrlLr8lb2uLxVInB5fwFd3spAUa7SzBNcdCIiOa8qvAOm4rgSQ9FdTfhmQ3FZTQFvLo2vBtT46sI1Xs+hmHCXRTqUNYS7PIrxGs2ydbimUpf3Z39c7CvxrtXMCHitZvy8awt3ZsR77ebxCwyal81Nrcmwwa2jZINDamld5g0OEZN1I9Ll/4WNZD2lG8kfTBvJ+s2MgNdn2Eg2EL6REO8NFG0k6zFsJBsq2UiQWtpI+EZCMdmosZHA5tpY6Ubye3/cGlTi3aSZEfAmDGLYBBjATYVvSrSGmzIU+k0VvHfamIH3Zko2OKQuc8IfBVJMcgyxzgvXOOV2nmlj59JlHqjLgnBd1mtmTLjLIpuZonCNU4yLDGuI1GFJwV5YYqiPIwfw1JwuMP+5gJx/B76G/wPYkJeBtXDrYbi5tgHOtS1wru2Ac20PnGsH4Fw7AufaCTjXzsC5dsHNZaI048B8rTLjmzczAt6c4anuFsINNPHegqHJJrHRN2J9mvjFNlcTz0Y9Aozzd9SrDmsM6LWJpf8P8i7f/vMPwMeQtvsPoY/P2fF/DPmDK7by/wj1E522+v8M8Zc62Nobk/3XANoJb03mXxxvfTf7T85c1n97QO/nsvX+g+bezmXr/0ctvZvLTuw/bO3NXHbi/3Fbz+eaxEzGtPd0rknOZExHz+bqwUzGdPZkrh7NZEzXpOfq4UzGTDmpuXo8kzEDJz5XL2YyZtDE5urVTMYMrj9XL2cyZki9uXo9kzFT+eeajJmMmdo312TNZMzQCeeazJmMGVY712TPZMzw6rlCzGTMNJVzhZrJmGmBD2EqjcSW1OujnxhRI01PjTiecCEXoftgx5YVhofj6dkWDE82Rw7AYdwK6FLJ8PRr8rvrEeA1aBiJ3szUMBK9m6lhJHo3U8NI9G6mhpHo3UwNI2F6eTWMRO+uhpHo3dXd09K1dfDwfBufoTDhLksN6pZKvrkmnFsxvIbfVvjnBySAbRl4bwd+hdZt+mje0cG86LXYhmkttmdai+0nshZhMXPp4qxhvPkwCXyFSeBj08DZYN4jwNonUw6rVYExB833rzmHzFdh0AHzVZn00PPVGPWQ801g1kPN5zHsIebzmvbJnq+OcZ/M+eqa98mabyIGfjLmm6iJ7/V8kzDyvZxvkma+V/P1wND3Yr4emfoez9dDY9/D+Xps7ns0Xy8Mfg/m65XJn+R8vTT6k5iv12Z/ovNNhuGfyHyTZfrrzjeZxr/OfJNt/r3zhXgA4Jkv1EOACeYL+SCgZr7QDwOq5gM8ENiW4QUVsD+3Z4M//3QtVlPlw4vaq6f/W5PyAJVzcvht1JpUvqzbocKzwEFvCwbdbWB3mMgb3ElMM8n0Icw7MBi5q8FGrvvq18uY9ebBU1jOOzbLLDDIWFTqcseKByuTG59JrTkyPjtVzGXjcZcbxbQtF8vxZDoby9tUPJUqJ8rpVCZRLCcTuWK6ZBO5eCxbSpuyzZRK6WS8kE6Vs8VCqlxZtG0xHk8Us/mCTcZSubzJFOM5U06k4zGTK8bTxWI8k0rl4vFiKlPOZDOxWK4cz5hkOp01qVg8G+OKz05BfCb21YLkz7QrN7Gdgwfku2gp4Fz4dmYo1rsybVy7Mj6FprXYhWEtdmNai90Yn0Jz6eJa4U+huTRw3TDZdYCKLIerAcbbXtdwNbWX3ZnJ1eyu0dXszuxqdmcoDNf/H3Q1ezTLLDDXM3XNeyhzNXsCXc11QFfDFZ89K1xNvU1B8uMoTpxcG8xeGjeYvZg3mL0YNpgbmDaY/mCcyAK2N3Au5GMz5GZ1A1Mx3LsHm1XYNd2nGbcpVD02E7RZccVnn//QI7h9g0dw+3Gcqqv3YakJd9mtwDs3F+8+jLzDYtxf+GNREub+DJvxaKbGZDTjY9H9mNbiAKa1OIDxsSiXLm4W/liUSwO3KHgsuj9DLQXG297SeCxae/2vfqPWpLLBOpDTte7PVBAPZHSthPlAhsJwq5LHovsDm6KDmmUWmFuZnMxBETwWRcbnYOBj0VuATpMrPgf3wGmO6GW8JnE1fqKiVzM1fqKidzM1fqKidzM1fqKidzM1fqKidzM1fqLC9PJq/ERF767GT1T07qo0/ocET+cP1WJ6ufAdwmBwD2My+4cxPgmmtTiUYS0OZ1qLwxmfBHPp4jXhT4K5NPC6gp9pgNWqwJyC5vvXoELmqzCpgPmqjGro+WrMasj5JjCsoebzmNYQ83mN62TPV8e8TuZ8dQ3sZM03ERM7GfNN1Mj2er5JmNlezjdJQ9ur+XpgansxX4+MbY/n66G57eF8PTa4PZqvFya3B/P1yuhOcr5emt1JzNdrwzvR+SbD9E5kvskyvnXnm0zzW2e+yTbA3vlCmGDPfKGM8ATzhTTDNfOFNsRV8wFMMcebe2B/bl9vvLmvvewhTG/uj9D45v4I5jf3RzAYuc//D765P7JZZoH5nOnN8JHK3twfBXxz/zrwzT1XfI76/3CgCfnJFSdOrg3maI0bzNHMG8zRDBvMF0oONCEL2DHAuZCfhiE3qy+YiuExERxoOhZ4oOmWYTI3K674HFsRn5nBcaHvt4F/C9b/3gLA5gveAoDm+/ctAGS+ircAgPmq3gKEnq/mLUDI+SZ4CxBqPs9bgBDzed8CTPZ8dd4CTOZ8dd8CTNZ8E3kLMBnzTfQtQK/nm8RbgF7ON8m3AL2arwdvAXoxX4/eAvR4vh6+BejhfD1+C9Cj+XrxFqAH8/XqLcAk5+vlW4CR4M/eRoI/fRsJ/vxtJPgTuJHgz+BGgj+FGwn+HG4k+JO4keDP4kaCP42j+bqvOjrs9dVUcaH97Rjgw0ROnMdNPs5U7Q3CNrhpvC+j/5vW4a/gz8f2Hf/nMRV/Pi74d7r/e8e7/3usG+PcOKF5/P3uqy9WB/a4vri5jgd6/BOZHsah1+944PqNBa7fSUrWrxW4fuOA63cy+HllbW04saI2nFTx55Mr/nxCTW04xf3fp7pxmhunN48/1jaoKZofURnXN/z6lsr/u0qVeM9oZgR8hucVeljwZwA3uDOBouVawzOBD8G71/DMZh3NzFk4nAlfITirIuHHVjQGp1Tc/7tPdSE42/1n57hxrhvnNVfPh4w9NZ7I2Hev6fnCj0yQ5s9n0Pz5SjR/AQ5n3Kf5Cyo3uQrNnz0RzV/o/rOL3LjYjUsmovmw3Ls1X7tnmHCXrTSFYTFeKjx/+vf9x7RKXsPLmF5I07wjgnnR/GlPAMbeUj26kKG+Xw5cW6UNbrkS7xWcDe4V+Aa3fAVQZFcqaHCvxG/25SuFF2kqppczJP9VzM65XsN81USah6vdf3aNG9e6cR1zw3wlw5per6Bhvp4hh65n1lK9RvTqiWjpBvef3ejGTW7czNyIXim8Eb0FvNEPaIpmoz8W99TRdFbgvDXY6G8L/nl78M87gn/eGfzzruCfdwf/vCf4573BP+8L/nl/8M8Hgn8+yPmJJvAzo6qO+PYAdOW9uzz37vXce6B5QkGgE+0hmIjjCU6cD08+zmLtDV8xfKii6N1a8efbKv78cM0j6Ufc//2oG4+58XgEr6tuBzamjwAb0yeYnuyg1+8O4Po9Cly/J5Ws353A9XsMuH5PMTdKT1TUgCcr/vxUxZ8fr6kNT7v/+xk3nnXjuQhqw13A2DwNjM3zSrR9N3D9ngGu3wtK1u8e4Po9C1y/F5lrw/MVNeCFij+/WPHn52pqw0vu/37ZjVfceDWC2nAvMDYvAWPzmhJt3wdcv5eB6/e6kvW7H7h+rwDX7w3m2vBaRQ14veLPb1T8+dWa2vCm+7/fcuNtN96JoDY8AIzNm8DYvMscm3crYvBWxZ/frvjzOzWxec/93++78YEbH3pig/a8H+HWoOxbg48quL5X8ecHJ/IA8GP3n33ixqdufNY8/jOsqP4uq4+BuuhTgfPz4CHTF1oeMnHh+5zhCf6X4GTufkBG845mjNUXDGvxFdNafNXM92uZXLqYeThvPoT9tUwuDcwyXH4d+Jjh7Qsw3ha5hv+VX1/6HFxbuq+vNb55qQTdS8yTPLZEmL9mKAyzggtD94X+9SXka9RvmmUWGGQsKnX5TTP/ry8h4/NtRXzC/qBFZdEO+4MWXPH5NogP/bmlabzj7k18JnHZvyY+X6xQtvGkWzmTyiWSxVQ8VoylTTGRLFsXtFg24UJWLiQyxUwsXo6lY4Vutzaq3z//7N7I6M+fV7i5L4I/f+f++b0bPzQ3VV21TxfCagf5xu074NOFH5uxzUNU32j+yLTB/9TMCPinZvy8PwPFwMX754rkAs070ce0YdcB+Xr3e2B8flGarL8wJeuvzYyAf2VI1t+EJyvx/i3iZDXhrqrd0IS7oMX0d/A7KQ63+TPDow3qvFBr+IeCNbxL+Br+CS6+rcE6/l7RTX9f8ec/msd/v3lHxf07K/78Z/Dv/OX++TfVm5Z/8HHE5wfh8ZmihSc+39WJD/3vTdHDf6eP+2dfN/oxxefnYL9BPz3q3yK/bvRvwfMewMwb8fqEeKPzEfmUpxm8hmiuVDOBGC3l+AAGLbYoyMEfGGpPq4Ic5ODdBtQkR97Qnv1XM1Y/LQx5064gb+5i0E+Hgrzh4N0pPG+ohwfWNEt1op0hb7qE79vUawM1bkk3XQzrOKWCPJySoYcEHga1Gw/Ferra7xXrncu7fSLfKw50azbIjcFuDGnp/c/GhY3bwApdxXLJYimRLhXjxuTce7t82r3fy+VsIp2Kudd57j1nslAu2FShmLE2Vcqn8iabN+VYKhEv5GL5bCXeqVoYAU/lEVpY8FMBi8DULbwPlBFrOLWnSIVdw6mBRYqSgJ5B9WmadBKYcJcdCC6utRdyTbqvoUGCDQv+OTz45zQUV7RgKLBU4bV8WzW84mlabZWmheuuxsMq/jy8pX6Vntb9Z9O5Mb0bM7Tw/qzE1MKfxMzI3NEhihsQo502mK8JGxOWbpZ+263yKbgJd6n4rbiZmIo3OrdHwHDGkxzaoZ9oAv5kjKWfB7qB46N84U9ipgnqBfyjfPAbqdp9cUTF/jdzxZ9nmci+OKv7z2ZzY3Y35mjh/emumYTvi3O28PQyNO+IYM1rv/dsYlrvWYXnGP3O5sxMezLXmnLsU/9nTwJ2CwBdZOcSLvzj+vL8jTNUXFqbJhQ/XSNbmvxOqvKvUKGr+89zNdX/K1TmdpPN48a8bszXwn9+fCRwrrmBj3XmZ+pa4esHdFLzANdvASXrh/wrVOYFrp9h7ibnr+gaF6j4s6n483wt1bXBuv875kbcjUTFs/C2pvF/fXLlhS6uwFixPgacomnSv+1gwl0WiZcL41wKMI7UgDGiJygm3GWt8HfJ9OQN2OX/zzFIf+rexBnw7gVFd/lxBb9vwME7IeT4tukBfxTnJDAhgbqxwFjYysdFyYrHRUOaonlcpKNxivHNbcefgPvfo9TgzykXi7QbGTeybizoxkJuLOzGIm4s6sZipE83lnBjSTeWcmNpN5ZxY1k3lnNjlBvLu7GCGyu6sZIbK7uxihururGaG6u7sYYba7qxlhtrd7v2bmEQmNp7ac+9jOde1nNvQc+9hTz3FvbcW8Rzb1HPvcU89xb33FvCc29Jz72lPPeW9txbxnNvWc+95Tz3RnnuLe+5t4Ln3oqeeyt57q3subeK596qnnuree6t7rm3hufemp57a3nurd3y7+Ghf6+Zg38uHvzThLuqik7YTSIFcNb//LUYxqZBcxHHDGSuf9YrG36uWPePBC0Ydq7E+B8cWijcXKbyx4sWDjNXrPqHkBaZ/LlM7Y8qLTqZc6XKE/5A02KTN1fG92NPi0/OXBn/D0ct0fu50vV+hGrJ3s6Vrv+DVkv1bq7YxH4ca+nezJWe+A9tLdPzuSb5Q3DL9nSu9CRroV2uZ3OZHtRVO6onc5ke1Wi7/KTnSvaw3tsVJjVXosd7h11xonMlyr3Yh+xKE5sr3as9za5cf65ML/dHu0qdubLlXu+1dlX/XGYy9m27mm8uM1k9gF19wrnsZPYTdo3auYqT3ZvYNavniofoc+xaFXPFyqF6Jrt2C/b1Y1Q/e7I2rNcr2kq867QwAqbJUR9KdoNfBxdAuy5gUTl/QoXWkDCinqh1r+G64CSg12h9mqJNAhPqKrI+Valci/WCBFu/1m2u1zL+a+/ue+t7HCj63S6ukhi7HjCB1gcHFy0+Spr1gMnYzXs9pTvSWjAdZYuVeDdoYQS8AXxHyhY3AO5IGwrfkWgNN4TvSNnihkp3pLVguLMFD1yWHWmjIME2rt2RNvLsSBtHsCOtBdyRNgIm0MZMwUUVoG6cSM6bAItZUxN+t1w3KEDoryCQVmBTYDHzraEJd1mK8aYMncymSjuZNWH1Jx+vxLtZCyPgzeCdTD6+GTD5c8I7GVrDHLyTycdzzMmPKKCbCi+gefAadl/ojRep8QIw96LsgNeE4c7HPHBZOuBiUJhLtR1w0dMBlyLogHE7kLFFoChLTMFFJyKSc5m5AzbhLkvFscDQvW0uvGuluGyugDeXxjcHanwL4Rqv16Qgmh/UXFuCN+yo3M4asL0mU67Eu1ULI+Ct4G4nU94KGMCthbsdWsOt4W4nU95auNuhQrdli+xivA24GHdfaM5IjW+r1O2sAcOdKXngsrid7YLCvH2t29nO43a2j8Dt4HYgY7cDinJ7puCiExHJeQfhnSAVx20Zuv4dhbsdisuOCnhzaXxHoMZ3Eq7xek2KCXdZZJOys9J3O6vD9ppY1V8Xt0sLI+Bd4G4nZnYBJsGuwt0OreGucLcTM7sKdztU6HZukV2Md1PidpAa312p21kdhtuWPXBZ3M4eQWHes9bt7OFxO3tG4HZwO5CxewBFuSdTcNGJiOS8l/BOkIrj7gxd/97C3Q7FZW8FvLk0vjdQ4/sI13i9JsWEuyyySdlXqdtZDbbXFKvczn4tjID3g7udotkPmAT7C3c7tIb7w91O0ewv3O1Qodu3RXYxHq3E7SA1foBSt7MaDHchMrdzYFCYD6p1Owd63M5BEbgd3A5k7IFAUR7EFFx0IiI5Hyy8E6TieABD13+IcLdDcTlEAW8ujR8C1PihwjVer0kx4S6LbFIOU+p2VoXtNamq38Q4vIUR8OFwt5OyhwOT4AjhbofW8Ai420lV8TYhLx9vRKE7rEV2MT5SidtBavwopW5nVRjuVGS/pXJ0UJiPqXU7R3vczjERuB3cDmTs0UBRHsMUXHQiIjkfK7wTpOJ4FEPXP0a426G4jFHAm0vjY4AaP064xus1KSbcZZFNyvFK3c4quHc7mUq8Y1sYAY/Fv9vJjAUmwTjhbofWcBz+3U5mnHC3Q4Xu+BbZxfgEJW4HqfETlbqdVWC4i2kPXBa3c1JQmE+udTsnedzOyRG4HdwOZOxJQFGezBRcdCIiOZ8ivBOk4ngiQ9d/qnC3Q3E5VQFvLo2fCtT4acI1Xq9JMeEui2xSTlfqdlaG7TWJbCXeM1oYAZ8BdzuJ7BnAJDhTuNuhNTwT7nYS2TOFux0qdKe3yC7GZylxO0iNn63U7awMw53IeOCyuJ1zgsJ8bq3bOcfjds6NwO3gdiBjzwGK8lym4KITEcn5POGdIBXHsxm6/vOFux2Ky/kKeHNp/Hygxi8QrvF6TYoJd1lkk3KhUrezEmyvyVd9yXZRCyPgi+BuJ28vAibBxcLdDq3hxXC3k6/ibUJePt6IQndhi+xifIkSt4PU+KVK3c5KMNz5yL5kuywozJfXup3LPG7n8gjcDm4HMvYyoCgvZwouOhGRnK8Q3glScbyUoeu/UrjbobhcqYA3l8avBGr8KuEar9ekmHCXRTYpVyt1Oyvi3E6hEu81LYyAr8G7ncI1wCS4VrjboTW8Fu92CtcKdztU6K5ukV2Mr1PidpAav16p21kR1xDnPXBZ3M4NQWG+sdbt3OBxOzdG4HZwO5CxNwBFeSNTcNGJiOR8k/BOkIrj9Qxd/83C3Q7F5WYFvLk0fjNQ47cI13i9JsWEuyyySblVqdtZAfclW74S720tjIBvw3/Jlr8NmAS3C3c7tIa3479ky98u3O1Qobu1RXYxvkOJ20Fq/E6lbmcF3MdOOQ9cFrdzV1CY7651O3d53M7dEbgd3A5k7F1AUd7NFFx0IiI53yO8E6TieCdD13+vcLdDcblXAW8ujd8L1Ph9wjVer0kx4S6LbFLuV+p2loftNZmqX6B+oIUR8ANwt5MxDwCT4EHhbofW8EG428mYB4W7HSp097fILsYPKXE7SI0/rNTtLA/DnY7sF6gfCQrzo7Vu5xGP23k0AreD24GMfQQoykeZgotORCTnx4R3glQcH2bo+h8X7nYoLo8r4M2l8ceBGn9CuMbrNSkm3GWRTcqTSt3OKCa381QLI+CnGNzOU8AkeFq426E1fJrB7Twt3O1QoXuyRXYxfkaJ20Fq/FmlbmeUQrfzXFCYn691O8953M7zEbgd3A5k7HNAUT6vxO0gOb8gvBOk4vgsQ9f/onC3Q3F5UQFvLo2/CNT4S8I1Xq9JMeEui2xSXlbqdpaD7TW5qt9ke6WFEfArcLeTy74CTIJXhbsdWsNX4W4nl31VuNuhQvdyi+xi/JoSt4PU+OtK3c5yMNy5yH6T7Y2gML9Z63be8LidNyNwO7gdyNg3gKJ8kym46EREcn5LeCdIxfF1hq7/beFuh+LytgLeXBp/G6jxd4RrvF6TYsJdFtmkvKvU7SyLczuJSrzvtTACfg/vdhLvAZPgfeFuh9bwfbzbSbwv3O1QoXu3RXYx/kCJ20Fq/EOlbmdZXEMc98BlcTsfBYX541q385HH7XwcgdvB7UDGfgQU5cdMwUUnIpLzJ8I7QSqOHzJ0/Z8KdzsUl08V8ObS+KdAjX8mXOP1mhQT7rLIJuVzpW5nGdheU6x6t/NFCyPgL+Bup5j9ApgEXwp3O7SGX8LdTjH7pXC3Q4Xu8xbZxfgrJW4HqfGvlbqdZWC4i5G92/kmKMzf1rqdbzxu59sI3A5uBzL2G6Aov2UKLjoRkZy/E94JUnH8mqHr/16426G4fK+AN5fGvwdq/AfhGq/XpJhwl0U2KT8qdTtLw/aaQqkS708tjIB/grudQuknYBL8LNzt0Br+DHc7hdLPwt0OFbofW2QX41+UuB2kxn9V6naWhuEuFD1wWdzOb0Fh/r3W7fzmcTu/R+B2cDuQsb8BRfk7U3DRiYjk/IfwTpCK468MXf+fwt0OxeVPBby5NP4nUON/Cdd4vSbFhLssskn5W6nbWQq219iqdztNrYyAaXKs27FZmhOFcYpW2W6H1pAwYt2OE0Ar76aBKHR/t8guxn1ascW4+0JzRmq8L5BzlG5nKVjRt5G92+kXFOb+rU3VzqZf64Ruh/4lbrezFNDt9AOKsn8rT3DRiYjkPABcfNAJR8Wxbyt+Y2hm3rhMuMtSXJoV8ObSeDNQ4y3CNV6vSTHhLotsUlqBuonS7SwJ22vyVW6nrZURcBvc7eSzbcAkaBfudmgN2+FuJ59tF+52qNC1tsouxh1K3A5S451K3c6SMLeTj8ztdAWFecpat9PlcTtTRuB2lgS6nS6gKKds5QkuOhGRnAcK7wSpOHYydP2DhLsdissgBby5ND4IqPHBwjVer0kx4S6LbFKGKHU7S8D2mkymEu9UrYyAp4K7nUxmKmASTC3c7dAaTg13O5nM1MLdDhW6Ia2yi/FQJW4HqfFhSt3OEjC3k0l74LK4neFBYZ6m1u0M97idaSJwO0sA3c5woCinaeUJLjoRkZynFd4JUnEcxtD1Tyfc7VBcplPAm0vj0wE1Pr1wjddrUky4yyKblBmUup3FYXtNosrtzNjKCHhGuNtJZGYEJsFMwt0OreFMcLeTyMwk3O1QoZuhVXYxHqHE7SA1PrNSt7M4zO0kInM7swSFedZatzOLx+3MGoHbWRzodmYBinLWVp7gohMRyXk24Z0gFceZGbr+2YW7HYrL7Ap4c2l8dqDG5xCu8XpNigl3WWSTMqdSt7MYbK/J2kq8c7UyAp4L7naydi5gEowU7nZoDUfC3U62ircJefl4IwrdnK2yi/HcStwOUuPzKHU7i8HcTtZ44LK4nXmDwjxfrduZ1+N25ovA7SwGdDvzAkU5XytPcNGJiOQ8v/BOkIrjPAxd/wLC3Q7FZQEFvLk0vgBQ40a4xus1KSbcZZFNilXqdhaF7TVpU4k31soIOAZ3O2kTAyZBXLjboTWMw91O2sSFux0qdLZVdjFOKHE7SI0nlbqdRWFuJ1X2wGVxO6mgMKdr3U7K43bSEbidRYFuJwUUZbqVJ7joRERyzgjvBKk4Jhm6/qxwt0NxySrgzaXxLFDjCwrXeL0mxYS7LLJJWUip21kE9ysFVb9AvXArI+CF4W4nX1oYmASLCHc7tIaLwN1OvrSIcLdDhW6hVtnFeFElbgep8cWUup1FcL9SENkvUC8eFOYlat3O4h63s0QEbmcRoNtZHCjKJVp5gotORCTnJYV3glQcF2Po+pcS7nYoLksp4M2l8aWAGl9auMbrNSkm3GWRTcoySt3OwrC9Jlb1bmfZVkbAy8LdTswsC0yC5YS7HVrD5eBuJ2aWE+52qNAt0yq7GI9S4naQGl9eqdtZGPcL1JG921khKMwr1rqdFTxuZ8UI3M7CQLezAlCUK7byBBediEjOKwnvBKk4Ls/Q9a8s3O1QXFZWwJtL4ysDNb6KcI3Xa1JMuMsim5RVlbqdhXB7TaES72qtjIBXg7sdU1gNmASrC3c7tIarw92OKawu3O1QoVu1VXYxXkOJ20FqfE2lbmch3F+ylvfAZXE7awWFee1at7OWx+2sHYHbAe5Adi2gKNdu5QkuOhGRnNcR3glScVyToetfV7jbobisq4A3l8bXBWp8PeEar9ekmHCXRTYp6yt1OwvC9ppU1ZdsG7QyAt4A7nZSpQ2ASbChcLdDa7gh3O2kShsKdztU6NZvlV2MN1LidpAa31ip21kQd24nsi/ZNgkK86a1bmcTj9vZNAK3syDQ7WwCFOWmrTzBRScikvNmwjtBKo4bM3T9OeFuh+KSU8CbS+M5oMbzwjVer0kx4S6LbFIKSt1OFrbX2KrfZCu2MgIuwt2OtUVgEpSEux1awxLc7dgq3ibk5eONKHSFVtnFuKzE7SA1vrlSt5PFfckW2W+ybREU5i1r3c4WHrezZQRuJwt0O1sARbllK09w0YmI5LyV8E6QiuPmDF3/1sLdDsVlawW8uTS+NVDj2wjXeL0mxYS7LLJJ2Vap28ngPsaoOrezXSsj4O1a8fNuL9yhEO/tW8cvMGheFldBBWXbVtlFbwclrgKpyx2ZCz0iJjsyaDzKgppmKqg7tTIC3omhoO4svKAS750bBRU21y5KCipSl7sKL6gUk12VF9RUC249KvHu1soIeDeGZN0NKLbdhRdnWsPdGez97sKfx2so9HsoKfRIje8p/BEJxWRPhnzZS/hjQKoTezE1cVy63Auoy72F67JePTPhLousZ/sI1zjFeB8Gg4bUITWEQ5rGvwqrvNC4gXPxvWM0Mdb3l1NUrO2I4M/7unju58b+box24wA3DnTjIDcOduMQNw514zA3DnfjCDeOdOMoN4524xg3jnVjjBvHuXG8G2PdGOfGCW6c6MZJbpzsxilunOrGaW6c7sYZte9O9w3ek1be289zb3/PvdGeewd47h3ouXeQ597BnnuHeO4d6rl3mOfe4Z57R3juHem5d5Tn3tGee8d47h3ruTfGc+84z73jPffGeu6N89w7wXPvRM+9kzz3TvbcO8Vz71TPvdM890733DujdcJ38jMH/1w8+KcJd1UVnbDFcl9A4e1+v78faC7iuD9krn/Wa3T4uWLBetkDws6V+Hft7YHh5jIVcbQHhZkrVqUJe/Dkz2Vq9GUPmcy5UuUJtGoPnby5Mh7d28MmZ66MN4fs4b2fK10nH+0RvZ0rXTe37ZG9mys2kTphj+rNXOmJ1hx7dM/nKkyiftljejpXepK10B7bs7lMD+qqHdOTuUyParQ9btJzJTM9q/f2+EnNlejx3mHHTnSuRLkX+5AdN7G50r3a0+wJ9efK9HJ/tCfWmStb7vVea0/yz2UmY9+2J/vmMpPVA9hTJpzLTmY/YU+tnas42b2JPa16rniIPseeXjFXrByqZ7JnAE16lG8vzoD1esWq0wRntjICPrMVfZqgaM/EBdCeBVhUzrcXtIZnAZ/Gdq/hWeAkiOqrcFzyFiP7KvzsIMHOqX2ycXbrhF+Fn9PK/1U4rpIYezYwgc4BBxctPkqas4HJ2M37bKU70ukwHWWLlXjPbWUEfC58R8oWzwXuSOcJ35FoDc+D70jZ4nlKd6TTYbizBQ9clh3p/CDBLqjdkc737EgXRLAjnQ7ckc4HJtAFTMFFvwhGcr4QWMyamvC75VlBAUK/CEZagYuAxcy3hibcZSnGFzF0Mhcp7WROg9WffLwS78WtjIAvhncy+fjFwOS/RHgnQ2t4CbyTyccvYU5+RAG9SHgBvRS8ht0XeuNFavwyYO5F2QGfBsOdj3ngsnTAlweF+YraDvhyTwd8RQQdMG4HMvZyoCivYAouOhGRnK9k7oBNuMtScbyMoXu7SnjXSnG5SgFvLo1fBdT41cI1Xq9JQTQ/qLmuAW/YUbmdU2F7TaZciffaVkbA18LdTqZ8LTCA1wl3O7SG18HdTqZ8nXC3Q4XumlbZxfh6cDHuvtCckRq/QanbORWGO1PywGVxOzcGhfmmWrdzo8ft3BSB28HtQMbeCBTlTUzBRScikvPNwjtBKo43MHT9twh3OxSXWxTw5tL4LUCN3ypc4/WaFBPussgm5Tal73ZOge01sapffbi9lRHw7XC3EzO3A5PgDuFuh9bwDrjbiZk7hLsdKnS3tcouxncqcTtIjd+l1O2cAsNd/VfONyFx1ridu4PCfE+t27nb43buicDt4HYgY+8GivIepuCiExHJ+V7hnSAVx7sYuv77hLsdist9Cnhzafw+oMbvF67xek2KCXdZZJPygFK3czJsrylWuZ0HWxkBPwh3O0XzIDAJHhLudmgNH4K7naJ5SLjboUL3QKvsYvywEreD1PgjSt3OyTDchcjczqNBYX6s1u086nE7j0XgdnA7kLGPAkX5GFNw0YmI5Py48E6QiuMjDF3/E8LdDsXlCQW8uTT+BFDjTwrXeL0mxYS7LLJJeUqp2zkJttekqn4T4+lWRsBPw91Oyj4NTIJnhLsdWsNn4G4nVcXbhLx8vBGF7qlW2cX4WSVuB6nx55S6nZNguFOR/ZbK80FhfqHW7TzvcTsvROB2cDuQsc8DRfkCU3DRiYjk/KLwTpCK43MMXf9Lwt0OxeUlBby5NP4SUOMvC9d4vSbFhLssskl5RanbORH3bidTiffVVkbAr+Lf7WReBSbBa8LdDq3ha/h3O5nXhLsdKnSvtMouxq8rcTtIjb+h1O2cCMNdTHvgsridN4PC/Fat23nT43beisDt4HYgY98EivItpuCiExHJ+W3hnSAVxzcYuv53hLsdiss7CnhzafwdoMbfFa7xek2KCXdZZJPynlK3cwJsr0lkK/G+38oI+H2420lk3wcmwQfC3Q6t4Qdwt5PIfiDc7VChe69VdjH+UInbQWr8I6Vu5wQY7kTGA5fF7XwcFOZPat3Oxx6380kEbge3Axn7MVCUnzAFF52ISM6fCu8EqTh+xND1fybc7VBcPlPAm0vjnwE1/rlwjddrUky4yyKblC+Uup1xsL0mX/Ul25etjIC/hLudvP0SmARfCXc7tIZfwd1Ovoq3CXn5eCMK3Retsovx10rcDlLj3yh1O+NguPORfcn2bVCYv6t1O9963M53Ebgd3A5k7LdAUX7HFFx0IiI5fy+8E6Ti+A1D1/+DcLdDcflBAW8ujf8A1PiPwjVer0kx4S6LbFJ+Uup2xuLcTqES78+tjIB/xrudws/AJPhFuNuhNfwF73YKvwh3O1TofmqVXYx/VeJ2kBr/TanbGYtriPMeuCxu5/egMP9R63Z+97idPyJwO7gdyNjfgaL8gym46EREcv5TeCdIxfE3hq7/L+Fuh+LylwLeXBr/C6jxv4VrvF6TYsJdFtmkNLXpdDvH475ky1finaKNETBNjnU7DjwugLZPm2y3Q2tIGMFfsuX7tPFuGohC19Qmuxj3bcMW4+4LzRmp8X5AzlG6neNxHzvlPHBZ3E7/oDAPaGuqdjb92yZ0O/Qvcbud44Fupz9QlAPaeIKLTkQk52Zw8UEnHBXHfm34jaGFeeMy4S5LcWlRwJtL4y1AjbcK13i9JsWEuyyySWlT6naOg+01mapfoG5vYwTcDnc7GdMOTIIO4W6H1rAD7nYypkO426FC19Ymuxh3KnE7SI13KXU7x8HcTjqyX6CeMijMA2vdzpQetzMwArdzHNDtTAkU5cA2nuCiExHJeZDwTpCKYxdD1z9YuNuhuAxWwJtL44OBGh8iXOP1mhQT7rLIJmUqpW5nDJPbmbqNEfDUDG5namASDBXudmgNhzK4naHC3Q4VuqnaZBfjYUrcDlLjw5W6nTEK3c40QWGettbtTONxO9NG4HbGAN3ONEBRTqvE7SA5Tye8E6TiOJyh659euNuhuEyvgDeXxqcHanwG4Rqv16SYcJdFNikzKnU7x8L2mlzVb7LN1MYIeCa428llZwImwQjhbofWcATc7eSyI4S7HSp0M7bJLsYzK3E7SI3PotTtHAtzO7nIfpNt1qAwz1brdmb1uJ3ZInA7xwLdzqxAUc7WxhNcdCIiOc8uvBOk4jgLQ9c/h3C3Q3GZQwFvLo3PAdT4nMI1Xq9JMeEui2xS5lLqdo7BuZ1EJd6RbYyAR+LdTmIkMAnmFu52aA3nxrudxNzC3Q4VurnaZBfjeZS4HaTG51Xqdo7BuZ24By6L25kvKMzz17qd+TxuZ/4I3M4xQLczH1CU87fxBBediEjOCwjvBKk4zsvQ9RvhbofiYhTw5tK4AWrcCtd4vSbFhLssskmJKXU7R8P2mmLVu514GyPgONztFLNxYBIkhLsdWsME3O0UswnhbocKXaxNdjFOKnE7SI2nlLqdo2FupxjZu510UJgztW4n7XE7mQjcztFAt5MGijLTxhNcdCIiOWeFd4JUHFMMXf+Cwt0OxWVBBby5NL4gUOMLCdd4vSbFhLsssklZWKnbOQq21xRKlXgXaWMEvAjc7RRKiwCTYFHhbofWcFG42ymUFhXudqjQLdwmuxgvpsTtIDW+uFK3cxTM7RSKHrgsbmeJoDAvWet2lvC4nSUjcDtHAd3OEkBRLtnGE1x0IiI5LyW8E/xfcWTo+pcW7nYoLksr4M2l8aWBGl9GuMbrNSkm3GWRTcqySt3OkbC9xla921mujRHwcnC3Y7PLAZNglHC3Q2s4Cu52bHaUcLdDhW7ZNtnFeHklbgep8RWUup0jYW7HRvZuZ8WgMK9U63ZW9LidlSJwO0cC3c6KQFGu1MYTXHQiIjmvLLwTpOK4AkPXv4pwt0NxWUUBby6NrwLU+KrCNV6vSTHhLotsUlZT6naOwP3tolVuZ/U2RsCrw91OPrs6MAnWEO52aA3XgLudfHYN4W6HCt1qbbKL8ZpK3A5S42spdTtH4P4CysjcztpBYV6n1u2s7XE760Tgdo4Aup21gaJcp40nuOhERHJeV3gnSMVxLYaufz3hbofisp4C3lwaXw+o8fWFa7xek2LCXRbZpGyg1O0cjvsF6kwl3g3bGAFvCHc7mcyGwCTYSLjboTXcCO52MpmNhLsdKnQbtMkuxhsrcTtIjW+i1O0cDnM7mbQHLovb2TQozJvVup1NPW5nswjczuFAt7MpUJSbtfEEF52ISM454Z0gFcdNGLr+vHC3Q3HJK+DNpfE8UOMF4Rqv16SYcJdFNilFpW7nMNhek6hyO6U2RsAluNtJZErAJCgLdzu0hmW420lkysLdDhW6YpvsYry5EreD1PgWSt3OYTC3k4jM7WwZFOatat3Olh63s1UEbucwoNvZEijKrdp4gotORCTnrYV3glQct2Do+rcR7nYoLtso4M2l8W2AGt9WuMbrNSkm3GWRTcp2St3OobC9Jmsr8W7fxgh4e7jbydrtgUmwg3C3Q2u4A9ztZKt4m5CXjzei0G3XJrsY76jE7SA1vpNSt3MozO1kjQcui9vZOSjMu9S6nZ09bmeXCNzOoUC3szNQlLu08QQXnYhIzrsK7wSpOO7E0PXvJtztUFx2U8CbS+O7ATW+u3CN12tSTLjLIpuUPZS6nUNge03aVOLds40R8J5wt5M2ewKTYC/hbofWcC+420mbvYS7HSp0e7TJLsZ7K3E7SI3vo9TtHAJzO6myBy6L29k3KMz71bqdfT1uZ78I3M4hQLezL1CU+7XxBBediEjO+wvvBKk47sPQ9Y8W7nYoLqMV8ObS+Gigxg8QrvF6TYoJd1lkk3KgUrdzMO5XCqp+gfqgNkbAB8HdTr50EDAJDhbudmgND4a7nXzpYOFuhwrdgW2yi/EhStwOUuOHKnU7B+N+pSCyX6A+LCjMh9e6ncM8bufwCNzOwUC3cxhQlIe38QQXnYhIzkcI7wSpOB7K0PUfKdztUFyOVMCbS+NHAjV+lHCN12tSTLjLIpuUo5W6nYNge02s6t3OMW2MgI+Bu52YOQaYBMcKdzu0hsfC3U7MHCvc7VChO7pNdjEeo8TtIDV+nFK3cxDuF6gje7dzfFCYx9a6neM9bmdsBG7nIKDbOR4oyrFtPMFFJyKS8zjhnSAVx+MYuv4ThLsdissJCnhzafwEoMZPFK7xek2KCXdZZJNyklK3cyBurylU4j25jRHwyXC3YwonA5PgFOFuh9bwFLjbMYVThLsdKnQntckuxqcqcTtIjZ+m1O0cCHM7Ju+By+J2Tg8K8xm1bud0j9s5IwK3A9yB7OlAUZ7RxhNcdCIiOZ8pvBOk4ngaQ9d/lnC3Q3E5SwFvLo2fBdT42cI1Xq9JMeEui2xSzlHqdg6A7TWpqi/Zzm1jBHwu3O2kSucCk+A84W6H1vA8uNtJlc4T7nao0J3TJrsYn6/E7SA1foFSt3MA7txOZF+yXRgU5otq3c6FHrdzUQRu5wCg27kQKMqL2niCi05EJOeLhXeCVBwvYOj6LxHudigulyjgzaXxS4Aav1S4xus1KSbcZZFNymVK3c5o2F5jq36T7fI2RsCXw92OtZcDk+AK4W6H1vAKuNuxVbxNyMvHG1HoLmuTXYyvVOJ2kBq/SqnbGY37ki2y32S7OijM19S6nas9bueaCNzOaKDbuRooymvaeIKLTkQk52uFd4JUHK9i6PqvE+52KC7XKeDNpfHrgBq/XrjG6zUpJtxlkU3KDUrdzv64jzGqzu3c2MYI+MY2/Lw3CXcoxPumtvELDJqXxVVQQbmhTXbRu1mJq0Dq8hbmQo+IyS0MGo+yoO7HVFBvbWMEfCtDQb1NeEEl3rc1CipsrtuVFFSkLu8QXlApJncoL6j7tuLWoxLvnW2MgO9kSNY7gWK7S3hxpjW8i8He3yX8ebyGQn+3kkKP1Pg9wh+RUEzuYciXe4U/BqQ6cS9TE8ely3uBurxPuC7r1TMT7rLIena/cI1TjO9nMGhIHVJDOKRp/KuwyguNe64mnjxvguKMsb6/nKJibUcEf37AxfNBNx5y42E3HnHjUTcec+NxN55w40k3nnLjaTeeceNZN55z43k3XnDjRTdecuNlN15x41U3XnPjdTfecONNN95y42033nHjXTfec+P92nenDwTvSSvvPei595Dn3sOee4947j3qufeY597jnntPeO496bn3lOfe0557z3juPeu595zn3vOeey947r3oufeS597LnnuveO696rn3mufe6557b3juvem595bn3tuee+947r3rufee5977bRO+k585+OfiwT9NuKuq6IQtlg8ACm/3+/0HQXMRx4cgc/2zXg+HnysWrJd9JOxciX/X3j4abi5TEUf7WJi5YlWasI9P/lymRl/2icmcK1WeQKv2ycmbK+PRvX1qcubKeHPIPt37udJ18tE+09u50nVz2z7bu7liE6kT9rnezJWeaM2xz/d8rsIk6pd9oadzpSdZC+2LPZvL9KCu2pd6MpfpUY22L096rmQP6719ZVJzJXq8d9hXJzpXotyLfci+NrG50r3a0+zr9efK9HJ/tG/UmStb7vVea9/0z2UmY9+2b/nmMpPVA9i3J5zLTmY/Yd+pnas42b2Jfbd6rniIPse+VzFXrByqZ7LvA016lG8v3of1esWq0wQftDEC/qANfZqgaD/ABdB+CFhUzrcXtIYfAp/Gdq/hh+AkiOqrcFzyFiP7KvyjIME+rn2y8VHbhF+Ff9zG/1U4rpIY+xEwgT4GBxctPkqaj4DJ2M37I6U70nswHWWLlXg/aWME/Al8R8oWPwHuSJ8K35FoDT+F70jZ4qdKd6T3YLizBQ9clh3psyDBPq/dkT7z7EifR7AjvQfckT4DJtDnTMFFvwhGcv4CWMyamvC75YdBAUK/CEZagS+Bxcy3hibcZSnGXzJ0Ml8q7WTehdWffLwS71dtjIC/gncy+fhXwOT/WngnQ2v4NbyTyce/Zk5+RAH9UngB/Qa8ht0XeuNFavxbYO5F2QG/C8Odj3ngsnTA3wWF+fvaDvg7Twf8fQQdMG4HMvY7oCi/ZwouOhGRnH9g7oBNuMtScfyWoXv7UXjXSnH5UQFvLo3/CNT4T8I1Xq9JQTQ/qLl+Bm/YUbmdd2B7TaZcifeXNkbAv8DdTqb8CzCAvwp3O7SGv8LdTqb8q3C3Q4Xu5zbZxfg3cDHuvtCckRr/XanbeQeGO1PywGVxO38EhfnPWrfzh8ft/BmB28HtQMb+ARTln0zBRScikvNfwjtBKo6/M3T9fwt3OxSXvxXw5tL438iGql22xus1KSbcZZFNyhS4NYz03c7bsL0mVvWrD33aGQHT5Fi3EzN9gEnQt12226E1JIxYtxMzfdt5Nw1EoZuiXXYx7gcuxv8mJJgzUuP9gZyjdDtvw5qF6r9yvgmJs8btDAgKc3N7U7WzGdA+oduhf4nb7bwNdDsDgKJsbucJLjoRkZxbhHeCVBz7t+M3hlbmjcuEuyzFpVUBby6NtwI13iZc4/WaFBPussgmpV2p23kLd0qsyu10tDMC7oC7naLpACZBp3C3Q2vYCXc7RdMp3O1QoWtvl12Mu5S4HaTGp1Tqdt6CuZ1CZG5nYFCYB9W6nYEetzMoArfzFtDtDASKclA7T3DRiYjkPFh4J0jFcUqGrn+IcLdDcRmigDeXxocANT6VcI3Xa1JMuMsim5SplbqdN2F7TarqNzGGtjMCHgp3Oyk7FJgEw4S7HVrDYXC3k6ribUJePt6IQjd1u+xiPFyJ20FqfBqlbudNmNtJRfZbKtMGhXm6WrczrcftTBeB23kT6HamBYpyunae4KITEcl5euGdIBXHaRi6/hmEux2KywwKeHNpfAagxmcUrvF6TYoJd1lkkzKTUrfzBu7dTqYS74h2RsAj8O92MiOASTCzcLdDazgz/t1OZmbhbocK3UztsovxLErcDlLjsyp1O2/gflww7YHL4nZmCwrz7LVuZzaP25k9ArfzBtDtzAYU5eztPMFFJyKS8xzCO0EqjrMydP1zCnc7FJc5FfDm0vicQI3PJVzj9ZoUE+6yyCZlpFK38zpsr0lkK/HO3c4IeG6420lk5wYmwTzC3Q6t4Txwt5PIziPc7VChG9kuuxjPq8TtIDU+n1K38zrM7SQyHrgsbmf+oDAvUOt25ve4nQUicDuvA93O/EBRLtDOE1x0IiI5G+GdIBXH+Ri6fivc7VBcrALeXBq3QI3HhGu8XpNiwl0W2aTElbqd13C/QF31JVuinRFwAu528jYBTIKkcLdDa5iEu518FW8T8vLxRhS6eLvsYpxS4naQGk8rdTuv4X6kOLIv2TJBYc7Wup2Mx+1kI3A7rwHdTgYoymw7T3DRiYjkvKDwTpCKY5qh619IuNuhuCykgDeXxhcCanxh4Rqv16SYcJdFNimLKHU7r+LcTqES76LtjIAXxbudwqLAJFhMuNuhNVwM73YKiwl3O1ToFmmXXYwXV+J2kBpfQqnbeRXndvIeuCxuZ8mgMC9V63aW9LidpSJwO68C3c6SQFEu1c4TXHQiIjkvLbwTpOK4BEPXv4xwt0NxWUYBby6NLwPU+LLCNV6vSTHhLotsUpZT6nZewX3Jlq/EO6qdEfAo/Jds+VHAJFheuNuhNVwe/yVbfnnhbocK3XLtsovxCkrcDlLjKyp1O6/gvmTLeeCyuJ2VgsK8cq3bWcnjdlaOwO28AnQ7KwFFuXI7T3DRiYjkvIrwTpCK44oMXf+qwt0OxWVVBby5NL4qUOOrCdd4vSbFhLsssklZXanbeRn3t4tW/QL1Gu2MgNeAu52MWQOYBGsKdzu0hmvC3U7GrCnc7VChW71ddjFeS4nbQWp8baVu52WY20lH9gvU6wSFed1at7OOx+2sG4HbeRnodtYBinLddp7gohMRyXk94Z0gFce1Gbr+9YW7HYrL+gp4c2l8faDGNxCu8XpNigl3WWSTsqFSt/MSk9vZqJ0R8EYMbmcjYBJsLNzt0BpuzOB2NhbudqjQbdguuxhvosTtIDW+qVK385JCt7NZUJhztW5nM4/byUXgdl4Cup3NgKLMKXE7SM554Z0gFcdNGbr+gnC3Q3EpKODNpfECUONF4Rqv16SYcJdFNiklpW7nRdhek6v6TbZyOyPgMtzt5LJlYBJsLtzt0BpuDnc7uezmwt0OFbpSu+xivIUSt4PU+JZK3c6LMLeTi+w32bYKCvPWtW5nK4/b2ToCt/Mi0O1sBRTl1u08wUUnIpLzNsI7QSqOWzJ0/dsKdzsUl20V8ObS+LZAjW8nXOP1mhQT7rLIJmV7pW7nBZzbSVTi3aGdEfAOeLeT2AGYBDsKdzu0hjvi3U5iR+Fuhwrd9u2yi/FOStwOUuM7K3U7L+DcTtwDl8Xt7BIU5l1r3c4uHrezawRu5wWg29kFKMpd23mCi05EJOfdhHeCVBx3Zuj6dxfudiguuyvgzaXx3YEa30O4xus1KSbcZZFNyp5K3c7zuL9dtOrdzl7tjID3grudYnYvYBLsLdzt0BruDXc7xezewt0OFbo922UX432UuB2kxvdV6naex/3topG929kvKMz717qd/TxuZ/8I3M7zQLezH1CU+7fzBBediEjOo4V3glQc92Xo+g8Q7nYoLgco4M2l8QOAGj9QuMbrNSkm3GWRTcpBSt3Oc7C9plCqxHtwOyPgg+Fup1A6GJgEhwh3O7SGh8DdTqF0iHC3Q4XuoHbZxfhQJW4HqfHDlLqd52Bup1D0wGVxO4cHhfmIWrdzuMftHBGB23kO6HYOB4ryiHae4KITEcn5SOGdIBXHwxi6/qOEux2Ky1EKeHNp/Cigxo8WrvF6TYoJd1lkk3KMUrfzLGyvsVXvdo5tZwR8LNzt2OyxwCQYI9zt0BqOgbsdmx0j3O1QoTumXXYxPk6J20Fq/HilbudZmNuxkb3bGRsU5nG1bmesx+2Mi8DtPAt0O2OBohzXzhNcdCIiOZ8gvBOk4ng8Q9d/onC3Q3E5UQFvLo2fCNT4ScI1Xq9JMeEui2xSTlbqdp7B/e2iVW7nlHZGwKfA3U4+ewowCU4V7nZoDU+Fu5189lThbocK3cntsovxaUrcDlLjpyt1O8/g/nbRyNzOGUFhPrPW7ZzhcTtnRuB2ngG6nTOAojyznSe46EREcj5LeCdIxfF0hq7/bOFuh+JytgLeXBo/G6jxc4RrvF6TYsJdFtmknKvU7TyN+wXqTCXe89oZAZ8HdzuZzHnAJDhfuNuhNTwf7nYymfOFux0qdOe2yy7GFyhxO0iNX6jU7TwNczuZtAcui9u5KCjMF9e6nYs8bufiCNzO00C3cxFQlBe38wQXnYhIzpcI7wSpOF7I0PVfKtztUFwuVcCbS+OXAjV+mXCN12tSTLjLIpuUy5W6nadge02iyu1c0c4I+Aq420lkrgAmwZXC3Q6t4ZVwt5PIXCnc7VChu7xddjG+SonbQWr8aqVu5ymY20lE5nauCQrztbVu5xqP27k2ArfzFNDtXAMU5bXtPMFFJyKS83XCO0EqjlczdP3XC3c7FJfrFfDm0vj1QI3fIFzj9ZoUE+6yyCblRqVu50nYXpO1lXhvamcEfBPc7WTtTcAkuFm426E1vBnudrJVvE3Iy8cbUehubJddjG9R4naQGr9Vqdt5EuZ2ssYDl8Xt3BYU5ttr3c5tHrdzewRu50mg27kNKMrb23mCi05EJOc7hHeCVBxvZej67xTudigudyrgzaXxO4Eav0u4xus1KSbcZZFNyt1K3c4TsL0mbSrx3tPOCPgeuNtJm3uASXCvcLdDa3gv3O2kzb3C3Q4VurvbZRfj+5S4HaTG71fqdp6AuZ1U2QOXxe08EBTmB2vdzgMet/NgBG7nCaDbeQAoygfbeYKLTkQk54eEd4JUHO9n6PofFu52KC4PK+DNpfGHgRp/RLjG6zUpJtxlkU3Ko0rdzuO4Xymo+gXqx9oZAT8Gdzv50mPAJHhcuNuhNXwc7nbypceFux0qdI+2yy7GTyhxO0iNP6nU7TyO+5WCyH6B+qmgMD9d63ae8ridpyNwO48D3c5TQFE+3c4TXHQiIjk/I7wTpOL4JEPX/6xwt0NxeVYBby6NPwvU+HPCNV6vSTHhLotsUp5X6nYeg+01sap3Oy+0MwJ+Ae52YuYFYBK8KNzt0Bq+CHc7MfOicLdDhe75dtnF+CUlbgep8ZeVup3HcL9AHdm7nVeCwvxqrdt5xeN2Xo3A7TwGdDuvAEX5ajtPcNGJiOT8mvBOkIrjywxd/+vC3Q7F5XUFvLk0/jpQ428I13i9JsWEuyyySXlTqdt5FLfXFCrxvtXOCPgtuNsxhbeASfC2cLdDa/g23O2YwtvC3Q4VujfbZRfjd5S4HaTG31Xqdh6FuR2T98BlcTvvBYX5/Vq3857H7bwfgdsB7kD2PaAo32/nCS46EZGcPxDeCVJxfJeh6/9QuNuhuHyogDeXxj8Eavwj4Rqv16SYcJdFNikfK3U7j8D2mlTVl2yftDMC/gTudlKlT4BJ8Klwt0Nr+Cnc7aRKnwp3O1ToPm6XXYw/U+J2kBr/XKnbeQR3bieyL9m+CArzl7Vu5wuP2/kyArfzCNDtfAEU5ZftPMFFJyKS81fCO0Eqjp8zdP1fC3c7FJevFfDm0vjXQI1/I1zj9ZoUE+6yyCblW6Vu52HYXmOrfpPtu3ZGwN/B3Y613wGT4HvhbofW8Hu427FVvE3Iy8cbUei+bZddjH9Q4naQGv9Rqdt5GPclW2S/yfZTUJh/rnU7P3nczs8RuJ2HgW7nJ6Aof27nCS46EZGcfxHeCVJx/JGh6/9VuNuhuPyqgDeXxn8Favw34Rqv16SYcJdFNim/K3U7D+E+xqg6t/NHOyPgP9rx8/4p3KEQ7z/bxy8waF4WV0EF5fd22UXvLyWuAqnLv5kLPSImfzNoPMqC+iBTQW3qYARMk6PnnaJDdkEl3lN0NMHF5sP6f6Gg9unQUVCRuuzbIbugUkz6Mmg8yoL6QBsw9hU4+3UwAqbJ0cLtBxRbf+HFmdawfwc+Ifp3NAp92LkGKCn0SI03Mxd6E+6yFJNmhnxpYc4XE+76X51oYWriuHTZAtRlq3Bd1qtnJtxlkfWsTbjGKcZtDAYNqUNqCIc0jX8VVnmhcY9s4snzJijOGOv7yykq1nZE8Od2F88ONzrd6HJjSjcGujHIjcFuDHFjKjemdmOoG8PcGO7GNG5M68Z0bkzvxgxuzOjGTG6McGNmN2ZxY1Y3ZnNjdjfmcGNON+ZyY6Qbc3c0Vb8nJTAtNfc6PPc6Pfe6PPem9Nwb6Lk3yHNvsOfeEM+9qTz3pvbcG+q5N8xzb7jn3jSee9N67k3nuTe9594Mnnszeu7N5Lk3wnNvZs+9WTz3ZvXcm81zb3bPvTk89+b03JvLc2+k597cHRO+k585+OfiwT9NuKuq6IQtlu2Awtv9fr8DNBdx7ITM9c96dYWfKxasl50y7FyJf9feDgw3l6mIox0UZq5YlSbs4Mmfy9Toyw6ZzLlS5Qm0aqeavLkyHt3bqSdnrow3h+zQ3s+VrpOPdlhv50rXzW07vHdzxSZSJ+w0vZkrPdGaY6ft+VyFSdQvO11P50pPshba6Xs2l+lBXbUz9GQu06MabWec9FzJHtZ7O9Ok5kr0eO+wIyY6V6Lci33IzjyxudK92tPsLPXnyvRyf7Sz1pkrW+71Xmtn889lJmPftrP75jKT1QPYOSacy05mP2HnrJ2rONm9iZ2req54iD7HjqyYK1YO1TPZuYEmPcq3F3PDer1i1WmCeToYAc/TgT5NULTz4AJo5wUsKufbC1rDeYFPY7vXcF5wEkT1VTgueYuRfRU+X5Bg89c+2ZivY8Kvwufv4P8qHFdJjJ0PmEDzg4OLFh8lzXzAZOzmPZ/SHWkkTEfZYiXeBToYAS8A35GyxQWAO5IRviPRGhr4jpQtGqU70kgY7mzBA5dlR7JBgsVqdyTr2ZFiEexII4E7kgUmUIwpuOgXwUjOcWAxa2rC75bzBgUI/SIYaQUSwGLmW0MT7rIU4wRDJ5NQ2snMBas/+Xgl3mQHI+AkvJPJx5PA5E8J72RoDVPwTiYfTzEnP6KAJoQX0DR4Dbsv9MaL1HgGmHtRdsBzwXDnYx64LB1wNijMC9Z2wFlPB7xgBB0wbgcyNgsU5YJMwUUnIpLzQswdsAl3WSqOGYbubWHhXSvFZWEFvLk0vjBQ44sI13i9JgXR/KDmWhS8YUflduaE7TWZciXexToYAS8GdzuZ8mLAAC4u3O38L+hwt5MpLy7c7VChW7RDdjFeAlyMuy80Z6TGl1TqduaE4c6UPHBZ3M5SQWFeutbtLOVxO0tH4HZwO5CxSwFFuTRTcNGJiOS8jPBOkIrjkgxd/7LC3Q7FZVkFvLk0vixQ48sJ13i9JsWEuyyySRml9N3OHLC9Jlb1qw/LdzACXh7udmJmeWASrCDc7dAargB3OzGzgnC3Q4VuVIfsYryiEreD1PhKSt3OHDDc1X/lfBMSZ43bWTkozKvUup2VPW5nlQjcDm4HMnZloChXYQouOhGRnFcV3glScVyJoetfTbjbobispoA3l8ZXA2p8deEar9ekmHCXRTYpayh1O7PD9ppildtZs4MR8Jpwt1M0awKTYC3hbofWcC242ymatYS7HSp0a3TILsZrK3E7SI2vo9TtzA7DXYjM7awbFOb1at3Ouh63s14Ebge3Axm7LlCU6zEFF52ISM7rC+8EqTiuw9D1byDc7VBcNlDAm0vjGwA1vqFwjddrUky4yyKblI2Uup3ZYHtNquo3MTbuYAS8MdztpOzGwCTYRLjboTXcBO52UlW8TcjLxxtR6DbqkF2MN1XidpAa30yp25kNhjsV2W+p5ILCnK91OzmP28lH4HZwO5CxOaAo80zBRSciknNBeCdIxXEzhq6/KNztUFyKCnhzabwI1HhJuMbrNSkm3GWRTUpZqduZFfduJ1OJd/MORsCb49/tZDYHJsEWwt0OreEW+Hc7mS2Eux0qdOUO2cV4SyVuB6nxrZS6nVlhuItpD1wWt7N1UJi3qXU7W3vczjYRuB3cDmTs1kBRbsMUXHQiIjlvK7wTpOK4FUPXv51wt0Nx2U4Bby6NbwfU+PbCNV6vSTHhLotsUnZQ6nZmge01iWwl3h07GAHvCHc7ieyOwCTYSbjboTXcCe52EtmdhLsdKnQ7dMguxjsrcTtIje+i1O3MAsOdyHjgsridXYPCvFut29nV43Z2i8Dt4HYgY3cFinI3puCiExHJeXfhnSAVx10Yuv49hLsdisseCnhzaXwPoMb3FK7xek2KCXdZZJOyl1K3MzNsr8lXfcm2dwcj4L3hbidv9wYmwT7C3Q6t4T5wt5Ov4m1CXj7eiEK3V4fsYryvEreD1Ph+St3OzDDc+ci+ZNs/KMyja93O/h63MzoCt4PbgYzdHyjK0UzBRScikvMBwjtBKo77MXT9Bwp3OxSXAxXw5tL4gUCNHyRc4/WaFBPussgm5WClbmcEzu0UKvEe0sEI+BC82ykcAkyCQ4W7HVrDQ/Fup3CocLdDhe7gDtnF+DAlbgep8cOVup0RuIY474HL4naOCArzkbVu5wiP2zkyAreD24GMPQIoyiOZgotORCTno4R3glQcD2fo+o8W7nYoLkcr4M2l8aOBGj9GuMbrNSkm3GWRTcqxSt3OTLgv2fKVeMd0MAIeg/+SLT8GmATHCXc7tIbH4b9kyx8n3O1QoTu2Q3YxPl6J20FqfKxStzMT7mOnnAcui9sZFxTmE2rdzjiP2zkhAreD24GMHQcU5QlMwUUnIpLzicI7QSqOYxm6/pOEux2Ky0kKeHNp/CSgxk8WrvF6TYoJd1lkk3KKUrczI2yvyVT9AvWpHYyAT4W7nYw5FZgEpwl3O7SGp8HdTsacJtztUKE7pUN2MT5didtBavwMpW5nRhjudGS/QH1mUJjPqnU7Z3rczlkRuB3cDmTsmUBRnsUUXHQiIjmfLbwTpOJ4BkPXf45wt0NxOUcBby6NnwPU+LnCNV6vSTHhLotsUs5T6nZmYHI753cwAj6fwe2cD0yCC4S7HVrDCxjczgXC3Q4VuvM6ZBfjC5W4HaTGL1LqdmZQ6HYuDgrzJbVu52KP27kkAreD24GMvRgoykuUuB0k50uFd4JUHC9i6PovE+52KC6XKeDNpfHLgBq/XLjG6zUpJtxlkU3KFUrdzvSwvSZX9ZtsV3YwAr4S7nZy2SuBSXCVcLdDa3gV3O3kslcJdztU6K7okF2Mr1bidpAav0ap25kehjsX2W+yXRsU5utq3c61HrdzXQRuB7cDGXstUJTXMQUXnYhIztcL7wSpOF7D0PXfINztUFxuUMCbS+M3ADV+o3CN12tSTLjLIpuUm5S6nelwbidRiffmDkbAN+PdTuJmYBLcItzt0Bregnc7iVuEux0qdDd1yC7GtypxO0iN36bU7UyHa4jjHrgsbuf2oDDfUet2bve4nTsicDu4HcjY24GivIMpuOhERHK+U3gnSMXxNoau/y7hboficpcC3lwavwuo8buFa7xek2LCXRbZpNyj1O1MC9trilXvdu7tYAR8L9ztFLP3ApPgPuFuh9bwPrjbKWbvE+52qNDd0yG7GN+vxO0gNf6AUrczLQx3MbJ3Ow8GhfmhWrfzoMftPBSB28HtQMY+CBTlQ0zBRScikvPDwjtBKo4PMHT9jwh3OxSXRxTw5tL4I0CNPypc4/WaFBPussgm5TGlbmca2F5TKFXifbyDEfDjcLdTKD0OTIInhLsdWsMn4G6nUHpCuNuhQvdYh+xi/KQSt4PU+FNK3c40MNyFogcui9t5OijMz9S6nac9bueZCNwObgcy9mmgKJ9hCi46EZGcnxXeCVJxfIqh639OuNuhuDyngDeXxp8Davx54Rqv16SYcJdFNikvKHU7w2F7ja16t/NiByPgF+Fux2ZfBCbBS8LdDq3hS3C3Y7MvCXc7VOhe6JBdjF9W4naQGn9FqdsZDsNtI3u382pQmF+rdTuvetzOaxG4HdwOZOyrQFG+xhRcdCIiOb8uvBOk4vgKQ9f/hnC3Q3F5QwFvLo2/AdT4m8I1Xq9JMeEui2xS3lLqdobB9pp8ldt5u4MR8Ntwt5PPvg1MgneEux1aw3fgbieffUe426FC91aH7GL8rhK3g9T4e0rdzjAY7nxkbuf9oDB/UOt23ve4nQ8icDu4HcjY94Gi/IApuOhERHL+UHgnSMXxPYau/yPhbofi8pEC3lwa/wio8Y+Fa7xek2LCXRbZpHyi1O0Mhe01mUwl3k87GAF/Cnc7mcynwCT4TLjboTX8DO52MpnPhLsdKnSfdMguxp8rcTtIjX+h1O0MheHOpD1wWdzOl0Fh/qrW7XzpcTtfReB2cDuQsV8CRfkVU3DRiYjk/LXwTpCK4xcMXf83wt0OxeUbBby5NP4NUOPfCtd4vSbFhLssskn5TqnbmRq21ySq3M73HYyAv4e7nUTme2AS/CDc7dAa/gB3O4nMD8LdDhW67zpkF+MflbgdpMZ/Uup2pobhTkTmdn4OCvMvtW7nZ4/b+SUCt4PbgYz9GSjKX5iCi05EJOdfhXeCVBx/Yuj6fxPudiguvyngzaXx34Aa/124xus1KSbcZZFNyh9K3c5UsL0mayvx/tnBCPhPuNvJ2j+BSfCXcLdDa/gX3O1kq3ibkJePN6LQ/dEhuxj/rcTtQDXeqdPtTAWLVdZ44LK4nSk6Az10NlU7G/oPat0O/Uvcbge3Axk7RSdOlH06eYKLTkQk576d2OKDTjgqjk2d+I2hXyfvxmXCXZbi0k8Bby6N9wNqvL9wjddrUky4yyKblAFA3UTpdobA9pq0qcTb3MkImCbHup20aQYmQQswObnWsKUT7XbSpoV500AUugGdsotxK7gYd19ozkiNtyl1O0NgbidV9sBlcTvtQWHuqHU77R630xGB2xkCdDvtQFF2dPIEF52ISM6dwjtBKo5tDF1/l3C3Q3HpUsCbS+NdQI1PKVzj9ZoUE+6yyCZloFK3Mxi21+SrfoF6UCcj4EFwt5MvDQImwWDhbofWcDDc7eRLg4W7HSp0AztlF+MhStwOUuNTKXU7g3EH2SP7Beqpg8I8tNbtTO1xO0MjcDuDgW5naqAoh3byBBediEjOw4R3glQcp2Lo+ocLdzsUl+EKeHNpfDhQ49MI13i9JsWEuyyySZlWqdsZBNtrYlXvdqbrZAQ8HdztxMx0wCSYXrjboTWcHu52YmZ64W6HCt20nbKL8QxK3A5S4zMqdTuDYG7HRvZuZ6agMI+odTszedzOiAjcziCg25kJKMoRnTzBRScikvPMwjtBKo4zMnT9swh3OxSXWRTw5tL4LECNzypc4/WaFBPussgmZTalbmcgbq8pVOKdvZMR8Oxwt2MKswOTYA7hbofWcA642zGFOYS7HSp0s3XKLsZzKnE7SI3PpdTtDMSdscp74LK4nZFBYZ671u2M9LiduSNwO8AdyI4EinLuTp7gohMRyXke4Z0gFce5GLr+eYW7HYrLvAp4c2l8XqDG5xOu8XpNigl3WWSTMr9StzMlbK9JVX3JtkAnI+AF4G4nVVoAmARGuNuhNTRwt5MqGeFuhwrd/J2yi7FV4naQGo8pdTtT4s7tRPYlWzwozIlatxP3uJ1EBG5nSqDbiQNFmejkCS46EZGck8I7QSqOMYauPyXc7VBcUgp4c2k8BdR4WrjG6zUpJtxlkU1KRqnb6YLtNbbqN9mynYyAs3C3Y20WmAQLCnc7tIYLwt2OreJtQl4+3ohCl+mUXYwXUuJ2kBpfWKnb6cJ9yRbZb7ItEhTmRWvdziIet7NoBG6nC+h2FgGKctFOnuCiExHJeTHhnSAVx4UZuv7Fhbud/8VFAW8ujS8O1PgSwjVer0kx4S6LbFKWVOp2OoE/GlyJd6lORsBLdeLnXVq4QyHeS3eOX2DQvCyuggrKkp2yi94ySlwFUpfLMhd6REyWZdB4lAW1g6mgLtfJCHg5hoI6SnhBJd6jGgUVNtfySgoqUpcrCC+oFJMVlBfUduAvJ1fiXbGTEfCKDMm6IlBsKwkvzrSGKzHY+5WEP4/XUOhXVlLokRpfRfgjEorJKgz5sqrwx4BUJ1ZlauK4dLkqUJerCddlvXpmwl0WWc9WF65xivHqDAYNqUNqCIc0jX8VVnmhcY9s4cnzJijOGOv7yykq1nZE8Oc1XDzXdGMtN9Z2Yx031nVjPTfWd2MDNzZ0YyM3NnZjEzc2dWMzN3Ju5N0ouFF0o+RG2Y3N3djCjS3d2MqNrd3Yxo1t3djOje3d2MGNHWvfna4RvCetvLem595anntre+6t47m3rufeep5763vubeC5t6Hn3kaeext77m3iubep595mnns5z728517Bc6/ouVfy3Ct77m3uubeF596Wnntbee5t7bm3jefetp5723nube+5t4Pn3o6dE76Tnzn45+LBP024q6rohC2WawAKb/f7/TVBcxHHtSBz/bNea4efKxasl10n7FyJf9ferhtuLlMRR7temLliVZqw60/+XKZGX3aDyZwrVZ5Aq3bDyZsr49G93Why5sp4c8hu3Pu50nXy0W7S27nSdXPbbtq7uWITqRN2s97MlZ5ozbG5ns9VmET9svmezpWeZC20hZ7NZXpQV22xJ3OZHtVoW5r0XMke1ntbntRciR7vHXbzic6VKPdiH7JbTGyudK/2NLtl/bkyvdwf7VZ15sqWe73X2q39c5nJ2LftNr65zGT1AHbbCeeyk9lP2O1q5ypOdm9it6+eKx6iz7E7VMwVK4fqmeyOQJMe5duLHWG9XrHqNMFOnYyAd+pEnyYo2p1wAbQ7AxaV8+0FreHOwKex3Wu4MzgJovoqHJe8xci+Ct8lSLBda59s7NI54Vfhu3byfxWOqyTG7gJMoF3BwUWLj5JmF2AydvPeRemOtANMR9liJd7dOhkB7wbfkbLF3YA70u7CdyRaw93hO1K2uLvSHWkHGO5swQOXZUfaI0iwPWt3pD08O9KeEexIOwB3pD2ACbQnU3DRL4KRnPcCFrOmJvxuuXNQgNAvgpFWYG9gMfOtoQl3WYrx3gydzN5KO5ntYfUnH6/Eu08nI+B94J1MPr4PMPn3Fd7J0BruC+9k8vF9mZMfUUD3Fl5A9wOvYfeF3niRGt8fmHtRdsDbw3DnYx64LB3w6KAwH1DbAY/2dMAHRNAB43YgY0cDRXkAU3DRiYjkfCBzB2zCXZaK4/4M3dtBwrtWistBCnhzafwgoMYPFq7xek0KovlBzXUIeMOOyu1sB9trMuVKvId2MgI+FO52MuVDgQE8TLjboTU8DO52MuXDhLsdKnSHdMouxoeDi3H3heaM1PgRSt3OdjDcmZIHLovbOTIozEfVup0jPW7nqAjcDm4HMvZIoCiPYgouOhGRnI8W3glScTyCoes/Rrjbobgco4A3l8aPAWr8WOEar9ekmHCXRTYpY5S+29kWttfEqn714bhORsDHwd1OzBwHTILjhbsdWsPj4W4nZo4X7nao0I3plF2MxypxO0iNj1PqdraF4a7+K+ebkDhr3M4JQWE+sdbtnOBxOydG4HZwO5CxJwBFeSJTcNGJiOR8kvBOkIrjOIau/2ThboficrIC3lwaPxmo8VOEa7xek2LCXRbZpJyq1O1sA9trilVu57RORsCnwd1O0ZwGTILThbsdWsPT4W6naE4X7nao0J3aKbsYn6HE7SA1fqZSt7MNDHchMrdzVlCYz651O2d53M7ZEbgd3A5k7FlAUZ7NFFx0IiI5nyO8E6TieCZD13+ucLdDcTlXAW8ujZ8L1Ph5wjVer0kx4S6LbFLOV+p2tobtNamq38S4oJMR8AVwt5OyFwCT4ELhbofW8EK420lV8TYhLx9vRKE7v1N2Mb5IidtBavxipW5naxjuVGS/pXJJUJgvrXU7l3jczqURuB3cDmTsJUBRXsoUXHQiIjlfJrwTpOJ4MUPXf7lwt0NxuVwBby6NXw7U+BXCNV6vSTHhLotsUq5U6na2wr3byVTivaqTEfBV+Hc7mauASXC1cLdDa3g1/t1O5mrhbocK3ZWdsovxNUrcDlLj1yp1O1vBcBfTHrgsbue6oDBfX+t2rvO4nesjcDu4HcjY64CivJ4puOhERHK+QXgnSMXxWoau/0bhboficqMC3lwavxGo8ZuEa7xek2LCXRbZpNys1O1sCdtrEtlKvLd0MgK+Be52EtlbgElwq3C3Q2t4K9ztJLK3Cnc7VOhu7pRdjG9T4naQGr9dqdvZEoY7kfHAZXE7dwSF+c5at3OHx+3cGYHbwe1Axt4BFOWdTMFFJyKS813CO0EqjrczdP13C3c7FJe7FfDm0vjdQI3fI1zj9ZoUE+6yyCblXqVuZwvYXpOv+pLtvk5GwPfB3U7e3gdMgvuFux1aw/vhbidfxduEvHy8EYXu3k7ZxfgBJW4HqfEHlbqdLWC485F9yfZQUJgfrnU7D3nczsMRuB3cDmTsQ0BRPswUXHQiIjk/IrwTpOL4IEPX/6hwt0NxeVQBby6NPwrU+GPCNV6vSTHhLotsUh5X6nY2x7mdQiXeJzoZAT+BdzuFJ4BJ8KRwt0Nr+CTe7RSeFO52qNA93im7GD+lxO0gNf60UrezOa4hznvgsridZ4LC/Gyt23nG43aejcDt4HYgY58BivJZpuCiExHJ+TnhnSAVx6cZuv7nhbsdisvzCnhzafx5oMZfEK7xek2KCXdZZJPyolK3U8Z9yZavxPtSJyPgl/BfsuVfAibBy8LdDq3hy/gv2fIvC3c7VOhe7JRdjF9R4naQGn9Vqdsp4z52ynngsrid14LC/Hqt23nN43Zej8Dt4HYgY18DivJ1puCiExHJ+Q3hnSAVx1cZuv43hbsdisubCnhzafxNoMbfEq7xek2KCXdZZJPytlK3U4LtNZmqX6B+p5MR8Dtwt5Mx7wCT4F3hbofW8F2428mYd4W7HSp0b3fKLsbvKXE7SI2/r9TtlGC405H9AvUHQWH+sNbtfOBxOx9G4HZwO5CxHwBF+SFTcNGJiOT8kfBOkIrj+wxd/8fC3Q7F5WMFvLk0/jFQ458I13i9JsWEuyyySflUqdspMrmdzzoZAX/G4HY+AybB58LdDq3h5wxu53PhbocK3aedsovxF0rcDlLjXyp1O0WFbueroDB/Xet2vvK4na8jcDu4HcjYr4Ci/FqJ20Fy/kZ4J0jF8UuGrv9b4W6H4vKtAt5cGv8WqPHvhGu8XpNiwl0W2aR8r9TtFGB7Ta7qN9l+6GQE/APc7eSyPwCT4EfhbofW8Ee428llfxTudqjQfd8puxj/pMTtIDX+s1K3U4DhzkX2m2y/BIX511q384vH7fwagdvB7UDG/gIU5a9MwUUnIpLzb8I7QSqOPzN0/b8LdzsUl98V8ObS+O9Ajf8hXOP1mhQT7rLIJuVPpW4nj3M7iUq8f3UyAv4L73YSfwGT4G/hbofW8G+820n8LdztUKH7s1N2MW7q0uF2kBqfAsg5SreTxzXEcQ9cFrfTp+uff/btaqp2NvQf1Lod+pe43Q5uBzK2TxdOlH27eIKLTkQk537g4oNOOCqOU3ThN4b+Xbwblwl3WYpLfwW8uTTeH6jxAcI1Xq9JMeEui2xSmoG6idLt5GB7TbHq3U5LFyNgmhzrdorZFmAStAKTk2sNW7vQbqeYbWXeNBCFrrlLdjFuU+J2kBpvV+p2cjC3U4zs3U5HUJg7a91Oh8ftdEbgdnJAt9MBFGVnF09w0YmI5NwlvBOk4tjO0PVPKdztUFymVMCbS+NTAjU+ULjG6zUpJtxlkU3KIKVuZzPYXlMoVeId3MUIeDDc7RRKg4FJMES426E1HAJ3O4XSEOFuhwrdoC7ZxXgqJW4HqfGplbqdzWBup1D0wGVxO0ODwjys1u0M9bidYRG4nc2AbmcoUJTDuniCi05EJOfhwjtBKo5TM3T90wh3OxSXaRTw5tL4NECNTytc4/WaFBPussgmZTqlbmdT2F5jq97tTN/FCHh6uNux2emBSTCDcLdDazgD3O3Y7AzC3Q4Vuum6ZBfjGZW4HaTGZ1LqdjaFuR0b2budEUFhnrnW7YzwuJ2ZI3A7mwLdzgigKGfu4gkuOhGRnGcR3glScZyJoeufVbjbobjMqoA3l8ZnBWp8NuEar9ekmHCXRTYpsyt1O5vA9pp8lduZo4sR8Bxwt5PPzgFMgjmFux1awznhbiefnVO426FCN3uX7GI8lxK3g9T4SKVuZxOY28lH5nbmDgrzPLVuZ26P25knArezCdDtzA0U5TxdPMFFJyKS87zCO0EqjiMZuv75hLsdist8CnhzaXw+oMbnF67xek2KCXdZZJOygFK3szHuF6gzlXhNFyNgA3c7mYwBJoEV7nZoDS3c7WQyVrjboUK3QJfsYhxT4naQGo8rdTsbw9xOJu2By+J2EkFhTta6nYTH7SQjcDsbA91OAijKZBdPcNGJiOScEt4JUnGMM3T9aeFuh+KSVsCbS+NpoMYzwjVer0kx4S6LbFKySt3ORrC9JlHldhbsYgS8INztJDILApNgIeFuh9ZwIbjbSWQWEu52qNBlu2QX44WVuB2kxhdR6nY2grmdRGRuZ9GgMC9W63YW9bidxSJwOxsB3c6iQFEu1sUTXHQiIjkvLrwTpOK4CEPXv4Rwt0NxWUIBby6NLwHU+JLCNV6vSTHhLotsUpZS6nY2hO01WVuJd+kuRsBLw91O1i4NTIJlhLsdWsNl4G4nW8XbhLx8vBGFbqku2cV4WSVuB6nx5ZS6nQ1hbidrPHBZ3M6ooDAvX+t2RnnczvIRuJ0NgW5nFFCUy3fxBBediEjOKwjvBKk4LsfQ9a8o3O1QXFZUwJtL4ysCNb6ScI3Xa1JMuMsim5SVlbqdDWB7TdpU4l2lixHwKnC3kzarAJNgVeFuh9ZwVbjbSZtVhbsdKnQrd8kuxqspcTtIja+u1O1sAHM7qbIHLovbWSMozGvWup01PG5nzQjczgZAt7MGUJRrdvEEF52ISM5rCe8EqTiuztD1ry3c7VBc1lbAm0vjawM1vo5wjddrUky4yyKblHWVup31cb9SUPUL1Ot1MQJeD+528qX1gEmwvnC3Q2u4Ptzt5EvrC3c7VOjW7ZJdjDdQ4naQGt9QqdtZH/crBZH9AvVGQWHeuNbtbORxOxtH4HbWB7qdjYCi3LiLJ7joRERy3kR4J0jFcUOGrn9T4W6H4rKpAt5cGt8UqPHNhGu8XpNiwl0W2aTklLqd9WB7Tazq3U6+ixFwHu52YiYPTIKCcLdDa1iAu52YKQh3O1Tocl2yi3FRidtBaryk1O2sh/sF6sje7ZSDwrx5rdspe9zO5hG4nfWAbqcMFOXmXTzBRScikvMWwjtBKo4lhq5/S+Fuh+KypQLeXBrfEqjxrYRrvF6TYsJdFtmkbK3U7ayL22sKlXi36WIEvA3c7ZjCNsAk2Fa426E13BbudkxhW+Fuhwrd1l2yi/F2StwOUuPbK3U768Lcjsl74LK4nR2CwrxjrdvZweN2dozA7QB3ILsDUJQ7dvEEF52ISM47Ce8EqThuz9D17yzc7VBcdlbAm0vjOwM1votwjddrUky4yyKblF2Vup11YHtNqupLtt26GAHvBnc7qdJuwCTYXbjboTXcHe52UqXdhbsdKnS7dskuxnsocTtIje+p1O2sgzu3E9mXbHsFhXnvWrezl8ft7B2B21kH6Hb2Aopy7y6e4KITEcl5H+GdIBXHPRm6/n2Fux2Ky74KeHNpfF+gxvcTrvF6TYoJd1lkk7K/UrezNmyvsVW/yTa6ixHwaLjbsXY0MAkOEO52aA0PgLsdW8XbhLx8vBGFbv8u2cX4QCVuB6nxg5S6nbVxX7JF9ptsBweF+ZBat3Owx+0cEoHbWRvodg4GivKQLp7gohMRyflQ4Z0gFceDGLr+w4S7HYrLYQp4c2n8MKDGDxeu8XpNigl3WWSTcoRSt7MW7mOMqnM7R3YxAj6yCz/vUcIdCvE+qmv8AoPmZXEVVFCO6JJd9I5W4iqQujyGudAjYnIMg8ajLKhrMhXUY7sYAR/LUFDHCC+oxHtMo6DC5jpOSUFF6vJ44QWVYnK88oK6RiduPSrxju1iBDyWIVnHAsU2TnhxpjUcx2Dvxwl/Hq+h0J+gpNAjNX6i8EckFJMTGfLlJOGPAalOnMTUxHHp8iSgLk8Wrst69cyEuyyynp0iXOMU41MYDBpSh9QQtjaNvyobrVMpP/sFI4qO8VRgQPtU4DwtKDSn174opP9gdM2904N7lRf6ReGpwAie1vO5CpOYy54Ofhjev8n/9rqpl+s5KdxNjKI8DbgmlUl0Rq0Yz+iaMMtqhYcUyySw2kmROQMo4jO7YGIwlWt6Zg+SOSz204HrgFzTs3qxppP636pc07MqimZLxXpWrqkJd9m/Jj5frFC28WQpnTSpXCJZTMVjxVjaFBPJsnWAY9mEW5pyIZEpZmLxciwdK/yFxfc/jXUXtu6N5K+m8RsI/fls989z3Di3658dNKrnLudUxN1m4rFYOk76yBSNTRTdFhCLFfMJUzC5QqyUTdhsORFLxAvFQt5pKWfLppwrZMuZf+aqxHteFyPg8zy9Zljw5wF77POFP3ehNTzf02uGXcPzwR1B36Zovmc7h+lzkCbs+lZ1BBdUNgDoBwLAQNrK3aASdC8xF3oivgsmw4ROatEvACbzheD2sHtdL6zoXHqrBUs/QWpN2WRjJmfShVQ6ny3G8plcOV5OxovxyV3XSYkdua4XMa3rRcG6RulrkcWosnheHOzIl1AOchSMCxieXlwg/En+5CaH6QXvsBgvFf7ki4R5KcNT7cuYisJlEym2JtxlL2Fai8uZ1uLyEBvPpDBz6eKA4f9fa8okn6txaeDA4bLrwDkBb3QtBcbbItfwv/LM82KmZ55XTMzhmHCXvZSpIF4xEYcziWkm+QyVMF/BUBgOAheG7qtfL2PWm0YmLOcru2QWGGQsKnV5pefZdm/jM6k1R8bnqsrnkvG4y41i2paL5XgynY3lbSqeSpUT5XQqkyiWk4lcMV2yiVw8li2lTdlmSu5pb7yQTpWzxUKqXFm0bTEeTxSz+YJNxlK5vMkU4zlTTqTjzvwW4+liMZ5JpXLxeDGVKWeyzrA6G5wxyXQ6a1KxeDbGFZ+rKpwmalOY1JONyjm1bApXa9wUrmbeFK5m2BQOFrIp1BVx+n9nX8vIonON0E3hYKaicw1gU5jUYz5kfK4Vuilwxefa/9Djx+uCx4/X+x4/mnBX3Wf/yPcgYecCPspk+Yivew3RXzxwrWHYuW4QHg9KmBsYNvYbmZqcGxkfi17PtBY3Ma3FTYyPRbl0cajwx6JcGjhMwWPRGxgeiwLjbQ9rPBatvf5Xv1FrUtn43czpgG9gKog3MzpgwnwzQ2E4XMlj0RuATdEtXTILzOFMDuuWCB6LIuNzK9ABHwZ0wFzxudUTH/QHXsj43MZUP28DrMOkntQg1+F2pnW4vQePySVv5B64MB1XNgl3aGwS7mBuEu5gaBKOiKhJCPl1LLTI3QmcC9kkHMG0Cd3ZgyYh7Fe2yPjc1YXb2JFNAld87mJ88tRUZ96wMbpb+EeZNMfdDPXyHoDO//nV2zILb8J3DwPve4XHmzjfy8D7PuG8Cd99DLzvF86b8N3PwPsB4bwJ3wMMvB8UzpvwPcjA+yHhvAnfQwy8HxbOm/A9zMD7EQX72CMMvB8VzpvwPcrA+zEF8X6MgffjwnkTvscZeD8hnDfhe4KB95PCeRO+Jxl4P6Ugv59i4P20cN6E72kG3s8I5034nmHg/axw3oTvWQbezwnnTfieY+D9vIK69jwD7xeE8yZ8LzDwflE4b8L3IgPvl4TzJnwvMfB+WUF+v8zA+xXhvAnfKwy8X1UQ71cZeL8mnDfhe42B9+sK4v06A+83hPMmfG8w8H5TOG/C9yYD77eE8yZ8bzHwfltBfr/NwPsd4bwJ3zsMvN9VEO93GXi/J5w34XuPgff7CuL9PgPvD4TzJnwfMPD+UDhvwvchA++PhPMmfB8x8P5YQX5/zMD7E+G8Cd8nDLw/Fc6b8H3KwPszBTr/jIH358J5E77PGXh/oSDeXzDw/lI4b8L3JQPvrxTE+ysG3l8L5034vmbg/Y1w3oTvGwbe3wrnTfi+ZeD9nXDehO87Bt7fC+dN+L5n4P2Dgnr+AwPvH4XzJnw/MvD+SThvwvcTA++fhfMmfD8z8P5FQX7/wsD7V+G8Cd+vDLx/UxDv3xh4/y6cN+H7nYH3H8J5E74/GHj/KZw34fuTgfdfwnkTvr8YeP+toK79zcC7aUrZvAkfDTTvKYTz/t+ZdwbefYTzJnx9GHj3Fc6b8PVl4N1Pgc77MfDuL5w34evPwHuAcN6EbwAD72bhvAlfMwPvFuG8CV8LA+9W4bwJXysD7zbhvAlfGwPvduG8CV87A+8O4bwJXwcD704FfUsnA+8u4bwJXxcD7ymF8yZ8UzLwHqhA5wMZeA8SzpvwDWLgPVg4b8I3mIH3EOG8Cd8QBt5TKcjvqRh4Ty2cN+GbmoH3UAXxHsrAe5hw3oRvGAPv4cJ5E77hDLynUaDzaRh4TyucN+GbloH3dAriPR0D7+mF8yZ80zPwnkFBvGdg4D2jcN6Eb0YG3jMJ5034ZmLgPUI4b8I3goH3zMJ5E76ZGXjPIpw34ZuFgfesCur5rAy8ZxPOm/DNxsB7duG8Cd/sDLznUKDzORh4zymcN+Gbk4H3XMJ5E765GHiPFM6b8I1k4D23cN6Eb24G3vMI50345mHgPa9w3oRvXgbe8ynYx+Zj4D2/cN6Eb34G3gsI5034FmDgbYTzJnyGgbcVzpvwWQbeMQV1LcbAOy6cN+GLM/BOCOdN+BIMvJMKdJ5k4J0SzpvwpRh4pxXEO83AOyOcN+HLMPDOCudN+LIMvBdUoPMFGXgvJJw34VuIgffCCuK9MAPvRYTzJnyLMPBeVDhvwrcoA+/FFOh8MQbeiwvn/T98DLyXUBDvJRh4LymcN+FbkoH3UsJ5E76lGHgvrUDnSzPwXkY4b8K3DAPvZYXzJnzLMvBeTjhvwrccA+9RwnkTvlEMvJcXzpvwLc/AewXhvAnfCgy8VxTOm/CtyMB7JQX790oMvFcWzpvwrczAexUF8V6FgfeqwnkTvlUZeK8mnDfhW42B9+rCeRO+1Rl4ryGcN+Fbg4H3msJ5E741GXivJZw34VuLgffawnkTvrUZeK+jYP9eh4H3usJ5E751GXivJ5w34VuPgff6CnS+PgPvDYTzJnwbMPDeUDhvwrchA++NFOh8IwbeGwvnTfg2ZuC9iYJ4b8LAe1PhvAnfpgy8NxPOm/BtxsA7J5w34csx8M4L50348gy8C8J5E74CA++ignpeZOBdEs6b8JUYeJeF8yZ8ZQbemyvQ+eYMvLcQzpvwbcHAe0sF8d6SgfdWwnkTvq0YeG+tIN5bM/DeRjhvwrcNA+9thfMmfNsy8N5Ogc63Y+C9vXDehG97Bt47COdN+HZg4L2jcN6Eb0cG3jspyO+dGHjvLJw34duZgfcuwnkTvl0YeO+qQOe7MvDeTThvwrcbA+/dhfMmfLsz8N5DOG/CtwcD7z2F8yZ8ezLw3ks4b8K3FwPvvYXzJnx7M/DeR8E+tg8D732F8yZ8+zLw3k9BvPdj4L2/cN6Eb38G3qOF8yZ8oxl4HyCcN+E7gIH3gQry+0AG3gcJ5034DmLgfbCCeB/MwPsQ4bwJ3yEMvA9VEO9DGXgfJpw34TuMgffhCuJ9OAPvI4TzJnxHMPA+UkG8j2TgfZRw3oTvKAbeRwvnTfiOZuB9jAKdH8PA+1jhvAnfsQy8xwjnTfjGMPA+TjhvwnccA+/jhfMmfMcz8B4rnDfhG8vAe5yCej6OgfcJwnkTvhMYeJ8onDfhO5GB90nCeRO+kxh4n6wgv09m4H2KcN6E7xQG3qcK5034TmXgfZpw3oTvNAbepwvnTfhOZ+B9hnDehO8MBt5nKqjnZzLwPks4b8J3FgPvsxXE+2wG3ucI5034zmHgfa6CeJ/LwPs84bwJ33kMvM9XEO/zGXhfIJw34buAgfeFwnkTvgsZeF8knDfhu4iB98UK8vtiBt6XCOdN+C5h4H2pgnhfysD7MuG8Cd9lDLwvF86b8F3OwPsKBTq/goH3lcJ5E74rGXhfpSDeVzHwvlo4b8J3NQPvaxTE+xoG3tcK5034rmXgfZ1w3oTvOgbe1wvnTfiuZ+B9g4L8voGB943CeRO+Gxl43yScN+G7iYH3zQp0fjMD71uE8yZ8tzDwvlVBvG9l4H2bcN6E7zYG3rcriPftDLzvEM6b8N3BwPtO4bwJ350MvO8Szpvw3cXA+27hvAnf3Qy875Fe1xy+exh436ugnt/LwPs+4bwJ330MvO8Xzpvw3c/A+wHhvAnfAwy8H1SQ3w8y8H5IOG/C9xAD74eF8yZ8DzPwfkQ4b8L3CAPvR4XzJnyPMvB+TEFde4yB9+PCeRO+xxl4PyGcN+F7goH3kwp0/iQD76eE8yZ8TzHwflo4b8L3NAPvZ4TzJnzPMPB+VjhvwvcsA+/nhPMmfM8x8H5eQT1/noH3C8J5E74XGHi/qCDeLzLwfkk4b8L3EgPvlxXE+2UG3q8I5034XmHg/aqCeL/KwPs14bwJ32sMvF9XEO/XGXi/IZw34XuDgfebwnkTvjcZeL8lnDfhe4uB99vCeRO+txl4vyOcN+F7h4H3uwrq+bsMvN8TzpvwvcfA+30F8X6fgfcHwnkTvg8YeH+oIN4fMvD+SDhvwvcRA++PFcT7YwbenwjnTfg+YeD9qYJ4f8rA+zPhvAnfZwy8PxfOm/B9zsD7CwU6/4KB95fCeRO+Lxl4fyWcN+H7ioH31wp0/jUD72+E8yZ83zDw/lZBvL9l4P2dcN6E7zsG3t8L5034vmfg/YNw3oTvBwbePyrI7x8ZeP8knDfh+4mB98/CeRO+nxl4/yKcN+H7hYH3rwry+1cG3r8J5034fmPg/buCeP/OwPsP4bwJ3x8MvP9UEO8/GXj/JZw34fuLgfffCuL9NwPvpoGyeRM+GmjeUwjnTfGegoF3H+G8CV8fBt59FcS7LwPvfsJ5E75+DLz7C+dN+Poz8B4gnDfhG8DAu1k4b8LXzMC7RThvwtfCwLtVOG/C18rAu004b8LXxsC7XThvwtfOwLtDOG/C18HAu1M4b8LXycC7SzhvwtfFwHtK4bwJ35QMvAcK5034BjLwHiScN+EbxMB7sHDehG8wA+8hwnkTviEMvKcSzpvwTcXAe2rhvAnf1Ay8hwrnTfiGMvAeJpw34RvGwHu4cN6EbzgD72mE8yZ80zDwnlY4b8I3LQPv6YTzJnzTMfCeXjhvwjc9A+8ZhPMmfDMw8J5xIPDdi5tjUAX3ygu9HjMC41WJd6aBjIBnGoifdwQwgFy8Rwwcv8CgedleSnK8jJ0ZXFy6rz61/FOxTCKRicXzuXTM5hL5dKqcLRZy5VgmHyvmTCljUsV0LBfP5DIJmy/kMiZfzMWS6WIuUUrZGFJLs1TM5f4XCyZbNrlkJpcuuYlMybg/5DOlciqWyxcSJla01pYS7v+LlYqJbL6YsvmU+19P5q377/liHcsXsql02v03C8V8ImGT2ViumLdpS+QT5Uw6nrf5uIMaTyfLsVI5YbJuMRzNsluCeL7UL9DlBGuYyOZKbtp8PBUv5R3YciyZymXdf6uQKsVTiTytbzIeK6cScbduMRNP5MqFRDJjsrFMIZHoB1zDWYVvSoRvVoZ8mU04b8I3GwPv2YXzJnyzM/CeQzhvwjcHA+85hfMmfHMy8J5LOG/CNxcD75HCeRO+kQy85xbOm/DNzcB7HuG8Cd88DLznFc6b8M3LwHs+4bwJ33wMvOcXzpvwzc/AewHhvAnfAgy8jXDehM8w8LbCeRM+y8A7Jpw34Ysx8I4L50344gy8E8J5E74EA++kcN6EL8nAOyWcN+FLMfBOC+dN+NIMvDPCeRO+DAPvrHDehC/LwHtB4bwJ34IMvBcSzpvwLcTAe2GlL3UXZnqpu8hARsCLMLzUXRQYQC7eiw4cv8CgeVmw0svXWRiSbLGIXuqGfdGJ1NLiA3EvSn2xtuVyoZwupkvleCxWSKfz6XghmcwXCu6FdT5v3a1iJusWwN01afe/EkunMvFMvFAweZsqlv/3wnRRz0tda1LpZCqbK7v/AbcmMWeV46Vy2fF38xUTuZRJ5pOxfCpeTGXKjpYtuBUoJtOxcqKUjdnYrMA1XEL4pkT4lmDIlyWF8yZ8SzLwXko4b8K3FAPvpYXzJnxLM/BeRjhvwrcMA+9lhfMmfMsy8F5OOG/CtxwD71HCeRO+UQy8lxfOm/Atz8B7BeG8Cd8KDLxXFM6b8K3IwHsl4bwJ30oMvFcWzpvwrczAexXhvAnfKgy8VxXOm/CtysB7NeG8Cd9qDLxXF86b8K3OwHsN4bwJ3xoMvNcUzpvwrcnAey3hvAnfWgy81xbOm/CtzcB7HeG8Cd86DLzXFc6b8K3LwHs94bwJ33oMvNdX+nJzfaaXmxsMZAS8AcPLzQ2BAeTiveHA8QsMmpcF6/9eQjIk2UYRvdwM+8IPqaWNB+JeGHpjnSybcjmfzpUKpWQpnrOpfDIRSyZymVQpkc9kckVTjLt/o5Qvx7KlWCyZtu5/KJmMpzPpQqGUWSLQ5QQviHPpeKKUz8djqXjClso5m82beMoWszZuCsVEOh9L5dOJTMa9mC3GUqVSwd0su3e2mbRbEZtbAriGmwjflAjfJgz5sqlw3oRvUwbemwnnTfg2Y+CdE86b8OUYeOeF8yZ8eQbeBeG8CV+BgXdROG/CV2TgXRLOm/CVGHiXhfMmfGUG3psL5034NmfgvYVw3oRvCwbeWwrnTfi2ZOC9lXDehG8rBt5bC+dN+LZm4L2NcN6EbxsG3tsK5034tmXgvZ1w3oRvOwbe2wvnTfi2Z+C9g3DehG8HBt47CudN+HZk4L2TcN6EbycG3jsL5034dmbgvYtw3oRvFwbeuyp9ybcr00u+3QYyAt6N4SXf7sAAcvHefeD4BQbNy4KVXsZtzJBke0T0ki/siy+klvYciHtx5ou1e1OZyMVy+aT7VxPlZDru3mta9z9hyu51JoGJF5PFXNYk8vFUIlvOx9L5gonnDf3vlfO59CaBLidYw0K2nMsX0plEspg0jmYyVorlTDxtC25BbNkmkiVTzGdipYyjk03ZQixZtqW4e2WapwXaBLiGewnflAjfXgz5srdw3oRvbwbe+wjnTfj2YeC9r3DehG9fBt77CedN+PZj4L2/cN6Eb38G3qOF8yZ8oxl4HyCcN+E7gIH3gcJ5E74DGXgfJJw34TuIgffBwnkTvoMZeB8inDfhO4SB96HCeRO+Qxl4HyacN+E7jIH34cJ5E77DGXgfIZw34TuCgfeRwnkTviMZeB8lnDfhO4qB99HCeRO+oxl4HyOcN+E7hoH3scJ5E75jGXiPEc6b8I1h4H2c0pddxzG97Dp+ICPg4xledo0FBpCL99iB4xcYNC8LVnoptSdDko2L6GVX2BdASC2dMBD3AskX61gpGU8aU86k0oWie0uWoJdmqUSykEwW8+lYvGjdu7WYySRTxXwxnbaZUjaRNxm3MOly3L3h2yvQ5QQvu2LWlEupeDKXTxTSiaJ7C5cvlNMmX4i5t4fxbDKVMQ61icWKxWzWlt3rxGIiaVK5vLufzBb3Aq7hicI3JcJ3IkO+nCScN+E7iYH3ycJ5E76TGXifIpw34TuFgfepwnkTvlMZeJ8mnDfhO42B9+nCeRO+0xl4nyGcN+E7g4H3mcJ5E74zGXifJZw34TuLgffZwnkTvrMZeJ8jnDfhO4eB97nCeRO+cxl4nyecN+E7j4H3+cJ5E77zGXhfIJw34buAgfeFwnkTvgsZeF8knDfhu4iB98XCeRO+ixl4XyKcN+G7hIH3pcJ5E75LGXhfpvSlz2VML30uH8gI+HKGlz5XAAPIxfuKgeMXGDQvC1Z6OXMCQ5JdGdVLn5AvQpBaumog7kWKL9YORN6WY4VYOZ4pOFSlXK6cTpXL5WTOFFOJdLxgs4VsIu5eKuUyiWIy6/6HbTpeTBRLqXw+kzgx0GXtGtpcMRsrJ1Ju8kwxm3MLmTOFkuOdL5lMzCZLBZuzZeMWOlsq5fPuVVmqWCwlU7mYzbp1LJ0IXMOrhW9KhO9qhny5RjhvwncNA+9rhfMmfNcy8L5OOG/Cdx0D7+uF8yZ81zPwvkE4b8J3AwPvG4XzJnw3MvC+SThvwncTA++bhfMmfDcz8L5FOG/CdwsD71uF8yZ8tzLwvk04b8J3GwPv24XzJny3M/C+QzhvwncHA+87hfMmfHcy8L5LOG/CdxcD77uF8yZ8dzPwvkc4b8J3DwPve4XzJnz3MvC+TzhvwncfA+/7lb78uJ/p5ccDAxkBP8Dw8uNBYAC5eD84cPwCg+ZlwUovKa5iSLKHInr5EfaFAFJLDw/EvVDwxdrG0qlCohyLx02yEDeOZ6wUN7l0OV/KJPNFUyjHS6VY0eTKybKNOwDWZtNFUyzHHZJcsXx1oMsJ1rBYKmayGZMrxfLFos0lYjGH0LhJs5lyIVNIZspJk0ynC7lkLlkoxfOxQiadySTLhaLJJ2Pxq4Fr+IjwTYnwPcKQL48K5034HmXg/Zhw3oTvMQbejwvnTfgeZ+D9hHDehO8JBt5PCudN+J5k4P2UcN6E7ykG3k8L5034nmbg/Yxw3oTvGQbezwrnTfieZeD9nHDehO85Bt7PC+dN+J5n4P2CcN6E7wUG3i8K5034XmTg/ZJw3oTvJQbeLwvnTfheZuD9inDehO8VBt6vCudN+F5l4P2acN6E7zUG3q8rfQnwOtNLgDcGMgJ+g+ElwJvAAHLxfnPg+AUGzcuClR7WP8yQZG9F9RIg5INxpJbeHoh7sO6NdS7p3hsUbTEdixXKhVSW/nabXLmQphcfyWQ2nXcQ3f9KtlgoxPNl9+9m3X9YymULBTd5Lv9IoMvaNYylbCxZzFmTM6WiScVj6aTJ5PI5kypat5jxXCFlU+52MV8qxhPZcjLu2BRz2WQ8Hk9nkulHgGv4jvBNifC9w5Av7wrnTfjeZeD9nnDehO89Bt7vC+dN+N5n4P2BcN6E7wMG3h8K5034PmTg/ZFw3oTvIwbeHwvnTfg+ZuD9iXDehO8TBt6fCudN+D5l4P2ZcN6E7zMG3p8L5034Pmfg/YVw3oTvCwbeXwrnTfi+ZOD9lXDehO8rBt5fC+dN+L5m4P2NcN6E7xsG3t8K5034vmXg/Z3Sh+HfMT0M/34gI+DvGR6G/wAMIBfvHwaOX2DQvCxY6aH12wxJ9mNED8PDPiBGaumngbgHzN5Yl0w8lU6U3MPzZDFZTKdShWI+5p7+58ruNUAiXU6XbNaYVDmVisWyyVQpXUhkCzaRKRVMNp5IvhPocoKH4bGUcbQTmUQi7x7Ox5I2E8vGk/FsKlNKZG3SvWeIJTMJm4kn04l03D28t0W3suWUjZdThXzxHeAa/ix8UyJ8PzPkyy/CeRO+Xxh4/yqcN+H7lYH3b8J5E77fGHj/Lpw34fudgfcfwnkTvj8YeP8pnDfh+5OB91/CeRO+vxh4/y2cN+H7m4E3uUDJvP/nUgfheU8hnDfhm4KBdx/hvAlfHwbefYXzJnx9GXj3E86b8PVj4N1fOG/C15+B9wDhvAnfAAbezcJ5E75mBt4tg3Q+FG4BxqsSb+sgRsCtg/DztgEDyMW7bdD4BQbNy4KVHt7+xNAkt4OLS/c1wUPhkA9KkVrqGIR70OqLtU1lUllbiOdSuUTSTZQsJEqFUj5XyBfS5Zwpp2KFeLKcyKbcf5B1z5rdM/B8PFlyMOKxeDkWo4eZxLd2DW22WHQgy/FcpphIFWyyYGw6Vc7nk/lsspQoFpJpk8mUyw5aomjzxUyikMqXc8l0sVAsuAD8DHwo3Cl8UyJ8nQybUpdw3oSvi4H3lMJ5E74pGXgPFM6b8A1k4D1IOG/CN4iB92DhvAnfYAbeQ4TzJnxDGHhPJZw34ZuKgffUwnkTvqkZeA8VzpvwDWXgPUw4b8I3jIH3cOG8Cd9wBt7TCOdN+KZh4D2tcN6Eb1oG3tMJ5034pmPgPb1w3oRvegbeMyh9ODoD08PRGQcxAp6R4eHoTMIfjhLvmZQ8HKWHmB0MSTYiooejYR8YIrU08yDcA0dfrK2bKGYy6Xg26f7FWMr9N8v5TKmczaVj7uFvzlEy5Xy2HIs7HuVM3Bbcv+oox2za5NK22BnocoI1zJczsaJbtHQxncgat2IOW6HgHiSbUsq6h8xJGysVcu7RcjIZs6YUS6dKbj0yhVKmnMyUkp3ANZxF+KZE+GZhyJdZhfMmfLMy8J5NOG/CNxsD79mF8yZ8szPwnkM4b8I3BwPvOYXzJnxzMvCeSzhvwjcXA++RwnkTvpEMvOcWzpvwzc3Aex7hvAnfPAy85xXOm/DNy8B7PuG8Cd98DLznF86b8M3PwHsB4bwJ3wIMvI1w3oTPMPC2Sh8SWqaHhLFBjIBjDA8J48IfEhLvuJKHhPQwb2aGJEtE9ZAw5IMzpJaSg3AP3nyxjpXTyaybMZPOlfOxUiIZzyczqXLGPQstp/PJkrWpfCYTc5NmEuWYjadj6XIqW7Y26f7NQiI/S6DLPhNoqFTKxwr5ZDZjS8VEMpXI5vKlfLFkMrZYcA8yU4VMythiKRFPpEvpYtGmYpl8LlbM5QqJeD49C3ANU8I3JcKXYsiXtHDehC/NwDsjnDfhyzDwzgrnTfiyDLwXFM6b8C3IwHsh4bwJ30IMvBcWzpvwLczAexHhvAnfIgy8FxXOm/AtysB7MeG8Cd9iDLwXF877f/gYeC8hnDfhW4KB95LCeRO+JRl4LyWcN+FbioH30kofli3N9LBsmUGMgJdheFi2rPCHZcR7WSUPy+ihVpIhyZaL6GFZ2AdISC2NGoR7AOWNdTyRyWVMPJMulQvxbCafKtI3ggWbziZjhUwxljLZfMnm45lcvOgeIGZzuWK2kE3lbDFr4yadCnQ5wRoWbT6XSjkqCYcta92jEff/yrlUtlSI5YvGxGI59/+KCbdqOefzc3ROO1MuJkqxVKlQzqeAa7i88E2J8C3PkC8rCOdN+FZg4L2icN6Eb0UG3isJ5034VmLgvbJw3oRvZQbeqwjnTfhWYeC9qnDehG9VBt6rCedN+FZj4L26cN6Eb3UG3msI50341mDgvaZw3oRvTQbeawnnTfjWYuC9tnDehG9tBt7rKH1otA7TQ6N1BzECXpfhodF6wh8aEe/1lDw0ooc7oxiSbP2IHhqFfZCC1NIGg3APYryxjhWK5UzM2ngync/nMtmsseV4uZSO5xLukVki7Ujmsqm0cU+qCkn6YzxdjhdtppSJZ226uHygywkfGmVTyVTSForFbCmRsbacKCVtPmOKxULOrW4+4dCVSjadiJlcrpTKuSdbxhZiKZsupEqZ5PLANdxQ+KZE+DZkyJeNhPMmfBsx8N5YOG/CtzED702E8yZ8mzDw3lQ4b8K3KQPvzYTzJnybMfDOCedN+HIMvPPCeRO+PAPvgnDehK/AwLsonDfhKzLwLgnnTfhKDLzLwnkTvjID782VPjzZnOnhyRaDGAFvwfDwZEvhD0+I95ZKHp7QQ44NGJJsq6genoR8oIDU0taDcA8kfLGOlcuJXDyWjWUK6bItpPOZeCyZK5VMplAq25JNJm26nEglS3n3D0ehnI0X3ZOZVDKRoL8SN7ZhoMsJ1tCkyrl8wvFNZR2UGO21pVwhk87kY6lUOl+M23w5XoplSnH3uCedSuRy9C8Xs/l80f1nVQ88wq7hNsI3JcK3DUO+bCucN+HbloH3dsJ5E77tGHhvL5w34duegfcOwnkTvh0YeO8onDfh25GB907CeRO+nRh47yycN+HbmYH3LsJ5E75dGHjvKpw34duVgfduwnkTvt0YeO+u9CHC7kwPEfYYxAh4D4aHCHsKf4hAvPdU8hCBzP7WDEm2V0QPEcIaa6SW9h6EM+a+WMfS8Vg6UyyYuHvcULa5fCodSycTsUwilnLM43mbiKVLGWty+WQxUczE0tlcxsRsqZwvxvKFzDaBLid4iJCN019RmCqWYuWiNWUHtVg06XjZrVTW5LLpVNmmsgX3DxN3+LK2kEink2nHKRErJuK5bYBruI/wTYnw7cOQL/sK50349mXgvZ9w3oRvPwbe+wvnTfj2Z+A9WjhvwjeagfcBwnkTvgMYeB8onDfhO5CB90HCeRO+gxh4HyycN+E7mIH3IcJ5E75DGHgfqtRMH8pkpg8bxAj4MAYzfbhwM028D1dipsn07s2QZEdEZaZDGkyklo4chDOovljHnB23mVIpkU4VsvlyySTob6cqloqFRL6cK+VT5bSj5Jx4MpZIlwupdLyYzhayuXQ2lSza2P+M6uE+Mx1L5+LJTCKbLTjCsXw+4e6Ui+lcMp5MFtM2nynYWMGm04lsomwKuaIxuWSm7Dhkc7FSKbYPcA2PEr4pEb6jGPLlaOG8Cd/RDLyPEc6b8B3DwPtY4bwJ37EMvMcI5034xjDwPk44b8J3HAPv44XzJnzHM/AeK5w34RvLwHuccN6EbxwD7xOUmsoTmEzliYMYAZ/IYCpPEm4qifdJSkwlmb8jGZLs5KhMZUijhdTSKYNwRs0X61jWwU/kbdrabLlAf6lJ1mayGfffLWdLqXS2VHKsSpl00ZRS2UwpFbelTLKcj8XjRZtz7vWoQJcTmMqU871ZB8bYdC4RM6V8vpQvOMwmk07bUjxOv1yZLZhcpuheJufy1paz2WTJun+nlMza2FHANTxV+KZE+E5lyJfThPMmfKcx8D5dOG/CdzoD7zOE8yZ8ZzDwPlM4b8J3JgPvs4TzJnxnMfA+Wzhvwnc2A+9zhPMmfOcw8D5Xqbk6l8lcnTeIEfB5DObqfOHminifr8RckQk6hSHJLojKXIU0HEgtXTgIZ1h8sY7ZRCplk/FSLpFLm0Ixn8ka63xiLl5KJW0pnTAmni+ZVLqYcNhsPp/LubeA5VguUy7lMvHEqYEuJzBXZevcqHuJmXLky8l82S1krGBKxWI272ZLljJxE8slbLmQzjiwyUw2nkuXczbhyCXThdKpwDW8SPimRPguYsiXi4XzJnwXM/C+RDhvwncJA+9LhfMmfJcy8L5MOG/CdxkD78uF8yZ8lzPwvkI4b8J3BQPvK5WajCuZTMZVgxgBX8VgMq4WbjKI99VKTAaZgQsZkuyaqExGyMYbqaVrB+Ead1+sY5l8PJO1Np63RVuIJQrpQi6WTOVLsYR7+5MrFFKOXbKcsLFUJl1KmXQ+UcrSm6N8Mkd/Rf1FgS4nMBnpvCkkU8502UQmYdwbpUwqZhK5bDmeKpcdXJvOJmLJhINtyrG4KTiwKZu1afc/m86lUxcB1/A64ZsS4buOIV+uF86b8F3PwPsG4bwJ3w0MvG8Uzpvw3cjA+ybhvAnfTQy8bxbOm/DdzMD7FqXN9i1MzfatgxgB38rQbN8mvNkm3rcpabapKb6WIcluj6rZDtmAIrV0xyBcA+uLtc2mi9akk3HnILIp939k3GQJm81mYxnXpRdNLpXJxkrxQqyQjiXcm4RUMZ5zbzPiyVSslC7/r1G8zdNsW2cI4sVyMUe/pJHN2mI5WSi51xHu3UfWcTS2WMgnk6lEPlWmBc5m3esRZwoK+Vy26JbGXgdcwzuFb0qE706GfLlLOG/CdxcD77uF8yZ8dzPwvkc4b8J3DwPve4XzJnz3MvC+T2nTeR9T03n/IEbA9zM0nQ8IbzqJ9wNKmk5qDu9gSLIHI2o6wzZiSC09NAjXyPlibQuJQty11K59zWZN0j09NvFULmHiaXc7l8qVbKZoi7FEMlZ0Exddm50olHOZUrGUNuViIXNnoMsJ1jDh/hcTiWIybzKmXMhR717Mp1OJbN7hd/hSuVQhH0vEUqV4LJEvFfPZhOubk9ZmyiYWz90JXMOHhW9KhO9hhnx5RDhvwvcIA+9HhfMmfI8y8H5MOG/C9xgD78eVNl+PMzVfTwxiBPwEQ/P1pPDmi3g/qaT5oibpIYYkeyqq5itkQ4LU0tODcA2NL9axVLZs87mCe5aYco8T0zH7/9i7Dvg4iqu/siTbki1bltx7AYyxjXfvTleopvfeO6crYHChGLCNAQECGzDYxpheA4QQeujkCwESCDUQeu+Q0AKBJHT4ZuDm9PT0du5O90beCZrf70l7M7P/efPmzZs3s7Oz6XioKZkIy73ATWLlM+U1e+FQKhsNidXMmFxnFEuMEbc5Eklm0uHQX3J62eHxeiLVJG6Livo3J8JpuS06HnLddCSWcptDyUQiJYQoP+ITjmcyYmU1nMmkI+KWcHNzkxdKt3OYypXhUwEflCR/TxnoL38LeL0lf38zUO+nA15vyd/TBur9jKVOyDOGnJBnBxhk+FkDTshzAXdCZL2fs8QJkc7CkwY62fNd9dixzIGZU5deGMA3sJNtLVaRRP3cVDLalHGF29Isyo/G3ExKeF1isSueSTVlUtFYNBRNxiJZsfKVSmWaU+KGrOA4G3sqp5cdZOi58ZB4WusJt6g5G8l4qWhGiEksVaXTTW48lUhE01lRlngmmsk2J+LNntck6ifcJyGwqNv8FKMMXwz4oCT5e9FAf3kp4PWW/L1koN4vWzoYv2xoMH5lgEGGXzEwGL8a8MFY1vtVSwZjOWi+YKCTvdZFg3G5AxSnLr0+gG+AI9u6KeymRblePCaWDlyJHEnG4tFMMu1FE6Fouikt4QS3yVA0Go8ms02RSDwinkZFQkkvHnoxp5cdBuPmcDiWFiwKzyWSDYUyKVHBTCibEAgZ8XSrKRQNxcLRaDbuxdykK3yZuFjViCSFn5NuysTbDaDlyvCNgA9Kkr83DPSXNy0dlN40NCi9NcAgw28ZGJTeDvigJOv9tiWDkhw8XjfQyd7pqkGpTEPNqUvvDuAz9MW0dXM4FUnHEumIl0x4saZ4qjmSSIWbvFhKDGuRZFNIjLxZLxSOuvFsKpFKvZHTyx4F2tqNxJujGU9ULB2PeEIEqUwyFMlGs2nBcXMmFQp7ITcSE6gx8UwgHH2DUYbvWWqc3zNknN8fYJDh9w0Y578H3DjLev/dEuMsjei7BozzP7rKOKNQqsHi1KUPBvAZPKqtOdrkAwNt/SF8dhoPh8SoI/PF064XSadC8VAo3RxxxXJqKpRJRLxENhKKhFPpVLPATHpZN5tMJbLxn7G60qB+aMigfjTAIMMfGTCoHwfcoMp6f2zAoEplq3TajAoVVFnlKrYJuagOzS0XqMyfAH1jtxwf8/VAryLXmBWA6aocwQrZ0ghQKf+Zw/9U1stEI3xiwKp8Ynjxh6vehVyKEkO7epfL42cBX0CTivmZAZfiX8xDszIMErclh8sti08NyeJzQ7L43KAsTLmaXwTcppjqD6cPXaX1ThXgz5junzE02PZP1vkLA2MIY3t7nDKUzlS1U5zHXAirkE5BTBPjFpdMoHP5b5237JYXvM8MDQSQ6RJ59gqVI3n+twHDcCazYVChqsQ2K8WBK7fO/xkQTAPD2RZQL/8DHJTOtk8hmXO2z3/hOlg4LPpGOuZl09lwUywRavai8llMJBuLxiNp8YgomY5lvEgyHErI1xnkh6JiTWH5Kd9EOhXNQqPtpcPhSDrRnPLEI51ksxtPh5NuNhILh9xkWjwCSofj0WgyHE5H49l4QqxKJLPhuNsUiyXcaCicCJlqn/8S7VPqQFho2YSzfb40ZD+/ZJBDoeUlTjl8ZUgOX+XkoHMSgjyQE+yy6TF0Er620Un42rCT8LUBJ+GsLnISCs2eutLIfcOIxekknGVoEPqmCCehkByEgnopz826CTGiurFUNNacSIea42IczTaF02HO9vl2AN/AzukkmGqfb8tYZSrUb9QKbiVvfyzleVhBLM7V4O8G8A5Iqo2+K6ONCjkunWyjgn2ylGeWhbA42+j7AXyyg230PXCu8CMtp5NtV4g9ztVW6Az+kHuc9SP1OMstL3h+j3U4n1WWi8X4aMwz0fCd7bSrSoZlb1poCHZ7/NRhGvgd5IoGM4O+xG3J4XLL4kdDsuhhSBY9NLIol2dTerEs4I+bTOnA8oA/bvoiV2/ux02M7e0t737chMNP9ptLJtDxq2wwuJLkGDKIkGnulSTJc6UBw3C2JY+bYJuV/W5DQzANzNmGViqqGsw/buJsn+oGvsdNyxlXkky1T3VD4ccLTontVcyuXRVsGRR62jgo9DQ8KPQ0MCisCMig4KvEsexPgdPo9ArooLDCkNHpxTAoFFrm42yf3gEdFEy1T28wKHTVe0Nf8L3v5EF+axoMMlxDTBvLZb6G0RjUMnYCUzKsJQaRcmVY28A7iJgY8CWP3EvBnEaPU3f6MC8Fq8D9OOILxuXvvoZ1kENXKB10ywucziyr/apjbg/u5UKpe4w8erLP9TXgoPdjnqz0dtp0UPH6Q+5alvUDr5x/KrMHKO/Cfm3lXZS77i/KrRc0QDkPiD8mXrwBjLKUzlojkKVJvvsz9yUceLBD5rC9ttUB+X9s7rpByKVR0EBBgwQNFjRE0FBBwwQNFzRC0EhBowSNFjRG0FhB4wSNFzRB0GqCVhe0hqCJgtYUNEnQWoImC5oiaKqgtQVNE+QK8hpyzCgvXjLTG8U1EnEDibhBRNxgIm4IETeUiBtGxA0n4kYQcSOJuFFE3GgibgwRN5aIG0fEjSfiJhBxqxFxqxNxaxBxE4m4NYm4SUTcWkTcZCJuChE3lYhbm4ibRsS5RJyXi4NhXO7/9Nx/t7zQzuiUO4g1MGBlfloHcr1GJixZx4EsWD/La1D5WCH1HG9wuViRtmeCQ8rDcuHzxaHlYIXaP6sc1nksFz/3HN5JLLFI1OEZ6ojOYcWp57EjO4MVp5/tjiodK+b3nHh0qVgx/2fOY0rDCumeX48tBSumfxY+rnisgns1xheLFStoC70JxWG5RdhVb7VisNyibLS3emGspiLtvbdGIaxI0WOHN1GLJU+wLR5rTR1WrKQxzZvkjxUvcXz01vLBSmRLHmu9yTSW24lx25tCYbmd8gG8qR2xvE76E97aGCvdad/Em9YeK1yGn+O5ACuULctn8jzGSZ/0G8c7bRMnLzeJmZab1EzNTXIm5yY9k3KToIm5SdHquUnShNykaVxuEjUmN6kalZtkjchNuoblJmFDcpOyQblJmvTdpC8oQ1c+7fDY/M90u6cdoQaDDEtwrhVXxXyIT6m8MOMEwZQMJY9cK3JKhmHGjik7gdShHk7XdgK3rJA2utIDZRHJdbAmvNoSyTUsjGsiZsXcy+18lkQ8Z2PsQE3MjcutfLLTRBg7o6p3hLkzdtWI5LLpUSIN+Y02GGQ4yj4iJdJRxhEpFvARScowxj4iJdIxS0ckl43vRIpg18iIFM91sAQekeLEiJToghHJZRyR4owdKGGocbk3IXDWeR1GY+Y4/KNlOGeAuB+mc04F1mU0ZpQM3fKCJ9t4XQOezLqWejLT2OxPcxjyu16DQYbXY/dkmsPrMXb+9QPuyUgZrs/uyTSH1zfc+TkM6LoBN6AbMMtQBe6Bl1PHN2Tse13pAU9j47s5RLBrxAOenjPMG2EPeDrhAW/UBR4w3wjketMZlXIjQ43L3RE567yxYQ/YLS940jhuaMB72yTgXqtsl00sqLcpHd+EUcc3DbiO+zkpHM4PF9ZmzAN2V8121mYba+JZyO/mDQYZ3px9thPPbs7YgFsEfLYjZbgF+2wnnt0i4LMdaeg2awi2Md6S2RirwF1nTh3fytLZztpsfMczBLtGZjtb5wzzNni2szUx29mmC2Y7fCOQ623NqJTbGGpc7o7IWedtA+4JSuO4lQGvf7uAz3Zku2xnQb1N6fh2jDq+fcB13M9JccsLHqeTsoOlz3amso01oXbH++zYYJDhHdlnOyF3R8ZOsFPAZztShjuxz3ZC7k4Bn+1IQ7dDQ7CN8c6WzHY4dXwXS2c7U9n49rIEu0ZmO7vmDPNueLazKzHb2a0LZjt8I5Dr7cqolLsZalzujshZ590D7glK47iLAa9/j4DPdmS77GFBvU3p+B6MOr5nwHXcz0lxywsep5Oyl6WznSlsY0263Wxn7waDDO/NPttJu3szdoJ9Aj7bkTLch322k3b3CfhsRxq6vRqCbYz3tWS2w6nj+1k625nCxneqy2Y7++cM8wF4trM/Mds5oAtmO3wjkOvtz6iUBxhqXO6OyFnnAwPuCUrjuJ8Brz8Z8NmObJekBfU2peNJRh1vDriO+zkpbnnB43RSUpbOdiazjTXRdmdipBsMMpxmn+1EvTRjJ8gEfLYjZZhhn+1E29XbLTNQ9eYwdKmGYBvjrCWzHU4dP8jS2c5kNr6jXXaWysE5wzwDz3YOJmY7M7pgtsM3ArnewYxKOcNQ43J3RM46HxJwT1Aax4MMeP2HBny2I9vlUAvqbUrHD2XU8ZkB13E/J8UtL3icTsosS2c7a/E924lDfmc3GGR4Nv+znfhsxk4wJ+CzHSnDOfzPduJzAj7bkYZuVkOwjfFhlsx2OHX8cEtnO2ux8Z2OEewame0ckTPMR+LZzhHEbOfILpjt8I1ArncEo1IeaahxuTsiZ53nBtwTlMbxcANe/1EBn+3IdjnKgnqb0vGjGHX86IDruJ+T4pYXPE4n5RhLZzuT2MaaSALyO6/BIMPz2Gc7kcQ8xk4wP+CzHSnD+eyznUhifsBnO9LQHdMQbGO8wJLZDqeOH2vpbGcSG9+ROMGukdnOwpxhPg7PdhYSs53jumC2wzcCud5CRqU8zlDjcndEzjofH3BPUBrHYw14/ScEfLYj2+UEC+ptSsdPYNTxloDruJ+T4pYXPE4n5URLZztrso01ze12sp3UYJDhk9hnO83eSYyd4OSAz3akDE9mn+00t6u3W2ag6s1h6E5sCLYxbrVktsOp46dYOttZk43v5i7byXZqzjAvwrOdU4nZzqIumO3wjUCudyqjUi4y1LjcHZGzzosD7glK43iKAa//tIDPdmS7nGZBvU3p+GmMOn56wHXcz0lxywsep5NyhqWznYl8s50U5HdJg0GGl/DPdlJLGDvBmQGf7UgZnsk/20mdGfDZjjR0ZzQE2xifZclsh1PHl1o625nI5xA3E+wame0syxnm5Xi2s4yY7SzvgtkO3wjkessYlXK5ocbl7oicdT474J6gNI5LDXj9KwI+25HtssKCepvS8RWMOn5OwHXcz0lxywsep5Oy0tLZzhp8O9maIb/nNhhk+Fz+nWzN5zJ2gvMCPtuRMjyPfydb83kBn+1IQ7eyIdjG+HxLZjucOn6BpbOdNfg2OyUJdo3Mdi7MGeaL8GznQmK2c1EXzHb4RiDXu5BRKS8y1LjcHZGzzhcH3BOUxvECA17/JQGf7ch2ucSCepvS8UsYdfzSgOu4n5Pilhc8TiflMktnO6uzjTXxdidQX95gkOHL2Wc7cfdyxk5wRcBnO1KGV7DPduLuFQGf7UhDd1lDsI3xryyZ7XDq+JWWznZWZ+M71mUnUF+VM8xX49nOVcRs5+oumO3wjUCudxWjUl5tqHG5OyJnnX8dcE9QGscrDXj91wR8tiPb5RoL6m1Kx69h1PHfBFzH/ZwUt7zgcTop11o621nN0Gzntw0GGf6tgdnObxk7wXUBn+1IGV5nYLZzXcBnO9LQXdsQbGN8vSWzHU4dv8HS2c5qFs52bswZ5pvwbOdGYrZzUxfMdvhGINe7kVEpb7JktsNZ55sD7glK43iDAa//loDPdmS73GJBvU3p+C2MOv67gOu4n5Pilhc8TiflVktnOxPYxppkuzPZbmswyPBt7LOdZOI2xk5we8BnO1KGt7PPdpKJ2wM+25GG7taGYBvjOyyZ7XDq+J2WznYmsPGd7LIz2e7KGea78WznLmK2c3cXzHb4RiDXu4tRKe821LjcHZGzzvcE3BOUxvFOA17/7wM+25Ht8nsL6m1Kx3/PqOP/F3Ad93NS3PKCx+mk/MHS2c54vtlOBPJ7b4NBhu/ln+1E7mXsBH8M+GxHyvCP/LOdyB8DPtuRhu4PDcE2xvdZMtvh1PH7LZ3tjOdziMMEu0ZmOw/kDPOf8GznAWK286cumO3wjUCu9wCjUv7JUONyd0TOOv854J6gNI73G/D6Hwz4bEe2y4MW1NuUjj/IqOMPBVzH/ZwUt7zgcTopf7F0tjOObaxJt3u283CDQYYfZp/tpBMPM3aCRwI+25EyfIR9tpNOPBLw2Y40dH9pCLYxftSS2Q6njj9m6WxnHBvf6S57tvN4zjA/gWc7jxOznSe6YLbDNwK53uOMSvmEocbl7oicdf5rwD1BaRwfM+D1Pxnw2Y5slyctqLcpHX+SUcefCriO+zkpbnnB43RS/mbpbGcs21iTykB+n24wyPDT7LOdVOZpxk7wTMBnO1KGz7DPdlKZZwI+25GG7m8NwTbGz1oy2+HU8ecsne2MZeM7lSbYNTLbeT5nmF/As53nidnOC10w2+EbgVzveUalfMFQ43J3RM46vxhwT1Aax+cMeP0vBXy2I9vlJQvqbUrHX2LU8ZcDruN+TopbXvA4nZRXLJ3tjGEba7x2z3ZebTDI8Kvssx0v8SpjJ3gt4LMdKcPX2Gc7XuK1gM92pKF7pSHYxvh1S2Y7nDr+hqWznTFsfHtd9mznzZxhfgvPdt4kZjtvdcFsh28Ecr03GZXyLUONy90ROev8dsA9QWkc3zDg9b8T8NmObJd3LKi3KR1/h1HH3w24jvs5KW55weN0Ut6zdLYzmm2saW4323m/wSDD77PPdpoT7zN2gr8HfLYjZfh39tlOc+LvAZ/tSEP3XkOwjfE/LJntcOr4B5bOdkaz8d3cZbOdD3OG+SM82/mQmO181AWzHb4RyPU+ZFTKjww1LndH5KzzxwH3BKVx/MCA1/9JwGc7sl0+saDepnT8E0Yd/2fAddzPSXHLCx6nk/KppbOdUWxjTTwO+f2swSDDn7HPduLxzxg7wb8CPtuRMvwX+2wnHv9XwGc70tB92hBsY/y5JbMdTh3/wtLZzig2vuMxgl0js51/5wzzf/Bs59/EbOc/XTDb4RuBXO/fjEr5H0ONy90ROev834B7gtI4fmHA6/8y4LMd2S5fWlBvUzr+JaOOfxVwHfdzUtzygsfppHxt6WxnJNtYE2k32/mmwSDD37DPdiLxbxg7wbcBn+1IGX7LPtuJxL8N+GxHGrqvG4JtjL+zZLbDqePfWzrbGcnGd6TLZjs/5Azzj3i28wMx2/mxC2Y7fCOQ6/3AqJQ/Gmpc7o7IWWenMdieoDSO3xvw+isazQ5cbnnBk+0ieQx6vU3pOOSzXKweAddxPyfFLS94nE5KJaPedOVsZwTbWJPwIL9VjQYZluC8s52EV8XYCaoZO6cpGVY3cs92Eu3q7ZYZqHpzGLrKxmAb457MxlgF7jpz6ngvxjp35WxnBJtDnHAJdo3MdnrnDHNNo9N+ZtO7seNsR2YyPdsZwTjb6c2olDWNZhqXuyNy1rk24J6gNI69DHj9fQI+25Ht0seCepvS8T6MOt434Dru56S45QWP00mps3S2M5xtrIm5kN9+jQYZ7sc+24m5/Rg7Qf+Az3akDPuzz3Zibv+Az3akoatrDLYxrrdktsOp4wMsne0MZ5vtRLMEu0ZmOw05w9yIZzsNxGynsQtmO8MZZzsNjErZ2Gimcbk7ImedBwbcE5TGcYABr39QwGc7sl0GWVBvUzo+iFHHBwdcx/2cFLe84HE6KUMsne0M4zuloN0J1EMbDTI8lH2205wZytgJhgV8tiNlOIx9ttOcGRbw2Y40dEMag22Mh1sy2+HU8RGWznaG8b3I3mUnUI/MGeZReLYzkpjtjOqC2c4wxtnOSEalHNVopnG5OyJnnUcH3BOUxnGEAa9/TMBnO7JdxlhQb1M6PoZRx8cGXMf9nBS3vOBxOinjLJ3tDGUba0Ltnu2MbzTI8Hj22U7IHc/YCSYEfLYjZTiBfbYTcicEfLYjDd24xmAb49Usme1w6vjqls52hrLNdrwue7azRs4wT8SznTWI2c7ELpjtDGWc7azBqJQTG800LndH5KzzmgH3BKVxXN2A1z8p4LMd2S6TLKi3KR2fxKjjawVcx/2cFLe84HE6KZMtne0M4RtrUpDfKY0GGZ7CPttxU1MYO8HUgM92pAynss923NTUgM92pKGb3BhsY7y2JbMdTh2fZulsZwjf6QrNBLtGZjtuzjB7eLbjErMdrwtmO4wjkOcyKqXXaKZxuTsiZ51DAfcEpXGcZsDrDwd8tiPbJWxBvU3peJhRxyMB13E/J8UtL3icTkqTpbOdwWxjTbTdTrZoo0GGo+yznWgmytgJYgGf7UgZxthnO9FMLOCzHWnomhqDbYzjlsx2OHU8YelsZzDfeztdtpNtnZxhXhfPdtYhZjvrdsFsZzDjbGcdRqVct9FM43J3RM46rxdwT1Aax4QBr3/9gM92ZLusb0G9Ten4+ow6vkHAddzPSXHLCx6nk7KhpbOdQWxjjdfuTLbpjSYZZp/teN50xk6wUcBnO1KGG7HPdrx29XbLDFS9OQzdho3BNsYbWzLb4dTxTSyd7Qzi28nWZWeybZozzJvh2c6mxGxnsy6Y7QxinO1syqiUmzWaaVzujshZ580D7glK47iJAa9/i4DPdmS7bGFBvU3p+BaMOr5lwHXcz0lxywsep5OylaWznYGMn0iB/G7daJDhrRv5cbcJ+AxF1nubxjYBM+EamVVIg7JVY7CN3raWzCo49XI7w4aeo022M6DjXWlQGw0Z1O0bDTK8vQGDukPADaqs9w7dBpUNa0dLDCqnXu4UcIMq22Qnyw1qA+N3YiC/OzcaZHhnA511Z0Zl2yXgxlnKcBcD0/tdAr4eb4Oh39USQ8+p47sFfIlEtsluBvrL7gFfBpR2YndDTpwpvdydUS/3CLhe+tkzt7zgcdqzPQOu47KN9zQwQePUw650COuBQ+jFw6FQLCx5iqddL5JOheKhULo54qbcZCqUSUS8RDYSioRT6VSz4D/pZd1sMpXIxn/Ggvzu1WiQ4b2ITlAu83sxdv69A+4QShnuTXSCcmW4N/O6vXwW3MPp2k7glhkIdrnk227GtQ9oP3ZPhbEhPfjAHzJdIs+pYpRvn06MjoWEvg9jZ96XsYNAuUrclk7qgidkl/LcrJsIuUk3lorGmhPpUHM8mQ1nm8LpcGflWkjZOeW6nyG57peTa1WOunpEdssM0HjunxuRD5B90ITB2MeAW7VPwJcYOts53BLqXS6PBwbcJZeKeaCB6XbSkFFIaoytW17wDjAki2ZDsmguY+ApxLMpvfj10FVqU1IF+DOmA9cMDbYdkAPfgQZsKWN7e5wylA5FtUPPcJwSZVBIpyCmCfvNJRPoYKV0Mxy3vOAdaMggpjQznAIwXqFyJM8pA4bhN8yGQYWqEtusFEem3DqnG4NpYDjbAuplGgzUnW2fQjLnbJ8MwPLCYdE30jEvm86Gm2KJULMXDUej2Ug2Fo1H0tmmSDIdy3iRZDiUyMTcrBfPZGJN4VQsmk2kU9EsNNpeOhyOpBPNKa8pFE02u/F0OOlmI7GwmPymw7F0OhyPRpPhcDoaz8YTYsIqpsFxtykWS7jRUDgRMtU+GTDT5BoUCq1sQExbBoWsjYNC1vCgkDUwKFwbkEHBV4ljP72Uk+U0OgcFdFC41pDROYhhUCi0zMfZPgcHdFAw1T4H/w8tP87ILT8eQi0/uuUF37V/zucg5WIxLmUa2V2gZFhpiQzLxTo04O0hO8yhBgb2mYacnJkGl0UPMSSLWYZkMcvgsqgpvbgu4MuipnTgeguWRQ81sCzK2N7e9d3Lojj8ZL+5ZAIdv9kmZ8CHGjKIsw3OgCXPsw0YhhssWRY9lNEpmtMYTANzg6EZ1pwuWBblbJ/DGGfA1zPOgE21z2FE+3Bv8OJsn8MN2c/DGeRQaKWGUw5HGJLDEUUskwd5ICfYZdNj6CQcaaOTcKRhJ+FIA07CjV3kJJS5O5bVyM1lxOJ0Em40NAjNLcJJKHeXLWf7HNXIN7BzOgmm2ucog6stXm72zX0sncd2LF3c49Sdo9lse7xdG0lcedSfHLDHOx0Dk1zzNpR7zOtVGXwej+F0VLobyhyP87obyvWW9go+j/O7G8r1elrQoxZ0N5TrXWVBjzq2u6Fc71ILGmqhqVUPbg/9OD5Gm2xVqOMag8/j8bYo1Al8jEZtVagTLFCoFlsU6kQ+RmO2KtSJFijUSbYo1Ml8jMZtVaiTLVCoVlsU6hQ+RhO2KtQpFijUqbYo1CI+RpO2KtQiCxRqsS0KdRofo822KtRpFijU6bYo1Bl8jKZsVagzLFCoJbYo1Jl8jKZtVagzLVCos2xRqKV8jGasfUhogUIt636k4XrvW/BIY7ktPf9sNkY911aFOtuCnr/CFoU6h0+hPFsV6hwLFGqlLQp1Lp9ChWxVqHMtUKjzbFGo8/kUKmyrQp1vgUJdYItCXcinUBFbFepCCxTqIlsU6mI+hbJ2n9HFFijUJbYo1KV8CmXtPqNLLVCoy2xRqMv5FMrafUaXW6BQV9iiUL/iUyhr9xn9ygKFutIWhbqKT6Gs3Wd0lQUKdbUtCvVrPoWydp/Rry1QqGtsUajf8CmUtfuMfmOBQl1ri0L9lk+hrN1n9FsLFOo6WxTqej6Fsnaf0fUWKNQNtijUjXwKZe0+oxstUKibbFGom/kUKmurQt1sgULdwsmjPOhngqCxOUB5xok8PkOezCBf+pfvk8tXgOVbm/JFO/lulHydRb6BIDeNy32+cmum3E0nN2rJvTVyO4R8gi0fOsrnRHJpX67GygU0ueYhp6lyZiGdQTl+S5Mre4msmAo9mJVbHQjF1QgS65hf0AFTv2M8YKpHTudw4JKhqY5nwxlFfO2U29VqsKF+0WcU3drdUHacUXRbd0PZcUbR7d0NZccZRXd0N5QdZ//c2d1Qdpypc1d3Q9lxVs3d3Q1lxxkw93Q3lB1nq/y+u6HsOLPk/7obyo6zQP7Q3VB2nLFxb3dD2XF2xR+7G8qOMyHu624oO86EuL+7oew4a+GB7oay4wyDP3U3lB1nA/y5u6HseOf+we6GsuNd9oe6G8qOd8T/0t1Qdrx7/XB3Q9nxTvMj3Q1lx7vCj3Y3lB3v4D7W3VB2vNv6eHdD2fHO6BPdDWXHu5h/7W4oO95xfLK7oex4d/Cp7oay4528v3HyWCVA+jht75ZJZsehRuvBXAFT7525ZYWf3xXjrKfkzWWoq3ovTuLJV3mC/HqQCRlOY5bhbQZkeFvAZbg2swxvNyDD2wMuw6nMMrzDgAzvCLgMpzDL8E4DMrwz4DKczCzDuwzI8K6Ay3AtZhnebUCGdwdchpOYZXiPARneE3AZrsksw98bkOHvAy7Dicwy/D8DMvy/gMtwDWYZ/sGADP8QcBmuzizDew3I8N6Ay3A1Zhn+0YAM/xhwGU5gluF9BmR4X8BlOJ5ZhvcbkOH9AZfhOGYZPmBAhg8EXIZjmWX4JwMy/FPAZTiGWYZ/NiDDPwdchqOZZfigARk+GHAZjmKW4UMGZPhQwGU4klmGfzEgw78EXIYjmGX4sAEZPhxwGQ5nluEjBmT4SMBlOIxZho8akOGjAZfhUGYZPmZAho8FXIZDmGX4uAEZPh5wGQ5mluETBmT4RMBlOIhZhn81IMO/BlyGA5ll+KQBGT4ZcBk2MsvwqcZg71Y0IcMGZhn+rTHgGwlR4MENRx0i8GCHPHPYbTol26w+d/20kPczgp4V9Jyg5wW9IOhFQS8JelnQK4JeFfSaoNcFvSHoTUFvNf6M8XZjDrQy91+CjkVxzxBxzxJxzxFxzxNxLxBxLxJxLxFxb+fiZODuaC760ALXBssqTj491+Xa8BrPGRcu+d3KKLt3mPgSdXSh/rwD9McxoUdee97LlcO7jEYVyuFdg/1omoF+JDfEcn+whHGTrfcuY33fM9Tm73WB7r/HKIf3DcnhfYO6v7YB3b/dgO4zbo723mes798NtfnfTeu+kMPTAZWDxKhirusUzo9SCbsxlanf/Pwiz89+zR3M/fBO7n4o6s24wb7dRvNy6/sPQ/3wH10wBv2DUQ4fGJLDBwbHoMkGxqC7DIxBjJv6vQ8Y6/uhoTb/sAt0/0NGOXxkSA4fGdT9tQzo/t0GdJ/xZQzvI8b6fmyozT/uAv/rmYDKQWJw+19rMvtfkwz4X/cw98PfG/C/GF/oafdiS7n1/cRQP/ykC8agTxjl8E9DcvinwTFoooEx6P8MjEGMLxF5/2Ss76eG2vzTLtD9Txnl8JkhOXxmUPfXMKD7fzCg+4wvf3mfMdb3X4ba/F9d4H89G1A5SAxu/2s1Zv9rdQP+173M/fCPBvwvxhcI271IV259PzfUDz/vgjHoc0Y5fGFIDl8YHIMmGBiD7jMwBjG+tOh9wVjffxtq8393ge7/m1EO/zEkh/8Y1P3xBnT/fgO6z/iyqfcfxvr+11Cb/7cL/K/nAioHicHtf41l9r/GGfC/HmDuh38y4H8xvrDc7sXdcuv7paF++GUXjEFfMsrhK0Ny+MrgGDTGwBj0ZwNjEONL0t5XjPX92lCbf90Fuv81oxy+MSSHbwzq/mgDuv+gAd1nfLnd+4axvt8aavNvu8D/ej6gcpAY3P7XSGb/a5QB/+sh5n74FwP+F+MBCe0OCii3vt8Z6offdcEY9B2jHL43JIfvDY5BIwyMQQ8bGIMYD2Xwvmes7w+G2vyHLtD9Hxjl8KMhOfxoUPeHG9D9RwzoPuNhGt6PjPV1Bpppc4k71jGo+0IOLwRUDhKD2/8ayux/DTPgfz3K3A8fM+B/MR7I0u5gknLrW2GoH1YMND8GQd7LlUMPQ3LoMdDcGDTEwBj0uIExiPEQGK8HY5tXGmrzyi7Q/UpGOVQZkkOVQd0fbED3nzCg+4yH93hVjG1ebajNq7vA/3qxMZhykBjc/tdAZv9rkAH/66/M/fBJA/4X4wFQ7Q5CKre+PQ31w55dMAb1ZLRHvQzJoZfBMajRwBj0lIExiPHQKa8XY5v3NtTmvbtA93szyqHGkBxqDOp+gwHd/5sB3Wc8LMyrYWzzWkNtXtsF/tdLjcGUA6xzBXOdX2aoc3PyZyyTfL7SaIc8X7WEz9cs4fN1S/h8wxI+37SEz7cY+ZRz175O+49q1zvtAzf/TxuQMzePz1jA47MW8PicBTw+bwGPL1jA44sW8PiSIRvPwWM4GjeCa4rfbtz/LVw+7FDIILanbAL0VfqIOWVfQXWC+gnqL6he0ABBDYIaBQ0UNEjQYEFDBA0VNEzQ8IFO+4Og+wzseDh0XyKujojrR8T1J+LqibgBRFwDETeMiBuei5MOnVinyS8AwMBtTBsHBl4ZPfkHymLEwJ//j8SNLhOw58u9MtXIsJokn8JIrBGMK1MjLVmRsYXPgZbwOcgSPgdbwucQS/gcagmfHPayOfGTV91uBRavjpdrPxlXNLw+htqGu86MKyReX0vqzLji4tVZUmfGFRyvnyV1ZlwR8vpbUmfGFSav3pI6M65YeQMsqTPjCpjX0EV1djsXPHUxjHGuNMrQU3yIyywHFbzhfLx7o5jmstlMNgHrXMGs72MY6kytzHLzOZaBz2jSTWSi0ZhJPscx8NncHI0lM/Emk3yO52j3VDSTDcdCJvmcwMBnsimSzTaFkyb5XI2BzybPzTSFYlmTfK7OwGei2W2KxuMpk3yuwcCnl42H04lks0k+J3K0e3PGTaW9hOSt0en4NUj4FUj49Uf41Uf4tUf4lUf4dUf4VccxYJG8V2Xnr+Fi+3BwPRZcjwPX48H1BHC9GrheHVyvAa4n5q7XFP8nCVpL0GRBUwRNFbS2oGkDf17kl3KsdDoG7jWYNYO/yC9DxBi297OfpmSr3vZwhVw8QSFBYfwwQSb2RnEeERci4sK5OBiqeYXVrlHLNRAulyOYdT2P8QFJiAXrZ3mFGTtBV3beSd2dl+y8ESGXJkFRQTHceSNEp2wi4qJEXKwLOu8kxs4bYey8TYydN8rYeWOWdt61ujsv2XnjQi4JQesIWhd33jjRKRNE3DpE3Lpd0HnXYuy8ccbOm2DsvOswdt51Le28k7s7L9l51xNyWV/QBoI2xJ13PaJTrk/EbUDEbdgFnXcyY+ddj7Hzrs/YeTdg7LwbWtp5p3R3XrLzThdy2UjQxoI2wZ13OtEpNyLiNibiNumCzjuFsfNOZ+y8GzF23o0ZO+8mlnbeqd2dl+y8mwq5bCZoc0Fb4M67KdEpNyPiNifituiCzjuVsfNuyth5N2PsvJszdt4tLO28a3d3XrLzbinkspWgrQVtgzvvlkSn3IqI25qI26YLOu/ajJ13S8bOuxVj592asfNuY2nnndbdecnOu62Qy3aCthe0A+682xKdcjsibnsibocu6LzTGDvvtoyddzvGzrs9Y+fdgbETKGW6z2FWVBF6d+N143XjdeN143XjdeN143XjBR5P+oO79W6bB+wKrncB1zuD653A9Y7gegdwvT243g5cbwuutwHXW4PrrcD1luB6C3C9ObjeDFxvCq43Adcbg+uNwPV0cL0huN4AXK8PrtcD1+uC63XAdQJcx8F1DFxHwfXFNW3XF4HrC8H1BeD6fHB9Hrg+F1yvBNfngOsV4PpscL0cXC8D10vB9Vng+kxwvQRcnwGuTwfXp4HrxeB6Ebg+FVyfAq5bwfXJ4PokcH0iuG4B1yeA6+PB9XHg+p3atuu3wfVb4PpNcP0GuH4dXL8Grl8F16+A65fB9Uvg+kVw/QK4fh5cPweunwXXz4Drp8H138D1U+D6SXD9V3D9BLh+HFw/Bq4fBdePgOuHwfVfwPVD4PpBcP1ncL1W37brSeB6TXA9EVyvAa5XB9ergesJ4Ho8uB4HrseC6zHgejS4HgWuR4LrEeB6OLgeBq6Hgush4HowuB4ErgeC60Zw3QCuB4DrenDdH1z3A9d14LovuO4Drg+va7s+DFzPAdezwfUscD0TXB8Krg8B1zPA9cHg+iBwnQXXGXCdBtcpcN0MrpPg+kBwfQC43h9c7weu9wXX+4DrvcH1XuB6T3C9B7jeHVzvBq53Bde7gOudwfUmYB0OPsqGj7rho/AtwDV8egafrsGnb9uAa7hgDxf04YL/DuAarhHCNUS4xhgG13D7OdyeDrevx8A13PEKd8TCHbPrgmu4yQ5uwoOb9DYE13BfD9z3o/YFPeX8HHYUv3cStLOgXQTtKmg3QbsL2kPQnoL2ErS3oH0E7StoP0H7CzpA0IGCkoKaBaUEpQVlBGUFHSToYEEzBB0i6FBBMwXNEjRb0BxBhwk6XNARgo4UNFfQUYKOFnSMoHmC5gtaIOhYQQsFHSfoeEEnCGoRdKKgkwSdLKhV0CmCThW0SNBiQacJOl3QGYKWCDpT0FmClgpaJmi5oLMFrRB0jqCVgs4VdJ6g8wVdIOhCQRcJuljQJYIuFXSZoMsFXSHoV4KuFHSVoKsF/VrQNYJ+I+haQb8VdJ2g6wXdIOhGQTcJulnQLYJ+J+hWQbcJul3QHYLuFHSXoLsF3SPo94L+T9AfBN0r6I+C7hN0v6AHBP1J0J8FPSjoIUF/EfSwoEcEPSroMUGPC3pC0F8FPSnoKUF/E/S0oGcEPSvoOUHPC3pB0IuCXhL0sqBXBL0q6DVBrwt6Q9Cbgt4S9LagdwS9K+g9Qe8L+rugfwj6QNCHgj4S9LGgTwT9U9Cngj4T9C9Bnwv6QtC/Bf1H0H8FfSnoK0FfC/pG0LeCvhP0vaAfBP0oyBkk9FpQD0GVgqoEVQvqKaiXoN6CagTVCuojqK+gOkH9BPUXVC9ogKAGQY2CBgoaJGiwoCGChgoaJmi4oBGCRgoaJWi0oDGDfu5TMvRw2sL03H+3zNCbFS/tdtvdVW931bloY4XujBM0XtAEQasJWl3QGoImClpT0CRBawmaLGiKoKmC1hY0bdDPD8TqgM5VgP9DlL6IfJ6gkKCwoIigJkFRQTFBcUEJQesIWlfQeoLWF7SBoA0FTRe0kaCNBW0iaFNBmwnafFCuoPw7WoPaKpp/R4uICxFxYSIuQsQ1EXFRIi5GxMWJuAQRtw4Rty4Rtx4Rtz4RtwERtyERN52I24iI25iI24SI25SI24yI2zwXJ5Wpn0Mr05jc9RYi75aCthK0taBtBG0raDtB2wvaQdCOgnYStLOgXQTtKmg3QbsL2kPQnoL2ErS3oH0E7StoP0H7CzpA0IGCkoKaBaUEpQVlsLJtQVRkSyJuKyJuayJuGyJuWyJuOyJueyJuByJuRyJuJyJuZyJuFyJuVyJuNyJudyJuDyJuTyJuLyJubyJuHyJuXyJuPyJufyLuACLuQCIuScQ1E3EpIi5NxGVK6AxZkfcgQQcLmiHoEEGHCpopaJag2YLmCDpM0OGCjhB0pKC5go4SdLSgYwTNEzRf0AJBxwpaKOg4QccLOkFQi6ATBZ0k6GRBrbgzZImKHETEHUzEzSDiDiHiDiXiZhJxs4i42UTcHCLuMCLucCLuCCLuSCJuLhF3FBF3NBF3DBE3j4ibT8QtIOKOJeIWEnHHEXHHE3EnEHEtRNyJRNxJRNzJRFxrCZ3hFJH3VEGLBC0WdJqg0wWdIWiJoDMFnSVoqaBlgpYLOlvQCkHnCFop6FxB5wk6X9AFgi4UdJGgiwVdIuhSQZcJulzQFYJ+JehK3BlOISpyKhG3iIhbTMSdRsSdTsSdQcQtIeLOJOLOIuKWEnHLiLjlRNzZRNwKIu4cIm4lEXcuEXceEXc+EXcBEXchEXcREXcxEXcJEXcpEXcZEXc5EXcFEfcrIu7KEjrDVSLv1YJ+LegaQb8RdK2g3wq6TtD1gm4QdKOgmwTdLOgWQb8TdKug2wTdLugOQXcKukvQ3YLuEfR7Qf8n6A+C7hX0R0H3Cbpf0AO4M1xFVORqIu7XRNw1RNxviLhribjfEnHXEXHXE3E3EHE3EnE3EXE3E3G3EHG/I+JuJeJuI+JuJ+LuIOLuJOLuIuLuJuLuIeJ+T8T9HxH3ByLuXiLuj0TcfUTc/UTcAyV0hj+JvH8W9KCghwT9RdDDgh4R9KigxwQ9LugJQX8V9KSgpwT9TdDTgp4R9Kyg5wQ9L+gFQS8KeknQy4JeEfSqoNcEvS7oDUFvCnoLd4Y/ERX5MxH3IBH3EBH3FyLuYSLuESLuUSLuMSLucSLuCSLur0Tck0TcU0Tc34i4p4m4Z4i4Z4m454i454m4F4i4F4m4l4i4l4m4V4i4V4m414i414m4N4i4N4m4t0roDG+LvO8IelfQe4LeF/R3Qf8Q9IGgDwV9JOhjQZ8I+qegTwV9Juhfgj4X9IWgfwv6j6D/CvpS0FeCvhb0jaBvBX0n6HtBPwj6UXaEwYjpt4mKvEPEvUvEvUfEvU/E/Z2I+wcR9wER9yER9xER9zER9wkR908i7lMi7jMi7l9E3OdE3BdE3L+JuP8Qcf8l4r4k4r4i4r4m4r4h4r4l4r4j4r4n4n4g4n4k4qSiFdsZKkTeHoIqBVUJqhbUU1AviSGoRlCtoD6C+gqqE9RPUH9B9YIGCGoQ1ChooKBBggYLGiJoqKBhgoYLGiFopKBRgkYLGoM7Q8XgjhXpQcRVEnFVRFw1EdeTiOtFxPUm4mqIuFoirg8R15eIqyPi+hFx/Ym4eiJuABHXQMQ1EnEDibhBRNxgIm4IETeUiBtGxA0n4kYQcSOJuFFE3GgibkwJnWGsyDtO0HhBEwStJmh1QWsImihoTUGTBK0laLKgKYKmClpb0DRBriBPUEhQWFBEUJOgqKCYoLighKB1BK0raD1B6wvaAHeGsURFxhFx44m4CUTcakTc6kTcGkTcRCJuTSJuEhG3FhE3mYibQsRNJeLWJuKmEXEuEecRcSEiLkzERYi4JiIuSsTFiLg4EZcg4tYh4tYl4tYj4tYn4jYAnaG/0zVfVGLEMvphDk4+KwCfGw7OCby+W+Bdwmc+9GBmuKk342kbg/n4gj1c4o4tIIdyeeeU6VqOGSXgrnMFY50nW1LnHox1nmJJnSsZ6zy1i+rslhe8tRnlJw2RiTpzDz7THDv4dC3h07OEz5AlfIYdO2xHxOGzHTf24q0zbpNy+asWtm1ST/62bnLs0MmoJXzGLOEzbgmfCUv4XMcSPte1hM/1LOFzfUv43MASPje0hM/plvC5kSV8bmwJn5tYwuemlvC5mSV8bm4Jn1tYwueWlvC5lSV8bm0Jn9tYwue2lvC5nSV8bm8JnztYwueOlvC5kyV87mwJn7sY4jPIzyx37aI6u+UFbzdG+VVZ8ixrd8cOPvewhM89LeFzL0v43NsSPvexhM99LeFzP0v43N8SPg+whM8DLeEzaQmfzZbwmbKEz7QlfGYs4TNrCZ8HWcLnwZbwOcMSPg+xhM9DLeFzpiV8zrKEz9mW8DnHEj4Ps4TPwy3h8whL+DySmU/u/aODezvO6N789Z4b8HoPMVTvowJe76GG6n20Y6Y/cq/FH8Moy/G97ajzPIY6//w5wLQ3urcddne+YwefCyzh81hL+FxoCZ/HWcLn8ZbweYIlfLZYwueJlvB5kiV8nmwJn62W8HmKJXyeagmfiyzhc7ElfJ5mCZ+nW8LnGZbwucQSPs+0hM+zLOFzqSV8LrOEz+WW8Hm2JXyusITPcyzhc6UlfJ5rCZ/nWcLn+ZbweYElfF5oCZ8XWcLnxZbweYklfF5qCZ+XWcLn5ZbweYUlfP7KEj6vtITPqyzh82pL+Py1JXxeYwmfv7GEz2st4fO3lvB5nSV8Xm8JnzdYwueNlvB5kyV83mwJn7dYwufvLOHzVkv4vM0SPm+3hM87LOHzTkv4vMsSPu+2hM97LOHz95bw+X+W8PkHS/i81xI+/2gJn/dZwuf9lvD5gCV8/skQnz2Y+fwzwCr3/RjP0LsiVcx1fpCxzvJbDFxY4aF8WJGhdvSThxw7+PyLJXw+bAmfj1jC56OW8PmYJXw+bgmfT1jC518t4fNJS/h8yhI+/2YJn09bwuczlvD5rCV8PmcJn89bwucLlvD5oiV8vmQJny9bwucrlvD5qiV8vmYJn69bwucblvD5piV8vmUJn29bwuc7zHxynyMl1zknGDhH6l0L6j3GQL3fs6Deaxqo9/uOHf3x75bw+Q9L+PzAEj4/tITPjyzh82NL+PzEEj7/aQmfn1rC52eW8PkvS/j83BI+v7CEz39bwud/LOHzv5bw+aUlfH5lCZ9fW8LnN5bw+a0lfH5nCZ/fW8LnD5bw+aMlfEpAG/issITPHpbwWWkJn1WW8FltCZ89LeGzlyV89raEzxpL+Ky1hM8+lvDZ1xI+6yzhs58lfPa3hM96S/gcYAmfDZbw2WgJnwMt4XOQJXwOtoTPIZbwOdQSPodZwudwS/gcYQmfIy3hc5QlfI62hM8xlvA51hI+x1nC53hL+JxgCZ+rWcLn6pbwuYYlfE60hM81LeFzkiV8rmUJn5Mt4XOKJXxOtYTPtS3hc5olfLqW8OlZwmfIEj7DlvAZsYTPJkv4jFrCZ8wSPuOW8JmwhM91LOFzXUv4XM8SPte3hM8NLOFzQ0v4nG4JnxtZwufGlvC5iSV8bmoJn5tZwufmlvC5hSV8bmkJn1tZwufWlvC5jSV8bmsJn9tZwuf2lvC5gyV87mgJnztZwufOlvC5iyV87moJn7tZwufulvC5hyV87mkJn3tZwufelvC5jyV87msJn/tZwuf+lvB5gCV8HmgJn0lL+Gy2hM+UJXymLeEzYwmfWUv4PMgSPg+2hM8ZlvB5iCV8HmoJnzMt4XOWJXzOtoTPOZbweZglfB5uCZ9HWMLnkZbwOdcSPo+yhM+jLeHzGEv4nGcJn/Mt4XOBJXweawmfCy3h8zhL+DzeEj5PsITPFkv4PNESPk+yhM+TLeGz1RI+T7GEz1Mt4XORJXwutoTP0yzh83RL+DzDEj6XWMLnmZbweZYlfC61hM9llvC53BI+z7aEzxWW8HmOJXyuNMRnD2Y+zwV8lvuN0A0H21Hn8xjrfFk/M3Uey1zn89vro+eWEW7rV6L8Yr7y83YcWHJbxPywdhrYiXaN01g7D+yUjsQprF06h5WIZjti7Tqw07rrYqzdBpbRD0LtsXYfWFafciHWHgPL7J+RNqw9B5bd10MKa6/yscKZn8G8vVmwshLN24cJS6B5+zJgKdu4H8ZKdxrLGzuoA19eZ7HGDSLq6HYOa/wgUl5uZ7Am0FheIls61mqDfNsxXirW6oM0OhErDWsNHVY8ki0Fa+KgAroaKR5rzUEF9b6pWKxJg4roQ25xWGsNKqo/usVgTS4Oy2uKFcaaUixWvClVCGtq8VjpUEyPtXYpWPFwSIc1rT1WuAxb6DkgjM39V9huecG7oIKPz/0ZbfYBA/ls9oED+Wx2ciCfzW4eyGezUwP5bHZ6IJ/Nzgzks9nZgXw2+6CBfDb74IF8NnvGQD6bfchAPpt96EA+mz1zIJ/NnjWQz2bPLtV/1cxN5zDOTQ9jnJsezjg3PYJxbnok49x0LuPc9CjGuenRjHPTYxjnpvMY56bzGeemCxjnpscyzk0XDrRj3e5CRt/uOEbf7nhG3+4ERt+uhdG3O5HRtzuJ0bc7mdG3a2X07U5h9O1OZfTtFjH6dosZfbvTGH270xl9uzMYfbsljL7dmYy+3VmMvt1SRt9uGaNvt5zRtzub0bdbwejbncPo261k9O3OZfTtzmP07c5n9O0uYPTtLmT07S6yxLe7iNG3u5jRt7uE0be7lNG3u4zRt7uc0be7gtG3+xWjb3clo293FaNvdzWjb/drRt/uGkbf7jeMvt21jL7dbxl9u+sYfbvrGX27Gxh9uxsZfbubGH27mxl9u1sYfbvfMfp2tzL6drcx+na3M/p2dzD6dncy+nZ3Mfp2dzP6dvdY4ttdzOjb/Z7Rt/s/Rt/uD4y+3b2Mvt0fGX27+xh9u/sZfbsHGH27PzH6dn9m9O0eZPTtHmL07f7C6Ns9zOjbPcLo2z3K6Ns9xujbPc7o2z3B6Nv9ldG3e5LRt3uK0bf7G6Nv9zSjb/cMo2/3LKNv9xyjb/c8o2/3AqNv9yKjb/eSJb7dJYy+3cuMvt0rjL7dq4y+3WuMvt3rjL7dG4y+3ZuMvt1bjL7d24y+3TuMvt27jL7de4y+3fuMvt3fGX27fzD6dh8w+nYfMvp2HzH6dh8z+nafMPp2/2T07T5l9O0+Y/Tt/sXo233O6Nt9wejb/ZvRt/sPo2/3X0bf7ktG3+4rS3y7Sxl9u68ZfbtvGH27bxl9u+8YfbvvGX27Hxh9ux8ZfTuH8f23Csb333owvv9Wyfj+WxXj+2/VjO+/9WR8/60X4/tvvRnff6spDUvr29WWiqXx7fqUjuXr2/XtDJaPb1c3iM+369dJLMq36995rA6+XX05WMi3G1AeVjvfrqFcLODbNQ7i8KF+xho4iMcfk1iDBvH5doMZsJRvN2SQHb7dZYy+3dBBfL7dMMazDYYznm0wgvFsg5GMZxuMYjzbYDTj2QZjGH07l9G38xh9uxCjbxdm9O0ijL5dE6NvF2X07WKMvl2c0bdLMPp26zD6dusy+nbrMfp26zP6dhsw+nYbMvp20xl9u40YfbuNGX27TRh9u00ZfbvNGH27zS3x7S5n9O22YPTttmT07bZi9O22ZvTttmH07bZl9O22Y/Tttmf07XZg9O12ZPTtdmL07XZm9O12YfTtdmX07XZj9O12Z/Tt9mD07fZk9O32YvTt9mb07fZh9O32ZfTt9mP07fZn9O0OYPTtDmT07ZKMvl0zo2+XYvTt0oy+XcYS3+4KRt8uy+jbHcTo2x3M6NvNYPTtDmH07Q5l9O1mMvp2sxh9u9mMvt0cRt/uMEbf7nBG3+4IRt/uSEbfbi6jb3cUo293NKNvdwyjbzeP0bebz+jbLWD07Y5l9O0WMvp2xzH6dscz+nYnMPp2LYy+3YmMvt1JjL7dyYy+Xaslvt2vGH27Uxh9u1MZfbtFjL7dYkbf7jRG3+50Rt/uDEbfbgmjb3cmo293FqNvt5TRt1vG6NstZ/Ttzmb07VYw+nbnMPp2Kxl9u3MZfbvzGH278xl9uwsYfbsLGX27ixh9u4sZfbtLGH27Sxl9u8sYfbvLGX27Kxh9u18x+nZXWuLbXcno213F6Ntdzejb/ZrRt7uG0bf7DaNvdy2jb/dbRt/uOkbf7npG3+4GRt/uRkbf7iZG3+5mRt/uFkbf7neMvt2tjL7dbYy+3e2Mvt0djL7dnYy+3V2Mvt3djL7dPYy+3e8Zfbv/Y/Tt/sDo293L6Nv9kdG3u4/Rt7uf0bd7wBLf7ipG3+5PjL7dnxl9uwcZfbuHGH27vzD6dg8z+naPMPp2jzL6do8x+naPM/p2TzD6dn9l9O2eZPTtnmL07f7G6Ns9zejbPcPo2z3L6Ns9x+jbPc/o273A6Nu9yOjbvcTo273M6Nu9wujbvcro273G6Nu9zujbvcHo273J6Nu9ZYlvdzWjb/c2o2/3DqNv9y6jb/ceo2/3PqNv93dG3+4fjL7dB4y+3YeMvt1HjL7dx4y+3SeMvt0/GX27Txl9u88Yfbt/Mfp2nzP6dl8w+nb/ZvTt/sPo2/2X0bf7ktG3+4rRt/ua0bf7htG3+5bRt/uO0bf7ntG3+4HRt/uR0bdzBtvh2/2a0berGMzn2/UYzOfbVQ7m8+2qBvP5dtWD+Xy7noP5fLteg/l8u96D+Xy7msF8vl3tYIfNt+sz2GHz7foWg1Wkb1dXHFZRvl2/YrGK8O36F49V0LerLwWrgG83oDQsrW/XUCqWxrdrLB3L17cb2BksH99u0GA+325wJ7Eo325I57E6+HZDy8FCvt2w8rDa+XbDy8UCvt2IwRw+1M9YIwfz+GMSa9RgPt9uNAOW8u3GWOLbXcPo241l9O3GMfp24xl9uwmMvt1qjL7d6oy+3RqMvt1ERt9uTUbfbhKjb7cWo283mdG3m8Lo201l9O3WZvTtpjH6di6jb+cx+nYhRt8uzOjbRRh9uyZG3y7K6NvFGH27OKNvl2D07dZh9O3WZfTt1mP07dZn9O02MOTb9cj95+LzQYfPT/xNRdfU2S0veNdW8MmvqbeZOlcw1/m3FXbweZ0lfF5vCZ83WMLnjZbweZMlfN5sCZ+3WMLn7yzh81ZL+LzNEj5vt4TPOyzh805L+LzLEj7vtoTPeyzh8/eW8Pl/lvD5B0v4vNcSPv9oCZ/3WcLn/Zbw+YAlfP7JEj7/bAmfD1rC50OW8PkXS/h82BI+H7GEz0ct4fMxS/h83BI+n7CEz79awueTlvD5lCV8/s0SPp+2hM9nLOHzWUv4fM4SPp+3hM8XLOHzRUv4fMkSPl+2hM9XLOHzVUv4fM0SPl+3hM83LOHzTUv4fMsSPt+2hM93LOHzXUv4fM8SPt+3hM+/W8LnPyzh8wNL+PzQEj4/soTPjy3h8xNL+PynJXx+agmfn1nC578s4fNzS/j8whI+/20Jn/+xhM//WsLnl5bw+ZUlfH5tCZ/fWMLnt5bw+Z0lfH5vCZ8/WMLnj5bw6fSwg88KS/jsYQmflZbwWWUJn9WW8NnTEj57WcJnb0v4rLGEz1pL+OxjCZ99LeGzzhI++1nCZ39L+Ky3hM8BlvDZYAmfjZbwOdASPgdZwudgS/gcYgmfQy3hc5glfA63hM8RlvA50hI+R1nC52hL+BxjCZ9jLeFznCV8jreEzwmW8LmaJXyubgmfa1jC50RL+FzTEj4nWcLnWpbwOdkSPqdYwudUS/hc2xI+p1nCp2sJn54lfIYs4TNsCZ8RS/hssoTPqCV8xizhM24JnwlL+FzHEj7XtYTP9Szhc31L+NzAEj43tITP6ZbwuZElfG5sCZ+bWMLnppbwuZklfG5uCZ9bWMLnlpbwuZUlfG5tCZ/bWMLntpbwuZ0lfG5vCZ87WMLnjpbwuZMlfO5sCZ+7WMLnrpbwuZslfO5uCZ97WMLnnpbwuZclfO5tCZ/7WMLnvpbwuZ8lfO5vCZ8HWMLngZbwmbSEz2ZL+ExZwmfaEj4zlvCZtYTPgyzh82BL+JxhCZ+HWMLnoZbwOdMSPmdZwudsS/icYwmfh1nC5+GW8HmEJXweaQmfcy3h8yhL+DzaEj6PsYTPeZbwOd8SPhdYwuexlvC50BI+j7OEz+Mt4fMES/hssYTPEy3h8yRL+DzZEj5bLeHzFEv4PNUSPhdZwudiS/g8zRI+T7eEzzMs4XOJJXyeaQmfZ1nC51JL+FxmCZ/LLeHzbEv4XGEJn+dYwudKS/g81xI+z7OEz/Mt4fMCS/i80BI+L7KEz4st4fMSS/i81BI+L7OEz8st4fMKS/j8lSV8XmkJn1dZwufVlvD5a0v4vMYSPn9jCZ/XWsLnby3h8zpL+LzeEj5vsITPGy3h8yZL+LzZEj5vsYTP31nC562W8HmbJXzebgmfd1jC552W8HmXJXzebQmf91jC5+8t4fP/LOHzD5bwea8lfP7REj7vs4TP+y3h8wFL+PyTJXz+2RI+H7SEz4cs4fMvlvD5sCV8PmIJn49awudjlvD5uCV8PmEJn3+1hM8nLeHzKUv4/JslfD5tCZ/PWMLns5bw+ZwlfD5vCZ8vWMLni4b47IH4DLvRSCQTC2W8sJd0Q4nmeJMbaWqOxr241xRvSofi4XAmHonHEs2JmJvwIuGMl21KhLM57ImMdX6pi+rslhe8l3vwyW/6YDvauYpRfq9YotvVjHV+1ZI692Ss82uW1LkXY51ft6TOvRnr/IYlda5hrPObltS5lrHOb1lS5z6MdX7bkjr3ZazzO5bUuY6xzu9aUud+jHV+z5I692es8/uW1Lmesc5/t6TOAxjr/A9L6tzAWOcPLKlzI2OdP7SkzgMZ6/yRJXUexFjnjy2p82DGOn9iSZ2HMNb5n5bUeShjnT+1pM7DGOv8mSV1Hs5Y539ZUucRjHX+3JI6j2Ss8xeW1HkUY53/bUmdRzPW+T+W1HkMY53/a0mdxzLW+UtL6jyOsc5fWVLn8Yx1/tqSOk9grPM3ltR5NcY6f2tJnVdnrPN3ltR5DcY6f89Y50rn5z0+z+YqvJagyYKmCJoqaG1B02Q5gjxBISkLQRFBTYKigmKC4oISgtYRtK6g9QStL2gDQRvm6r6RoI0FbSJoU0GbCdpc0BaCthS0laCtBW0jaFtB2wnaXtAOgnYUtJOgnQXtImhXQbsJ2l3QHoL2FLSXoL0F7SNoX0H7Cdpf0AGCDhSUFNQsKCUoLSgjKCvoIEEHC5oh6BBBhwqaKWiWoNmC5gg6TNDhgo4QdKSguYKOEnS0oGMEzRM0X9ACQccKWijoOEHHCzpBUIugEwWdJOhkQa2CThF0qqBFghYLOk3Q6YLOELRE0JmCzhK0VNAyQcsFnS1ohaBzBK0UdK6g8wSdL+gCQRcKukjQxYIuEXSpoMsEXS7oCkG/EnSloKsEXS3o14KuEfQbQdcK+q2g6wRdL+gGQTcKuknQzYJuEfQ7QbcKuk3Q7YLuEHSnoLsE3S3oHkG/F/R/gv4g6F5BfxR0n6D7BT0g6E+C/izoQUEPCfqLoIcFPSLoUUGPCXpc0BOC/iroSUFPCfqboKcFPSPoWUHPCXpe0AuCXhT0kqCXBb0i6FVBrwl6XdAbgt4U9JagtwW9I+hdQe8Jel/Q3wX9Q9AHgj4U9JGgjwV9Iuifgj4V9Jmgfwn6XNAXgv4t6D+C/ivoS0FfCfpa0DeCvhX0naDvBf0g6EdBspNVCOohqFJQlaBqQT0F9RLUW1CNoFpBfQT1FVQnqJ+g/oLqBQ0Q1CCoUdBAQYMEDRY0RNBQQcMEDRc0QtBIQaMEjRY0RtBYQeMEjRc0QdBqglYXtIagiYLWFDRJ0FqCJguaImiqoLUFTRPkCvIEhQSFBUUENQmKCooJigtKCFpH0LqC1hO0vqANBG0oaLqgjQRtLGgTQZsK2kzQ5oK2ELSloK0EbS1oG0HbCtpO0PaCdhC0o6CdBO0saBdBuwraTdDugvYQtKegvQTtLWgfQfsK2k/Q/oIOEHSgoKSgZkEpQWlBGUFZQQcJOljQDEGHCDpU0ExBswTNFjRH0GGCDhd0hKAjBc0VdJSgowUdI2ieoPmCFgg6VtBCQccJOl7QCYJaBJ0o6CRBJwtqFXSKoFMFLRK0WNBpgk4XdIagJYLOFHSWoKWClglaLuhsQSsEnSNopaBzBZ0n6HxBFwi6UNBFgi4WdImgSwVdJuhyQVcI+pWgKwVdJehqQb8WdI2g3wi6VtBvBV0n6HpBNwi6UdBNgm4WdIug3wm6VdBtgm4XdIegOwXdJehuQfcI+r2g/xP0B0H3CvqjoPsE3S/oAUF/EvRnQQ8KekjQXwQ9LOgRQY8KekzQ44KeEPRXQU8KekrQ3wQ9LegZQc8Kek7Q84JeEPSioJcEvSzoFUGvCnpN0OuC3hD0pqC3BL0t6B1B7wp6T9D7gv4u6B+CPhD0oaCPBH0s6BNB/xT0qaDPBP1L0OeCvhD0b0H/EfRfQV8K+krQ14K+EfStoO8EfS/oB0E/CpIORYWgHoIqBVUJqhbUU1AvQb0F1QiqFdRHUF9BdYL6CeovqF7QAEENghoFDRQ0SNBgQUMEDRU0TNBwQSMEjRQ0StBoQWMEjRU0TtB4QRMErSZodUFrCJooaE1BkwStJWiyoCmCpgpaW9A0Qa4gT1BIUFhQRFCToKigmKC4oISgdQStK2g9QesL2kDQhtJfEbSRoI0FbSJoU0GbCdpc0BaCthS0laCtBW0jaFtB2wnaXtAOgnYUtJOgnQXtImhXQbsJ2l3QHoL2FLSXoL0FyW/Ny++4y2+ky++Py297HyhIfpNafu9ZfktZfqdYfgNYfl9XfrtWfhdWfnNVfs9UfitUfodTfuNSfj9SfptRfvdQflNQfq9PfgtPfmdOfsNNfh9NfntMftdLfjNLfo9KfutJfkdJfqNIfv9HflunRZD8Joz83or8lon8Toj8Bof8voX8doT8LoP85oH8noA8q1+egy/PmJfnt8uz0eW54/JMb3letjyLWp7zLM9QlucTy7N/5bm68sxaeR6sPGtVnmMqzwiV52/Ksy0vFyTPZJTnHcqzBOU5ffIMPHm+nDy7TZ6LJs8ck+d5ybOy5DlU8owneX6SPJtInvsjz9SR59XIs2DkOSvyDBN5Pog8e0OeayHPjJDnMcizDuQ5AvIdffn+u3y3/D5B8p1o+b6xfJdXvicr30GV73fKdyfle4nynT/5Pp18V02+BybfsZLvL8l3g+R7N/KdFvm+iHwXQ/qr8h0CuT9f7n2X+8rlPmu5h1nuw5X7UuU+TblvUe7je1OQ3Ocl9z3JfUByX4zcJyL3Tch9BPK5unzOLJ+7yueQ8rmcfE4ln9vI5xhyXV+uc8t1X7kOKtcF5TqZXDeS6yhyXUHOs+W8U87D5LxE+uk9fh76HbnPWIa1nLaQMwtOZS5d7suV+1Tlvk25j1Hu65P73OS+L7kPSu4Lkvtk5L4RuY9C7iuQz9nlc2f5HFY+l5TP6eRzK/kcRz7XkOv8ct1brgPLdVG5TijXzcYKGidovCA575bzUDkvk/MUufd9TUGTnI5BjhkqNOT+D3p3o2GHP3rNZjDfQE3aiNz/SxqObpk4W7ZUWzhZc9/pmrTlmrTzNWmXadJ+rUm7QZN2mybt95q0BzRpj2jSntKkvaBJe12T9lbu/3MPLVny1893vRymvZ37P7ryyY2Ob75ne5j2Ue7/0vG93WuvXON5mPZx7n8Pp77f3n8+9EGY9kPu/6bfHbrZczPOvQym/ahJUy+oUGkVmrQemrRKTVqVJq1ak9ZTk9ZLk9Y7l3bnMW9/PXTu5INhWo0mrVaT1keT1leTVqdJ66dJG5xLo3RiSC6N0olJGrmspUmbrEmbokmbqklbW5M2TZMWzaW98MDbR+zR/ObZMC2ukVlCk7aOJm1dTdp6mrT1NWkbaNK20LTtlpq23Vsjs300aftq0vbTpO2vSTtAk3agJu1QTdvO1shsjibtME3a4Zq0IzRpR2rS5mrSjtO07fGatl2mkdlyTdrZmrQVmrRzNGkrNWnnatKu0LTtVRqZXa1J+7Um7RpN2m80addq0n6rSbtV07a3adr2IY3M/qJJe1iT9ogm7VFN2mOatMc1aS9o2vZljcxe0aS9qkl7TZP2uibtDU3am5q0DzRt+6Gmbb/TyOx7TdoPmrQfNWnqIQvpu2nSemjS6nJpVNvW59IomQ3QpDVo0ho1aQM1aYM0aYM1aWNyaVTbjs2lUW0b0sgsrEmLaNKaNGlRTVpMkxbXpG2iadvNNTLbQpO2pSZtK03a1pq0bTRp22rSdtO07e6atj1YI7MZmrRDNGmHatJmatJmadJma9Lma9p2oUZmx2nSjteknaBJa9GknahJO0mTdoambZdo2vZSjcwu06Rdrkm7QpP2K03alZq0qzRpN2na9ncamd2qSbtNk3a7Ju0OTdqdmrS7NGn3a9r2AU3bPquR2XOatOc1aS9o0l7UpL2kSXtZk/aepm3/oZHZB5q0DzVpH2nSPtakfaJJ+6cm7UtN236ladvayp//UzLro0nrq0mr06T106T116TVa9JG5NKoth2dSyN9FE3aWE3aOE3aeE3aBE3aapq0qbk0qm3XzqVRbTtdI7ONNGkba9I20aRtqknbTJO2uSZtJ03b7qqR2W6atN01aXto0vbUpO2lSdtbk5bStG1a07ZHa2R2jCZtniZtviZtgSbtWE3aQk3aIk3bnq6R2RmatCWatDM1aWdp0pZq0pZp0i7QtO2Fmra9XiOzGzRpN2rSbtKk3axJu0WT9jtN2h80bXufRmb3a9Ie0KT9SZP2Z03ag5q0hzRpT2ra9ilN276tkdk7mrR3NWnvadLe16T9XZP2D03aF5q2/a9GZl9q0r7SpH2tSftGk/atJu07TVp17iE41bY9c2lU2w7NpVEyG6ZJG65JG6FJG6lJG6VJG61Jm5hLo9p2zVwaJbNJmrS1NGmTNWlTNGlTNWlra9Km5dKOXjH69PeiW7d7Juzm0t4ZtNNFx/dZ84d25fX8+f9l146+fcS7PfZuh6lJi2nSEpq09TRpG2jSNtekbalJ206TtoMmbRdN2m6atP00aQdo0po1aWlN2kxN2mxN2pGatKM0aUfn0l6bddurtZ8+eBVMOy2XRu1nuFGDebMm7S5N2j2atOdyaQcteK/vXlc+eARMez2XdsXQ5OXv//B6H5j2nqYOX2jSHu3vz8tjmrSnNGlPa9Je1qS9qkl7U5P2tibtQ03ax5q0f2nSvtCkfalJ+1qTVlHvn1apSavWpPXSpPXVpPXTpO3f6J92oCZthibtUE3aLE3aHE3aXE3a0Zq0eZq0BZq04zVpLZq0xZq00zVpSzVpyzVpF+bSTp3wecPN156/OkzLDvK/72BN2kxN2mxN2tGatHmatOM0aSdo0k7WpJ2iSTtTk7ZUk7Zck7ZCk3a+Ju1CTdrFuTTKzlcP9k/rlUt77JwnH/rN4mQaptVo7uujua9Oc1+9Jq1BgzlQc99gzX1DNfeN0KSN0mCO0dw3TnPfBM19a2jS1tRgrqW5b4rmvrU193matLAGs0lzX0xzX0Jz33qatA00mNM1922suW9TzX1baNK20mBuo7lvO819O2ju21mTtqsGc3fNfXtq7ttbc99JmvteGULfp/Z6J0f//L8m91tt7JZbQOSywPTcb7e84NUAXG78uJvI1DjtAzP/4RqAaQA/pPCrzOD/dK60DBe3tMd3ULl1ud/glYH8PSoNbv6/JJfWO5euro/NXdcgPBPtDnnillsjwX8PUDcZNmlpS6vgKzui8Dc1g5/vk5uZwQ8p/M3N4IcV/hYtJtrecxX+lkbwQymFv1UO32mH7YXj0XAoHg2F0hk3mY7GsolwzA03N4UTqWbPDTeF4ulYMuy6mXAmFXHT0URTOpNMNIWzzclEVGFvTWKHM80CqikZjTd72WQ06zZHYvFwMhuLpZPpRCQTa3LTXirqpUJeNh5PNjUlU00Jz8tmEk3ZeB57GyNyadObbc3g5/V+OyP44SaFvz3AZ/xmRV4vdzCDn5fPjmbw8+27Uw7fMSCbnVuM6E7e5uxiBj9v83c1g59V+LuZwU8r/N2N4Ht53dwjhw91x4uHQ6FYWJ7lEk+7XiSdCsWF9WyOuCk3mQplEhEvkY2EIuFUOtUcj8STXtbNJlOJbPxndIW9pxHew/m23Qvg842H4bxd3puQjVteyNu0ffyxOy1+hb0vgR1KhlNuIusmm+LJWCbeJIY7V1w0xzPZaCjZLAa+UNrzvExE/All0pFEczrqNUczsVBTsygu36b7tZhoUy8/hu/PjB9NCuc2Go0p/AOY8Zubo7GkkKfCP5AZP5yKZrLhWN7WJ5nxk02RbLYpnFT4zcz4TZ6baQrF8rqZYsZPNLtN0Xg8rz9pZnzht4XTiWSzws9wy6c546bSXkLN+bI5fFWGDKrsg5jLzoVEBSrPcdrPaR1Ufi3ilduvrEDlQX6gfNT8Ucnu4JaOvNYTadDG4LRKIk6VQ2EdwIh1ICNWkhGrmRErxYiVZsRS/dpsX4vkx9GDjeCH4wp/hhF8N78+eIgJfK/NdzwU4Dt8/OfxZwL8CgP4s8zIP48/24x88vOCOTl8E9iHmZFN3gc73Ax+fl5whBn8vI96JMBn1M28bZhrhv88/lFm8BMK/2gz+Hkf+Bgz+Hkfcp4Z/LwPPN8Ivpfnf0GLCf0M5W3bsUb4D+Xtz0Ij/Ifz/B9nBj/P//FG8CN5/BPM4OfXbVrM4Oft/4lm8PP2/yQz+Hnf6mQj+E35OXirEfxoXn9OMYOfXwM51Qx+fk16kRn8vP4vNoOf1//TzODn9f90M/h5/+cMM/h5/2SJGfy8f3KmGfz8+HuWGfy8/7DUDH7+mcYyM/h5+7ncDH7efp5tBD+W9x9WmMHP289zzODn7edKM/h5+3muGfy8/TzPDH7efp5vBj9v3y4wg5+3bxeawc/bt4vM4KflyyZyT9WLA37Go/aiMfpbrtrnpfaEqTJg2dUgnnGuli5mTR+WX4t4NbGmD8tT/GD5wDV9mdaT4LWeSMNt2JMopydRTj2Rhv2zcrBWMGKdxoi1nBGLs45LGbGWMGItY8Q6nRFrASMWp+w5+9A5AcVqZcTi1AlO2XPq1yJGLM6+zakTpzJicdro8xixgjo+Kr/XrG/lRuuIslVQab1A2dCnwqES/YZ8S1/19QFtuDifCn2dtufWR86fndp+ztzMkY7mBhnUZmkcHzThVaC03kXUwXEKC/bzIgSLHXjIWx3ChPdWEFjUhhqszFDmVT48QAzVVtgRnp777ZYVvHAx9YDld9UkgjIS1CRCyaeXGfmEKhA+5KcXIR+sw7jtKpy2jlwNsGD+XqCOMD+8VvfDuJdz/+udjv1IbSCvINIqiTglX8n7s6husG2wnppph4hXrJ6q8msdk/2mTU8pvaAGsxqnYztzbjoqpl0p21ZDpCkstQkQ6inM3xvUEeaH1+p+GPeP3P96p6NOYz2tIeoD46Cevp27rvGpz/Tcb7esEItR4xTuB1BOnJuoi+0Hqvxax6TetfUDqp0oe6JkV0vwWk+k4UWfWqKcWqKceiINO6LlYC1nxDqVEWsxI9Y5AcVawoi1jBHrdEasBYxYZzFicep9EOWlGwdLxZKBU1dXMmKdwYjFqaucdWxlxApq376QEWshI5Z6wIf9TIXvOG2+Eh7vp+d+u2WFn+dusDxVDxgHy69FvPLy0+YrUXKlfFolnz5m5JPnpw/BTx9CPqot+xJpCkuttcA5A8zfB9QR5ofX6n4YpxqzHmHKgOcMfYn6wDg4Z1AfzMN+qcKToSvaAZan+IZxsPxax2S/cbV6QfX/GqdjOzPKxy2mXSG/qi3riDSF1S/3G+opzN8X1BHmh9fqfhg3Hekp1Gmsp3VEfWAc1NN1kJ7CtsF6aqQdvGzReqrKr3VM9ps2PaX0og8hxxqnYzszysctpl0hv6ot+xFpCit3Fmc7PYX560AdYX54re6HcdsjPYU6jV+c6kfUB8ZBPVUfxazxqc/03G+3rNAUodqSDz/m1RH1xP0MyppPr8NF9zNVfq3TUS9M9LP+iB8/PVCyqyd4rSfSsI7UE+XUE+XUE2l4XlMO1mJGrAWMWKcyYp3FiNXKiLWEEWspIxanTixixDqZEescJizKPpfD1womvmRYyYjF2bcvZMTitIWc/XEZIxZnO17EiMWpE5yy5+rbDnMdOXViOSNWUO0EJ1+/BJ+JS++7x7RV2x9PY8TirOP5AeWL05/grCN+PgDnlhW5/zVOx77HOM/OVKDyVD1gHCy/FvHKy0/bPJuSa39Crkp2Awhe64k0PM8eQJQzgCinnkjDY0Y5WIsZsRYwYnHWcQkj1jJGrJWMWJyyv5ARq7sdS8O6iBGLUycWMWItZ8TitF/nMGJxyp5TVzllH1T7xamrnPq1lBGLsx059YuzD3Hq1wpGrFZGLM46BtWX46wjpz/Ryoj1S/DlzmfECqqfw+ljdvsT/xt9qJURi5MvLv2S13hdtRy+zmXiS4ZWRixOH0CNtXi/m8KXwewaWqjoPbZ4Dc3IHqwCa2jU3roap6MeMsrHK6adIb+qLRuINIWV+zZuuz1hMP8AUEeYH16r+2Hcxjmh1CNMGfCesAaiPjBOyVfuCVuvR/u6wbbBemqyHWB5im8YB8uvdUz2G1erF9Qaeo3TsZ0Z5eMW066QX9WWjUSawlIfzoR6CvM3gDrC/PBa3Q/jdkR6CnUa62kjUR8YB/V0a6SnsG2wnppph+L3gqvyax2T/aZNTym9oMapGqdjOzPKxy2mXSG/qi0HEmkKK/c96nZ6CvM3gjrC/PBa3Q/j9kd6CnUa6+lAoj4wDurpnrkf/R3//lmqnab8MSxDeB/uD0ba28u4xfYHVX6tY7J/tvWHxiLlquQz0Ih80tli9Afyq9pyEJGmsHLfSG7XH2D+gaCOMD+8VvfDuDmoP8C+g/vDIKI+MA72hxnIbsO2wXpqpB1cN1usnqryax2TdrJNTym9oMa/GqdjOzPykymmXSG/qi0HE2kKK/e97nZ6CvMPAnWE+eG1uh/GHYf0FOo0fodnMFEfGAf19Jjcjxqf+kzP/XbLChmPaks+/KRbQ8iaDz+UqCHaiw+/Oa7wh5rBjyr8YUbw4/n2HW4EvykvnxFm8NMKf6QZ/cnzP8oIfjj/gfvRRvAzef7HGMGP5PHHGsFvzvffcUbwE3n9H29GPvn2nWAEP9uk8FczI588/6ub4T9v/ycCfM61CIU/yQi+G1byWNNpC5VEnVT5yhdZA+Sv8PmvsHCaKqsWYZny+6i6Qf7xvG9NwA+UgR/WmiVi1RBpJtp0oqbesPw6Da+4HjLgszE6KxMZFjFincSItYIJi/Jty+HrOEa+BjHxRfm/5WANYcSqZMKSAX/Iqxy+hjLxJa+HBRRrOCPWCEaskYxYoxixRjNijWHCkgF/YKUcvsYy8nU2I1/jmPiS1+MZsbjGDnk9gRFrNUas1ZmwZMBrp0HB2jSHZXa9K5Iwu94VTppd74qkza53NYXNrndFYmbXuyIp5aur8VCVAXULjm9884pI0e+IqfJrEa+8/LTN70YifrB8VL9UshtF8FpPpOE+OoooZxRRTj2Rhvf4lYN1HiNWKyPWWYxYSxixFjFiLWDEWsqItZgR65yAYrUyYp3OiMUle2rcDoqucvbHlYxYQe2P5zJicfahoMr+DEasVkYszrGW00Zzyr6VESuo+sXpm3C2Yysj1i/BTlzIhCWv8Ry2HL5aGPkawsQXJ5YMx7fw8TWUkS8u2ctwMiMWp07gtfRysCqZsGTg0gkZTmLEOoERi1O/OPni0tUg28K+jHxx6ipnO3La1aDKi1NX8dpqUPo2p/26iBGL0/86jRGLc02B0yfnnCtwrj0q/16tYw8HaRW5/2afAbidfgYw3Aw/2mcAwwm5UvthGflJF9POkF/VlqOJNIWlnuXDvf0w/yhQR5gfXqv7YdxZuYarR5gy4L39o4n6wDglX7m3f3Fl+7rBtsF6aqYdiv82pCq/1jHabzydXowk5Ejphbq3nkjDPn2x7UW1Pd77Vg7WckasUxmxFjNinRNQrCWMWMsYsU5nxFrAiHU2IxZnH+Jsx/MYsVoZsVYyYnH2bU794uxDnHb1lyD7pYxYnDZa2ULqPSpG/8Ol3nNixM+/czBGIwtYPt6Lo9Kp/woLp6myahEWc908Xd10czfoh+O9vRTWmBKxqHfjTLTpaE29Yflm3wVsCpl9F7ApavZdwEhW6fw4IM8KJLsJRtoyXvRZKqr8WsSrqT41AfGD5YPnQ6sRvNYTaXjv3mpEOasR5dQTaXjcLgfrPEasVkassxixljBiLWLEWsCIdTYj1gpGLE7ZB1VXVzJiLWbE4tQvTpuznBHrlyD7pYxYnHU8J6BYrYxYpzNiccleXuN9uUHR1VZGLE4fgBOre9zuHrdtGTu6x+3ucbt73P7flH1QdfVcRixOeXHaHE7Zn8GI1cqIxTluB9VGtzJiBVW/OH1fznZsZcT6JdiJC5mwKpyO+3PKwRrNiMW1Ti6vxzBhyYD3HpfDV19Gvlpa+LBOZsQ6iQlLXo91+LD+12Uvr/G7E+VgDWHEGsqEJQOnvMYz8cWpqzJw9qGg6n1Q6/i/bgs5+ZKhe+ywf+yQ4UQmLHnNueeBS17yehgjXycw8sU11srAOT5yyiuIY4cMFzFicc75TmPE4nymw7kOwLk+wbk/R60pqL1eE0BaRe4/dV68LGd67rdbXkhXoPJUPWAcLL8W8crMj6eT6wRCrtR594z8pCoQPuRndUI+qi0nEmkKS52TCd9vg/lXB3WE+eG1uh/GfVT18/96hCkDfr+NOisdxin5yvfb3qtqXzfYNlhPzbRDqOj321T5tY7RfuPp9ILq/5ReqHup9sLjfrHtRWEtYcQ6hxHrVEas5YxY5zFiLWbEWhFQvhYxYi1gxLqQEWshI9ZFjFic8lrGiMXZH1cyYnHqPact5GzH0xixOG0Op04sZcTilH0rIxYnX2czYnHqBKdvwjlutzJiBdV+ceoXZ38Mqo3mxGplxDqdEUvJXs1X4PymIvff8DfgIhWoPFUPGAfLr0W88vLTNtej5Lo6IddSvi+meFXXMA2W09Xf8ZJhOSPWqYxYixmxzgko1hJGrGWMWKczYi1gxOL6NpIMrYxYnP1xJSMWp361MmKdxYjFqV+cfYjTrnLqBKddDWrf5uyPnH3oPEasVkasX4J+LWXE4vQB1FjbP5cG/W14HglMg+XofH54v8pXR9xXkftv9hu+iaLP61Dl1xIyMeHzr1mkXJXsJhG81hNpeO/KJKKcSUQ59UQaHpvKwTqPEauVEessRqwljFiLGLEWMGKdzYi1ghGLU/ZB1dWVjFiLGbE49YvT5ixnxPolyH4pIxZnHc8JKFYrI9bpjFhcspfX+LyOoOhqKyMWpw/AiRXUcbuVEYvTB+C00Zz+RCsjVlD1q3vc/t/o290+ebd+4bRuv3DV6VcQ/UIZOOUVVF09lxGLU16cNodT9mcwYrUyYnGOHUG10a2MWEHVL07fl7MdWxmxfgl24kImrAqn4x6ncvg6npGv0Ux8yeu+jFicz4c45TWMka+TW/iwTmLCktdjHT4sLp2QAb/bHATZc/Zt7v7I1Yfk9RgmLBk4++MvQb/weUPlYA1hxBrKhCUDp7zGM/HFaQtl4LTRQdX7oNbxf32s5eRLhm7fxP6xQ4YTmbDkNadPziUvec3pk5/AyBfXWCsD5/jIKa8gjh0yXMSIxbmmcBojFudzK851Js71r0WMWGrNSu1V7QvSKnL/a5yOtk6WMz332y0reEWfN6TKr3U6jlV8/LTt8x3odJRrX0KuSnaDCF7riTQ8Nx5ElDOIKKeeSMPPfMvBWs6IdSoj1mJGrHMCirWEEWsZI9bpjFgLGLHOZsTi7EOc7XgeI1YrI9ZKRizOvs2pX5x8cbYjJ1+cdoJTJzjbcSkjFqe9x988xz7B9Nxvt6zQ1KR8E+jLKJ+qxqF9E56yvXgFKs9xaL9OlV+LeOXlp82vo9oNygf7dYMJXuuJNNyGg4lyBhPl1BNpuG+Wg3UmIxYnX8uZsOR1L4cHi7uOCxixljJincOIdTojFqe8VjJiXcCIdTYj1mJGLE7ZL2HEWsSIxVnHCxmxFjJiqXU+7FvIMD33XwyH4Xg0HIpHQ6F0xk2mo7FsIhxzw81N4USq2XPDTaF4OpYMu24mnElF3HQ00ZTOJBNN4WxzMhEz6zs0JWocenzlwfdCCn+IGfywwh9qBj+i8IeZwW9S+KPN4EcV/hgz+Hn9HGsGP67wzZx94OX1f5IZ/KTCX8sMflrhTzaDn1H4U8zgZxX+VCP4IVfhr20GP2/fppnBz9s31wx+3r55ZvDz9i1kBj9v38Jm8PP2LWIGP2/fmszg5+1b1Ax+3r7FzOA3K/y4Gfy8/UyYwc/bz3XM4Oft57pG8MN5+7meGXxP4a9vBj9vnzcwg5+3zxuawc/bt+lm8PP2bSMz+Hn7s7EZ/Lz92cQMft7+bGoGP6XwNzODn7dvm5vBz9u3Lczg5+3blkbwI3n7s5UZ/Lz92doMft7+bGMGP+8fbmsGP+8fbmcGP28/tzeDn7efO5jBz/uHO5rBz9vnnczg5+3zzmbw8/Z5FzP4efu8qxn8vH3ezQx+3j7vbgY/b5/3MILflPc/9zSDn7f/e5nBz9v/vc3g5+3/Pmbw8/Z/XzP4efu/nxn8vP3f3wx+3v4fYAY/b/8PdNpCG3Y40yweJTQlo/FmL5uMZt3mSCweTmZjsXQynYhkYk1u2ktFvVTIy8bjyaamZKop4XnZTKIpG8/zniSxywlevl81m5CLl83bhRTAr2DjP57HTxtp1zb8jBH5pPN2OUu0bSiSjjYn3Vg2lkzGs2IQDaXFv6jQmmxTKJkIp5JCi9LNmWRzOJUIpdKhdDgTF7YmE05EM5m2Mesgbr3xXFd+83JubpOBOnv5YCCjatTeM3K/1fc8ZZjV0pbnYJAO8y+r/fm/LG9errw60A4OKEcGVecqE+0lnkNUoPIch97Do8qvRbzy8tO2h6cK8YPlg/fwVBO81qM0GfAz3WqinGqiHArrIkasBYxYZzNiLWbEWsaItYgRawkjFmcdT2fECqp+tTJirWDEWsmIxalfrYxYZzFiceoXZx9azojFqROcdlXt9atxOo6FfGNz1FNjbdLpGFQa9LsrUFoK5N+6pS0fDpXoN6xTbymLhjZcnA/zA/2mZoDv5zPIoOTYE6Rz+jgKv8YMfljJvrfTXqa4TjU+slLp1H+FhdNUWbVOR7mb8A+pukH+cX/pDfiBMvDD6l0iVg2RZqJNe2rqDcuv0/BK1QPPbyh7RPnfKn+Nhi+Yvz9RtrpXybAWpDHKMKSTIeyLqvy+gM90pvmog7adA6ee+fuhHJTchqJ827a0yQHrYG8fLAf9HoriKgEeDGbnjKt2HFB1KnUcgLJtRmmdtXsyYNuAZS6DbOvn0dpCJVEnrEN+awuVIB3mf6VXW3kv5677gDL7asqsQ3zD/DJs29I+fz9Qt0oiT1/Eo8r/Zo4v2X4NufajZKf4qUH3/y/psqpTqboM2xHzpjCV7uC29WuXj0G7DGpo4xmXV6eph/p9IFGe4r0e5ZVBtfEAEM+4xlX0d8ZU+bWIV+ZxKO/DDED8YPko2yJl2Cd3PXNOMr1J8rAjj5qZ6YFE2R9cQ/h6BKfywLww1AOWHJ98uNll2KKl4304KFFWI5775sZAaU7+i5ZFsXrJUON0rDNjE6WKVRlVfq1j0ky1qUx/xA+WTw8kH0Mq3FzhdFTXSqJMxa9qywFEmsLKWZ12pgvmh3oM88NrdT+Mq8rpVr3Tsdvt1NKeB6pLwjglX6mnP2iW7w9taZ9WTZSp0npq0npr0qDLqnRApdWC+2ah+/oQmJKHnXu34fnpGmxvNdz3dzrqvp8t8sPaBmHB+wcgrIYCWDsjLHh/A8JqLIC1C8KC9zcirIEFsA5DWPB+fMzYoAJYhyMseD/+LNTgAlhHICx4Pz6Gc0gBrLkIC96PjwYbWgDrKIQF78fHcA4rgHU0woL346PBhhfAOgZhwfuHI6wRBbDmISx4/wiENbIA1m4IC94/EmGNKoA1A2HB+9W9dQQWHp/NvF5W/Pisyq9FvJoan0c7HeUK5YMfW44heK0n0rDdGkOUM4Yoh8JqZMQayIg1iBFrMCPWEEasoYxYwxixhjNijWDEwnar0Hi9a8vP/3XjtboP6i7MVwnyUGM0xPDzByqd4v2CLRDPVJmUjzm7pX0aXMLF/iBcbsQ+OVyKHYDSoI+J7T5cpm1AaX1AmqoP9DGrUX12y8WbXe5xXdhefrLC817qv+MUtxxILenq5rWdLQdiqWWoVbfk4maKqQcs3/SSi5JFo0YWZo4lihS9/ISPv2w0JAuli4XmBfgRD+X7NxL54XLVQZm54qHJxvN3TR7UC2SFZgizU4fyDUC/G3zYmo7y4ROxlHuB+YBYMGA+dMthVPmUGVHX1US8DNS0qR6VWerJIfD+wZpyGsssp5Eox+wpHG1P0s2cktH21JWaqsI6qfLxiWIqnfqvsHCaKqvW6dhGJswAVTddO0MXtpgp/dASscyerNLWpkM09Ybl12l4peoBn95BO/c5WOJe2Ls9NmUrzO7mCUeL1UdVflft/C125wHl2qp761GaDPirANQugJ5EORTWckascxmxljFiLWLEWsCIxVlHznbkrOOpjFicdVzKiHU2I9ZZjFiLGbFWMmItYcTi1AnO/sjZhzh1glNepzNincOIxSn70xixOGW/ghGLU16ctrCVEYtTXkG1ha2MWJw255fgM3HqBOe4zSV7eY1Prg6K3nPK/gxGLE6956xjKyMWpw/AKa8LGbGKeTuWmter/NQbBdS61C/ljYImlI/jjYImFFfp0G8USOzn0XY3/DaCDGbXY8OhClQerqODyq9FvDK3f37Nitp+RK17KtkNJ3itJ9LGg2uYBssZTpRTT6ThcbscrKWMWGczYp3FiLWYEWslI9YSRixOnVjGiLWAEYtTJzjldTojFqe8TmPE4pTXuYxYnLq6iBHrl9COKxixOOXFOQ61MmJxyiuo41ArIxanvefUL06bw9kfOXWC02fikr28xmswQdF7TtmfwYjFqfecdWxlxAqq/3UhI5Zag6FeVcFb5Kk57DBNOfD+YUVgUfNhlZ96tUW31kO92qLWHgy94hHStQf1ekxn1nqU3DyUD6/1QNs2wgfLQb89FOe31oP3LWVyC1lmv9hFb83G+xXhnlG8L5J6XRHGYf2F96t8ZutY+mkD9SgtBdLwVv00wIKnReBQiX7D+kp9HVrCSQSwPZp9MKuJvBUoTeWdW9PGx2o5Prq67c2sFXZd26tXaYtte1VfKfOJZbY99UVdxTf1Oi5cI4dpilcch9sR3j9AU86EMsuZQJRTR9xX4fNflYPjcDkUz7r19s6WA7GUrTC7dl+6/mM5Q/3He3Phacn4VLMMSIPPgXCg+oaShewbhxbRN8ye7NZ1MsSviEEZwr6NAyVDJYtiZdjfKdy3a4l6UOMEfqeh1HEC3t9fU05NmeXUEOUEzRdpRGlQl/BrilCXBqE0qEv4uVgWpFWgtINAWk+UBk/qxifgzQBp2DYcAtJKtQ3QZ7qMadyE9j+F0noTuGZfXQuHixlfYPm1iFdeftqet1Kv1FInNirZDSJ4rUdpMpzQ0pYPp1UScT00WEsYsc5hxDqVEWs5I9Z5jFiLGbFWBJSvRYxYCxixLmTEWsiIdREjFqe8ljFicfbHlYxYnHrPaQs52/E0RizOduS0X5zyOpsRq5URi1NenH2I059oZcQ6ixGr266uOrvKJXt5jZ+3BkXvOWV/BiMWp95z1rGVEet0Rqyg+qvHMWIpf1XdB+f4cM3Z8HO50Ko8Y4N6xozn9Cqd+q+wcBo+Y2OQmbppz9jQ6QF8BoWf05dzxgY+l8X0GRuDNfWG5ddpeKXqMZBRJsV8+YJaWyq1bakzd9S9hvtYfu/CQI2cYPnlvKcSQvnU88geTse2G+yD5aDfIRTnt3dB6RE820U935Jrxolammd45DQ802YASIf5DwdfcVwvd93f6ahPql7UVx/UkW1mvxxT+jp/NUpLEfWpILCoNXJVp1K/cADfZYK8QUy/Lxz0BOkw/1a1bbxEhtOYFQATvtOFv36hniP0dNrqDfNgHlT+7QAP6usXGLPKp169fTBTQBd3rKUxHQKTqlctqhfmoQbxoPLvCuoVAxukYB71G+rJnJb2vPUhynJ84iA2vBen6cotdK+8hl+/wGlYV7C84P1+MsW6ovLvp9GVngQPsL64XTEPOE+tDw9Jggd4vF9qzmHzc1+jcFDAH9WpRr9xU+Im6Eng+AUlBnlPqpbGgflUwOoHH8P2Jsro7cMjvFeKRzVvOjMzMzfjI6AeCKzap7AeDh2ozwcoW2r4a2RFv4eJvwrX0ww/2q/CUe8rU0fYqnvriTT8fL/Ycvo6bX3pyLlzjvDTBaiUlC5U+pRfQdzvoHsriDjHaf9OL+W74DqX+oXKGqI+VDn1ZZZTX2Q5jWWW00iUg7EoP1KGg1ra0mH+44B9XWc4jdnDB1N95kLlp3x7as+Jyk+tTQwk6ki9Xz/IKVw2lCUejwaXyGuhtYGBiFdqjlksr9t0Ma/VJfJaQ5QNx2Qx6Mw4OnPE9nPm5k9hdgg2HHSNx2OcBw8zvX1Y7YvyYTcML9tgU9eAfvch+KMCZeowL5VO4YC3JJ8Juuj6Pl3UceguqtQeT0vhvXBaqlTiCCKfKvNIVB+YH5ap8s8F5VCu3xGo3ir/SsL1qyd4UvzUoPt5h/hYk5LhUU7HoNKOdtrXHaYdA/Jv1dKWDwdqGqvqJGXx+YA2XJwP8wPbEfOmMOGQAdvWr12uAO2CP9QHyzvS8a+H+l1JlIdlqdJlUG18DMKYnvvtlhWakhWoPMeh3UpVfq3TUbYm3MpjED9YPpQZ1nyo7yhwDeH3QnAqD8wLw16AJccnH9Xsg4j7cFCirEY8/x9YbbgOmS3Y9fH3RSEPlUQc9raqCP6pcnqWWU5Pohy8q1QG/EG3GURd8a5SGfDH1w4FaTuhtJlOx3qptFkazNkazDmatMM0aYcTaZKnqX3beMTmmOoa+CNxsO38+oEfFv5IHLz/GIQ1rwAW/kgcvH8ewppfAAt/JA7ePx9hLSiAhT8SB+9fgLCOLYB1OMKC9x+LsBYWwMIfiYP3L0RYxxXAmouw4P3HIazjC2Dhj8TB+49HWCcUwMIfiYP3n4CwWgpg4Y/EwftbENaJBbDwR+Lg/ScirJMKYOGPxMH7T0JYJxfAwh+Jg/efjLBaC2DtirDg/a0I65QCWFsgLHj/KQjr1AJYuyMseP+pCGuRBkte47dZ4f3q3joCqyL3X7lfi0E8n7vjFb3bX5Vfi3jl5afN/VrsdJQrlA9e1TuN4LWeSINjEUyD5ZxGlENhHcWIdQwj1jxGrPmMWAsYsY5lxFrIiHUcI9bxjFgnMGK1MGKdyIh1EiPWyYxYrYxYpzBi4bFM59fLa7WUpfPr1X3QnuHloUp0D8wPMfzmDZWA52MK8IzfFO3s/EFeD0NYnZ0/yOvRCKuz8wd5PQZhdXb+IK/HIqzOzh/k9ZoIq7PzB3k9CWGVM3+Y39Ieq5z5w34Iq7PzB3m9ltMeq7PzB3k9GWHB+7HNPakA1hSEBe8vZf4gr6cirHLmD8e2tMfq7PxBXq+N+Ors/EFeT0NYuvnD4gJYLsKC9y9GWKcVwPIQFrz/NIR1egGsEMKC95+OsM4ogBVGWPD+MxDWkgJYEYQF71+CsM4sgNWEsOD9ZyKsswpgRREWvP8shLW0AFYMYcH7lyKsZRosGbZsaY8F71+GsJYX4CuO+IL3L0dYZxfASiAseP/ZCGtFAax1EBa8fwXCOqcA1roIC95/DsJaWQBrPYQF71+JsM4tgLU+woL3n4uwziuAtQHCgvefh7DO12DJsGdLeyx4//kI64ICWNshLHj/BQjrQkdfxw2d9ljw/gsR1kUFsKYjLHj/RQjrYg2WDAe3tMeC91+MsC4pwNdGiC94/yUI69ICWBsjLHj/pQjrsgJYmyAseP9lCOvyAlibIix4/+UI64oCWJshLHj/FQjrVwWwNkdY8P5fIawrC2BtgbDg/VcirKs0WDIc1NIeC95/FcK6ugBfWyK+4P1XI6xfF8DaCmHB+3+NsK4pgLU1woL3X4OwflMAaxuEBe//DcK6tgDWtggL3n8twvptAaztEBa8/7cI67oCWNsjLHj/dQjr+gJYOyAseP/1COuGAlg7Iix4/w0I68YCWDshLHj/jQjrpgJYOyMseP9NCOvmAli7ICx4/80I65YCWLsiLHj/LQjrdwWwdkNY8P7fIaxbC2DtjrDg/bcirNsKYO2BsOD9tyGs2wtg7Ymw4P23I6w7CmDthbDg/XcgrDsLYO2NsOD9dyKsuwpg7YOw4P3q3joCqyL3vyZ3fTeI53veE/EqUHmqHjAOll+LeOXlp+35091OR7lC+eDnT/cQvNYTaXjN8R6inHuIciiseYxY8xmxFjBiHcuItZAR6zhGrOMZsU5gxGphxDqREeskRqyTGbFaGbFOYcQ6lRFrMSPWaYxYpzNincGItYQR60xGrLMYsZYyYi1jxFrOiHU2I9YKRqxzGLFWMmKdy4h1HiPW+YxYFzBiXciIdREj1sWMWJcwYl3KiHUZI9bljFhXMGL9ihHrSkasqxixrmbE+jUj1jWMWL9hxLqWEeu3jFjXMWJdz4h1AyPWjYxYNzFi3cyIdQsj1u8YsW5lxLqNEet2Rqw7GLHwmmOhfXL75q51++TUfXDdCb9iWInugfkhht8+vErAc6H9ePshnsvZj7c/wipnP94BCAveX+p+vEEIi9qPR70HN7ulfdoMcB9+hwF+XQG/W3coSDsKpcH34PC69CyQdgxKmw3S5qG0OSBtPko7DKQtQGmHgzQlI/genHo/UsnIzcXXoLopHZyu8pUZqK+lYTnCdqvw+e84HdfYZcA2AH5howKVcxRjORBLvaatdBTqLz5+4GhUDo7D5cD7j/bBUq9my6DeuYR6XY3yr5dre4k9fXh7TGpv8gwQt62mrupepVPYrk3P/XbLC57CX2AGP6yzv7BOuA9C2ZWiX7CsWschx5XpTLLT1Q3yj/UQjgfF7BufXyJWDZFmok3naepN2VyKV6oefn0TlqM7nXOBhi+YXzc+KxnCMZJRhiGdDKkxvjOncyq5jUD58JdFKV8HYzno9wgUV+nQp3NStq3Gh09VbiE7Du9X+XRHWBRjN6hyKJ5VOfB8AXja6N7oXXmld/DID3ivete0GuV/aEAb5n45TOq9G7++UgHKg2cT4KNiVHl+R8XgcU/lbwbjHj6p8BBUZ1hPimeFCc9/gDyrcxgwDwchv8vQGEn6Xaqs/ohf3D64LlSbYL2bS8hBJ1vop0A/BuafVaKfAnUU+ymQJ3UvNdfDcqDK0Y2Tc4ssp7bMcmqJcsr1Q6hyKJ7xnEoGaE8WIHui9A7aE3jvFi1t6TD/bcCeHKexJ3h/CvadsI3F9kSV52dPsH6q/Cdp7Anlm2/R4s+zwoT2BPKM7YnKvwjZE0P+E2lPVFnUeNnHoeXhOMWNl30IOZgeL/ugcuYxlgOxVF+hfDlsf0r1reH92Jf1668r+9JlUv0V+wcw/0LQX89H/RXqu5I5pTd4jJpHlIv7jON0nJ/JoLNl83ywih2jVP7LNWOUbq4hg24urVtzhPlgHt36X6WmDKi3MF75xnDsPATlnY/yztPk9Zs3yutk7trs3D7WrPoCXMNUQaUtJHhWafCd3z1a2vLhUIl+wzpJXdlkeBsuzof5gXJa6INJ2Qt8eriqcw8CdwHChTYAy0uds4X7/325viD7/+19aTysJzLsncMzO3+NpXD7woDbF8sHB6p9Fd+yfY8ooX1hGx6H0qDNxme7QVuvMKTsH0U+QdD6Umf6yxFl9hdKnvgZATV2QnlWI4xPgL4/jvRd5cHjhQyq/6g+q+RXRdwvA/b9VP6nwNhz73C6fF1/cxzaLkA54DMZFzo0L1SdVd4PkT7CPsanj5H8F0SORzzDsk8wVHYFKs9x6HVeVX4dwY/iu5ZIqyqD1yYvFgtFI+mmbHM03tSUqUD4ilcch9coW4j8/Yn8StYngvv5ZB1OKxtQ2dKG3wLkKkMVSDsBpVWDNMWj7EP3D2/Pf4sh/ouRPyy/nsi/DahDKW1ZT5SD5xzlYM3rJFaD074PUGMh9G3wWAj9F3gOaA0YMCi7qLN1yrZhuw/rie1gz1x5Sofg+MeoQxHKH8W27nhDZRdr61T5dY5/29YSaeXYunRTxItkE03N6Ww4k45lK5yOY0IlEYdtHaW3/Yj8hm2FS9k6bM+qQNrxKA3aOsUjZevMjIthtxj5w/LrifzY1hXblvVEOdjWlYM1r5NYytZBPwj7qdDWYT8V+vPw2Hxl6/C8rC+ySWaOvqfXCLFNhfzKAOfQql7UWgLGgXHQb4b34DUblX9gXRsPA+po/lQddiL4o/YUwXoNrvPPt4DIJ91j5UcdlJm7y8HJIzLpXTKpIzJzKx2aPVxFXH08nXJQPhnwl6/moN94+WYGwlFDcLFfvlL/IRbVdBAbD73DcyKTJuxxZMLgMhXjNDdOLQerQE05sQrBQE1zFd+yTk+WMM2FaoWXeg8h7i1m2JYBmzwo1xkIV9ed/bpfFHS/iXVt+bE+F7P9qJjHyjAO5k+hNPgYqEKDj6f0U4FOxlD7wWFb1UM9lq8CaXz6GvIkHy8DPrDdgC4B1mvqUSp2jXTbomRQy+a6bTKUbkFdUjpCtbO6h3q0W4d4LfUxdh1Rjuk+VYfqA/UYuyulPkaj9LfQ46CNffqk3+OgqSAd5p8FHgdtVkR7Un1G5TPcZ0JUn4FyLabPUO1QTJ+BMqwn8u/V0j4N6g5+lEaldbYvwPtVPrPbVmIJyv1VgXJ/sU7DpWh11Ca17A8f7eFAjdGqvlJPPithjIbtgd1H2AcU35QNwNtpSrUBOp04GuBQtl99MgTrfbVP2X5bOZrBGIk/IEj1DUovVX5qqyQ1xlCPkPFWSUNbiCOK12MBn1i+uHyooz1A/mM1+fF2D4y/0Ed2Kr8MsI3xY2P4KgG1/UDdi5fBZoH2bkBf/1qoqQ9VZ7yEpttyWoEIP9qQ4ciWjuVTjyYkTc/9dssMuH2rQBnHEfLAj1DmoTFZLZdUEnWl5Ho8US5c4lIyqUb554F2nDOiPabirY9Dj2m4TfCSKe7Lm7S0T1f5jwfzhYU+U2sZoA/TWkeXXevQeoh5XUDwCseWBS3t01X+k4C8jhhB8wr5oXil+ujOLW1xpfbRnRGvKv9iTR/V6RJlc/Eje6qPYr6xDStWL1T+ZUAvzkJ6Qc1HZL5LkazxtgQZdPYB29Ppud9umQG3JeynlL3EbXk+qpfqv5VEXak2PY4oFy5dYvtwHCqXsg+qDNjn0qBcPz2uJniWAfc5lf9iTZ+jxn5KD6hXGqn+itukp09+XBeV/1dFrhVAf1uGKpDG56d45FoBtKnVLe3rPU8jJxl6+MgJ5qeWaOudwjYZbyOXcdBXVccQ423k9wA7cT2ah1JrW7g8yLtuvgTvL2btwPByfKIClafqAeNg+bWETBj5yb96Rn36UqdDRxP8Z1v881M6SrWbXJ7A6xH1AEuVC1/BnIfiqPVf3PZwLINj0f3IBlH6Rr3SgOXS06F9f7/XP+/1sUHY3ioZU/PuQ5yO9aDWdrCNL/Wzp9S6OlXOjDLLoR7lqP6JX0+anvvtlhVK3z43A6VR8wZqC5RaB6kgyqHWOqDeHwXGU5wP80rNO6kxpcLnP+QHxuFXH2F7wP5K2Qoch9ud6u+mXzOoR/XRbdsudYs79bqq7nUGw+sgRY9B0FfEMjExBlFrSLpnHpR/OF+TX+f3wPxwDFI8QZ2EW4odhN0b5Mc2DLc99alnabvfR2MQ9bV3eO/clrZ0mH8jsNb/gcbHwmtz0GYMcGheHKc4Gw7vx8d44Ofm1H9VDo7TPVMZgOpztKY+pdomeH9X2aYBqBy/9ZWvfNZXSn3FbzzQm281eqMb+3WvE5lYO9cdfdHZcop9Pep/Waf69Gu7pxydqgc61S+HSY21/+tyns9YDsTCry9C3wGvk1Dj7AJNObrjVfz0ZlQ/usxi9Ubl/6q+DXNsEXpDtYHfESGw3K56zr+qniVCLMrnUfmp5346H4zSJWpeT82rlG6b3ZbtFf0aiCq/FvHKy0+bv0t9qvRYQnZ9nba5XjJzpBeKb5pJHTH/sLm4MRRgvdNeyAsRoMrvoN/4PslUFcpzNFGGDKojYUXCk0HsUGP8YngqlLdQOtUJj/Wpp+MU1wnh/aWeCYbf31L54zmDV+x7zFB5SnmPeZ4P75VEHWod2pDABzQwDdZ5W02dVf4NNXWeX6DO26A6+51HBH/jfJVEHXo7HXUAYlAyhvuuO6NP8P6uclYaUDl+g/s2aHAvdDZBBqTD/O+BwX17NLhTzrfp+vudWQLrlQF5/N6dryIwZcAbqFX+PXJ1N7zwQ74LoNs/Dx+I79WvsGx0ba7yvwDafN8i2lzXf6izeHS2wmpHxsu4xeg4LN96R+aNivZCLtaRwffpHBmc169Tl+vIUDz55S3VkYEzAL8ntI5T3BNTeD/eYWrmqWjIxW0Cd6vAzuR3EBjcmaebweGnqBgfDwDwZSZKdmpQxCuvhwEnZtLIn6+ptmr04c9ximsreH9X7YxvROWYWMWVAa9odLWz7qeDU3PXhZykE0ocMOEkAeZfBAbMk9CASa0idHalFuu84xS3wq/rb8X2HyyjKgJTBr8DHC9FDpSZJ1VNrm4Vz6zz1lT04I8dOmq3Xy2RVtZhFrGs50ajsXA2lIxnmqJ4jFS84rhinuiNIPKbXTGKkIdZHAvkKkMVSFuA0qpBGnwyiF/wNuOYRdLFyB+WX0/kxztbSl015sBSL2VTk/VVZcuKPdhd5b9Ks6BBHTAKxy3dm5XHoPuoA1NlwDZRhum5/4U0KVsgqPJU+/QieME7zFXe64BcpoxsXxfqJXNloyo1ZThEXIXjLztcBvWSe9Zpz9v8InijFp4gxlwfPiUGdQAl1utSD6DULVrBcoaXWc5wohyTT75gmYX8sT+U+ERqt5a2dJj/KOCP3Yf8Mertb1UetbCqO1AbHnZGLaBie6PyPwj6VTEHau8GMP30rNgDtVX+RwOwoIXrXOW07aSH9nH7lvZ1UPnPz53+IOX/RL/SMHfwwfymXxvmUyVi7uiD+RHAfEajjwOd9uVBXaf0H/c5eD98ax7ywty++Y+KzDSDn/8AxaGELGCdVPnl7pyEZdU6HdvIxOIcVTddO8OPK+En0xTWoSVi1RBpJtr0EE29Yfl1Gl6pemC/gipnICETlX+Whi+YX/VhqPvqXiVD+NEqRhmGdO09C5Spyu/MR0WU3IagfPijIlD2M32wHPR7CIqrdOiPikibOSg3nlPrJn19eFY84Dis//B+rP9BORkH8ohDJfoN+Zbt/fqANlycD2JgPfb7QB9lc/0wqLXcQv1eBvgwQvXTI+fOOSKz4xEzjk7OzWx2dGb2XEJ/e6P6Yb2bg37PRHnxiRoqDT/MPBT9Pgz9PpzgBwcsExjqiHx+oVD/WB1cd6Z/wPt165ejyixnFFGODmt1Aktnv0cR+X8p9nsCyqfmXOXY7wkozs9+d9UbgxgLzp/gQYh4DV/lH5ObS5j1fRJhZd+h7VQyU2XPMlR2BSpPyRvGwfLrCH4U37VEWjnr06F42PPi4hF6xo24ybSr68swDvf92UT+iUR+JevDzMiaPIB0NpCrDFUgbRZKqwZpikdqfdqMfUoUJX9Yfj2RH6+XFNuWFNY2ncRS69PQxqu+3VW2yaxNKd2fxG9EFnsyVKmnP6n6Sr0d2tCGi/NhXmF74LXQQ4l66MZS3dyXmmuaXc/ouraCfQ8Hqq1UfUttK9geim+ztqnrZAhtDg6UDFV9pQwnliBDqGt4TR7aWnyqSlDkW4HS4HPCrVva8uFQSIY9SpAhta5f6XSU0wwCC8/fDiT4UfU83GnPP2w/GfDzQHj/4QhrbgEsvFka3l/Mmy8Qa2eEpXsmO68A1i4Ii9q4rrDmF8A6DGHp3upeUADrcISlO7nn2AJYRyAs3alpCwtgzUVYfqe0STquANZRCAvej09hO74A1tEIC95/PMI6oQDWMQiLOqSeWiOCPlsdEaf6utkD972SP0RDzX9MPBug5E75uUp2LQSv9UQaHLdhGiynhSiHwjqEEesYRqzZjFiHM2LNZcQ6mhFrHiPWfEasBYxYxzJiLWTEOo4R63hGrJmMWHMQFjW3pmxbX6ftGchPzwE2SR525FEzMw4K0J9UZcDfh/mUX0/c72iw4D26ulAn8Kv8yv76nYSH946o/Gfm1inhKVS6+2XQ7Tc3/Kw3VOy4ip+5mz5NTbefQAY8rlLrR/VEGl6TmFFkORw6LgOcb2F+8P1OASz1m3rGBPvSSIRxGOIXx2EbAe9X+ahyRpVZziiiHB3WSAJL5afmSLpnTNR+QtX3DH18PP+MiZqzUvOszjxjUnIbgfLhZ0zU3BVjOej3CBRX6BkTbNOZPnyqcgvpCrxfp5MzyixnBlEOxvJ7QRs/y1L570PPsqDs+fQrHta9X2T2PY940c+y/E5zg3xTp6eV8ywrGw+5qXA24zaFm5tTblpnM0o96WMckd/sHs44+SwLrlPKUAXS5qG0apAGP06Mn2WZsYNxtxj5w/LrifzYfyv1hEEOLPUsC44lqm93lW0ya1OC+ywL7ukp5fkIbA/8LOtwoh66MRvG6drqcE05E8osZwJRTh1xX4XPf1UOjsPlUDwXOpXxhf5t98B+4ncq47yWtnSYPwXeH3g5h0k9K8ZrQrhPQB2UAfd7+OWuYsZ3lf8NMAfE7w9Q70DNa/HnWZVRBeJ173Oq/O8iH8PQyaPk+wO698vwWmSp75dR7+SarWPpX2/Ce93hmhbeuwPXqGajNLjmhOe7eA0JpsE1+MNQWgtIOwalnQjS8LvwJ4E0qKM4ULYZHgJ0WQm2mfqiED7ABsqX2i+4GriGaYpXHIf1Dd4/0+c+bEcM7030DPfp/P5/6t1KWCfsu1PPhYoZX2BZXfXchqqbbq8TfO6Bn1tQWMeUiFVDpJlo09maelM2geKVqgeez1P9bDVCJir/PA1fMD910FFXr9dQMuRar1Fym4zy4Xc6oA4e44PloN+TUZzfeg31jhb04wbU0zwXey6Hyr818OMGgmu8lgmxDnbapx0M0o7KXRvezxeh1lWw7I4CZeM50NFEfYodS+Gevc+LeHeE2rMHeYOYsP2OBHn8nnWMr2/jJTKcxqxwaN8e+9pKJ4p9V1flXwPwgH1tlafKp16H+mCuB3Rxko+uOwQmVa9ZqF6Yh5mIB5V/KqiXeo7kOA45zh4Mfs9pac/bbKIsxycOjwWzfdJ05Ra6V14fAa6psR7r65Eov3pO6SdTrCsqf1SjK9S7ULq90pgHnGeWDw/rEDzIcaJPLj0157D5Po+WqsA1Ns9UU+ImOITA8QtKDLJ6qjtgHPVbp37UYznHJw43g7oXnnmXzszMzPV79tYDgc3wKayHQ4fu57D50OnnsLMIXuuJNOwvFltOZ5/DYl042Kf8CuJ+B91bQcTJIDvL3F4/X1NzUbz2UepclOocGMvvLI6DWtrSYf4dgT3CXzCeCfigMNWeVZWf8ot1B4YWml+q8pUsqXmKrmxq36/KP69EXgt96Xw24hXyN79EXrfpYl5nlsirX79UY5gw0jOOzhyx/Zy5GdhVMBsOuq5BcTjPYej3LB9W+6J8eNkbH12Ex008Js0h+KMCZRowL5VO4YDP8z4QdNH1fbqo4+i3NVHb8KHLPQBNuahHWDp1LOYYHmiaIAY+JkjlP1hjmhYUqDfuEtR2cuoDH9TWdHxsHXzMCpegZagCaYzDcZr6oCmUQXVL8fWl5ENtkaeOsa1H+aGsqEdDeNkWDmHwbOwX0GMc3QeWdR+1lQHrHzwnv5LAmNHSlg7zL9DoH/UaAHVcqspPbfWHy/t4CRvKV91L6R985UiGKpDGqH8ZSv+gDLD+6epLyYfaRg8fcaj2rUf5oayoo81UmZT9gx8YV0ebUY+3K3z+K15xnG5rwU4t7csx9TEj9VgQ20vKlZPXU532+eGHtil7ifPDD23r2g9/aPts0MfmoI9cw3EaLj+eU0+XDfv3MQSvuOybwTLPeWj8o9w3fGTuhYD3aSP978djC/SB8JEdfkcjQvnDesI2x3ZM5b8c8BnK8UnZEriMLkMVSGO0JdlSxzLK1urGskK2Fo9XUE/9vl8BsaDM/aYVPYn8EA/7eNcRy33UtG8B4n1uibwX6xseA+pxAjoSjxq3dG1F2f164v7jisBaoKnv8YBnKj+0EzD/nYTsMWa1Q+vSQh/MewDm9BIxMz6Yf9D4I9T4SX0/QuVvIfLDMVXxQ70u2ILSIO943DwBlI/zHoTKp15vdIhyHQ2/eMwtxC+27SrtWTA2PJy7rkF4zHYxrGvLNYj6FNuWx2jqj7HUfVVOR32l+tAJhLyerKcxq0vEfJoYXylfZ3ZLW9nP+vgGMmDfQAZsA48h+II+h+5oYewfvEz0V91WXaPjrpdxqXEXygKPu9QcW/e9oEJzbOzDw/wzW9qnFfNNKVhOZ8a1vdC4pjsuutB6w+4t7fOrukEbD2XRDNJh/g81Np6ao+vag9J9OK9U/FCvvcN500/3t7SlrUp91fmJlHwWlCEfrK+U30PpK34dllqOLVZf4RHW2yB9pbZSU22J108KrfXgrc7QDlL5sQ+k8v9QhF8FedC9alHs+gA1xp3g0GXDvgllskVL+/qo/FUD2uqjs+ddsybjeVT/gHLF/UMnQxlK9RHxuksLSMP+GOwfx6M0aq21WLur6zvqXvgxZd2Hj0vtr5hHal5O2XqVfxChT7qxVGfrC/Vp/GoDtB3q3lW3JkDrMpRBMbZeN98px9bjOTe19biQ7e6j0T+/dR7I6yGauhXrd5X6bGNVtn1XPtvAbU8926hAMoFYlG2g1mewv1WOv6nGKCwTP38Tr4Gq/BGNDaLkptNDq/3NTuhh0PxNygbB9civcsKlbBD2+Sj90/lnhWyQbp37WJ9yYD4ZqNdoZZie+++WGXTPZGqcjjrLuPbTVIHKU/KAcbD8WkKOJrZ/Ue1Kfb5IycfM5+Tcn8wU9TztkJaOsvGzO9iGq2dhMuwCcPCrT9QnNWV/2mlAe1zKD4T3qjKwH7jHgDbMXREm9XoctdeCer4OX198H/V9au6oa3Odv7IQlEPlh2MTzL8vGHtiRTxfp/RO5S/0zAd/vpN6vo7LpvYLUGOpyt8cqPlhyFvVz+zxmKWbO0IdxM+BqLEI9gvcByifC/ZX3adfVZkc3z6nXoOnxl786UuoK4pHw7oSonQFygDriq6+lHw6uzaMZQVlArF0Pjh1XDXlKylcqSsbI3sJ+ZlbRN2ouSg1J8C2UfF3IrAl+PkhtZ+OmhtgzNYS1xt0+l7snIry9xZq7qP8PVjW9Nz/wh/WLO6zm8rW9HL8fQhs55cAOarPblL+T3t+ywvUmkgFkhO0m4y2oejPJqvyawlZmvBNKR+B6ndKPscb4cfLQt8U6i/0Tf2O7oVrb9iuQl/zXOQXUjYA2tMpIB3mvxj4mhf4YDpOec8pVvZtj8u9VqdbR8H7FuB9+BkJtW8B+0J+ezTwmq7KfxWwDbq9Voovs8/Qsqv8GQF+DtAC0vDaGqV/UBf89vX2dPT7vPC84yZi3lHMc4p5JfJOfb4b93Pcd85FPios85giyuzscwoZ1DNsPD+9uwv9hu7nFB3zd/Y5BdSXYp9TLMjZbmofazGfIaDmZboxC+r3YJAO8z+m0b+gvAei5GRY/0Kr+lmJat9i3gPRrVFTx61K/ds7p38m5RiLu3mfVrUhPI4LhiqQDvO/ltPJWlAP9b+soyljSS8bTmaTTcl0OpJK4uO1ZFBtJl+3k/rw4oA2mSk5cctMBoVfbQY/v/8Rvp9eSdRJla90Cb/2Tf13HHrOosqqRVjMdfN0dYP847WCKsSPuvbDqioRq8YnbTpPvfNtWqmpNy7fLz/VB1R8Tw0+zK/sOtThnkgWvczIIqRrt56gTFV+Z44PUr9Honz4uGco72ofLAf9HoniKh36+CBsl+qcjvVW9xi2KUUfq6DKr3WM9oe8HahG/Pj1Xfha9cw5yXTutANs8nDTQXFCOFxt3HT5YRHFYXXAJ2goV48aQjGfFQQGJQL8pa4KonzKlFT6lOs4beqKzUchLHVdqeHFD6MCYdRpMLq7TnfXIUJ31ymu63B746F4PJoINbuRWDqVTUfChbxx7vJTzdHmSKY5FfUi0XDETZcyG8DeBpx1VxLyq0b5R+YKo55A9dBgyoBPdFD5xwBMPJOnvCKqnsWYAchPf6ejXuEZRFfpUywZb06kEpFkJOqm3Fi0lPakPNeKImRSTWDXE/dXF4EF21h9UFDlVx5sT0c/a6tG+acBncC7QHqCexTWbi2FeYZ6AGcG+LBslT8MeGgCq/ZYDnjohV4741CXqkDlOQ499Kryax2jroCH20Px46dfhmdSzRUIH/LTi5CPasveRJrCUitO0KbB/L1AHWF+eK3uh3Eb5XSrHmHKoE6DqCDSKok4JV/J+7oN7esG26bC57/CxXHYLkDZYFsJ7TR8Qrk5OlAR9nfKR1H2A/fF3RraMLfKXVN+DG4/bPuxzffz8/zsFR4XVf7tga3Ah0jicRHWE/MIy6siypUB2yuVf5dcuYanAOTh/n6rb7B+cuzSrbTo+q9uxUv1hZ4++RVeNcq/t2aM6Q3uqST4wr6Myr+fxpepIepF9TcVX0vkryHq1d/paJfUvdRTCSV7wyd6pKinElCG1S2F5dOrDPkoHahH+aGsKNvWC5VTaGqJn+JSq2jQFlL+G/YZYPnU+ArjsJ2G96t8VDlYnr005VB2iup3lBxxH5lbom8HP4TSy4eHYn07lX8e4CGu8e3gWLagQc8rtmtwjgXznwjGsuPQWIbbXgbKL69EabAtlYygve1J4FJ2A+sE1Sdhfuxrqz7W0yc/9Kdg/kWETvR3OvbbSp/yIH8wTtc3an2wqPaUAfsmKv+ZGpvfh+CvkuBP5e9L5O8D8ih+KNn0deiyYX1ge+IPKan8K4j6UOMIfEIiQxVIYxxHyFMOoVzxOKKToQxY5nVEfihLVb96lB/Kn+qjfVAaLLc34qHQHAqPMZT/BG0UtVwMZaD4rCHqy9d2Ka8ClafqB+Ng+bVOR503MWctVkeUfOrMyMfV6WAdIR/FTz8j/Lj5j4PWE2UrXnNq1c6uwPx1QIYwP7xW98O429DctT+4T+HXozQZ8HwZplUScT1WEVY9gQXlptpU9uNrkSzwicHUf4WL4zCPsD2VzutsRGfLgVjKj6L6k6Tpud9uWSEcUvXoR9RDlQ31iq/vNMWKtXWq/FrHaF/2dDoM5aPajer76t56p6MOH9/Slq+QfsNyKKyVAcVazIi1lBHrbEYsTnktYcRaxoh1OiPWAkYszjouZ8Ti5OtURizO/sjZjosYsTj70DmMWJztyKmr5zFicerXCkasCxixOPU+qDaHs44XMmItZMS6iBGLU16cvgmnfgXVL+TU+6D6cq2MWGcxYv0SfLmg6j2nb9I9ppWGFVRfLqi2kNOXa2XE4mxHTnkF1f86jhErqP7XaYxYnH2bsw9xyotzHOLsQ0GVfSsjFue6XFDXhjj1i9P3DaqPGcSxQ17jZ1YcY0d/H2x4rXs2TJVTQfBMPVPuATBqnI715XyurPAbDOGreg8gZAXrpMrHz5hVOvVfYeE0VVYtwmKum6erm+5ZNHzuDmXghzWgRKwaIs1Em9Zr6g3Lr9PwStWjjlEm1YxYeK8e1f+p57cqfwORn9KT/kTZ6l7Vto0gjbFtQ7q2hTZCld+Zt96V3HZH+dQHyns4HfvGAB8sB/3eHcVVAjwYusq+499qbw3c04u/Mtr1eySi4QpUnqqzg+r1v7JHoqWlLV+5PsP5jFica/ScfndQ1zM468j5rDioz21aGbE4deJMRqxfgk50P9NYdbLnlBfnmiBnHTnXM4L6TJZzjYtT789gxArqej+nTnT7X/8bNppzrD2ZEeuXYAuD+szsFEascxmxgrquzjmmdT+HKA2rlRErqPaesw+1MmJx2ujuseN/Y+zo3m+x6nSie01h1dWR852EoM6HOGXPuZ86qOuFnH5Ot51Ydf5Et51YdbIPqp1Q/hd+RizD9Nx/t6wQjtQR5VY47cs1tN8kU4HKUzKCcbD8WsQrMz/afT9UmxneY5WuQPiQnwZCPqotG4k0hTUw9xueJQLzN4A6wvzwWt0P49K5i3oCsz/ioZGoD4xT8pX7cvbP4ZbQB0KprBduysSa3Ggy0pSOhkPpUMxNR5qynhf3QolIPBzOpiLxdDwUzoZioRTex6R4heUaauNIsX1AlV/rGO2Tnk7nqP1UlM6pe7EuyDCnpS1fKbrAqVcUX+rcOoO2tqnO6ShbrGcm93/B8pSMYBwsv9Yxqveers2gfLCeDSR4rSfS+qP7+ne5zMPNnZW56X2tlMyp/YqlyFyGE1va8uG0SiKuhwarlRFrCSPWWYxYixmxFjFiLWDEWsmItZwRi7OOpzJicdZxKSPW2YxY5zJiceoXZ3/k1K9WRixOvpYxYnHq/S9BJ85gxGplxDqHEYuzjpyyP40Ri1PvVzBidduJ/w07wVnHCxixOP2JoMr+Qkas7j5UGtbJjFjdfWjVyZ5z7s45R8bPZuCayvTcf7e8EKohymXCzr8fPqh87DCOUNiD+fmOKOwh5WOnXR++h/LznVXYwwhsLxz2BDsxL5vOhptiiVCzFw1Ho9lINhaNR9LZpkgyHct4kWQ4lMjE3KwXz4inG+FULJpNpFPRrFqng9/hgN9R+SanQErvqW9Rwu9a9ADpMP+Bg9owv89h4m83OuC6BuFVOJzrmSG3ApXnOPT6qiq/FvHKy0/b+moPxA+WD15frSR4rUdpMpzQ0pYPp1UScTqsJYxY5zBincqItZwR6zxGrMWMWCsCytciRqwFjFitjFicfK1kxOLUe06+WhmxzmLE4mxHTtmfxojFWccLGbEWMmJdxIjFKa9ljFhB7ducY4fyJ6hvhqtv6VDf7+uD0qjvuVagNMhflYY/eH+Vz324Hoa/T+0p/N5m8PPnQRX6TqUqX/etbvxfYeE0VVZXfUubqpvuW+3Ud611WL1KxDL8ze58m+q+fwfLr9PwStUDf7OU6mcVhExUfG8NXzB/f6Jsda+SIfw2LaMMQzoZUt/e7MxZWkpuY1A+9V3CHk5HHezlg+Wg32NQXCXAg4H63jduL9yf/dq33ud+Geo05VDft1b1g99bHQ7S8bcehxM8DtfwCO9X+ahyKsosp4IoB2NRazQyHNTSlg7zz8it0VDfRh1B8KfriyOJ/CNAHsUPJRt1bx1RdoXPf1WO4+h1CPKA7dRIxnJGgjz4e+ujGMsZBfL0ReWMZixnNMjTB9wHbQLWM8XHWIIPZWfHgXjusQqWp/jFMlDl1yJemfnJ+wzjED9YPth2jSd4rSfSsN0eT5QzniiHwhqDeMA2XwbD7RfqbPuNMcOPtv3GEHIttf0akVzHG6lHKP/N2AlOx6DSVgNlY11YHaSNBdc4VKLfsE5yfFkXfMcd58P8QB1TvNUQvDLKqQnX1yH4WgOUPYjgXyeL1YAsdihBFlC/10BpY0HaRJQG9WlNlDYBpE1CaasR/BTTN2XANkanV2MYy4EyGovKGctYzliQZzwqZzxjObDtVFv1dzq23Thwjft4JRGHyxlHlKPqA+di8Png9YPoMqHvCe9V5/lWo/zjhrdh3pTDVH0c9jPGPh5TdZvodAwqbU1Q9moobRJIw/q8Fkgbi9ImgzTYtjhQdkPJQtqNWSXYDWi3cf/Xje9jQfyqGN9V+V01vo9F/JQyvqt7qX47GN0Hy8EyNzP2Fy9zVX5X+cSUrzoWxGGZr0bwSo0xau+LsjWqnzwB9iI8Mqg9NrRV6r0+7IfIgM/nnkCkSfzLchtC+hP84bUGONZWEnG6tYbVfLCqAFYNwNql5ef/1Sj/h11ie6Ok7cX9YE1DZRfbD7CdhPwovmuJtKoyeM2m4m7YjUbTmWikuSmSrUD4ilcch9dfJhH5qTPSlazXMiPrUP6bJi1t+NDHlKEKpK2J0qpBmuJR6v39w9vzP8kQ/8XIH5ZfT+TfGdShlLaksHZhwoL2gAOrVyexGpz2/QnbHPgbYsG1frWuTdlYjDWxANY2CAveP7GIOkKsnREWvH9NhDWpANYuCIvSvToCC9tUM/3cbSrWpqryax2T/bbNt1jL6ShXKB/sW0wmeK0n0vB4O5koZzJRDoW1BiPWREYspWNmdSfUXEfwpYJKmwLKhjqDAzVnguPGqSXMmWAbT0FpsM2mojTYBmujNNhvp+WugyZfPM+dCtLwmtPaIA2vOU0DadiXckEafA6JQ6H2PK+E9oR6o+pb43SsP6Ps01iGDsHX2iAOzzmgDOEcHgdKTqpOUk79RrXh4nyYH6iHWH+hfcD6C/WEUYYZSk6YZygnrL9Q17D+eiAN628IpGH9DYO0UvVXyalU/YU6CusL61UF4uDYt3nLz/8pX2QMwqJ8JBinW29V+ahyxpZZzliiHDV/VfUP5xZaZJt4uWtqrUbJUua7BeXr+jlp8c8rVfm1Tkf5mvCfKB+XaiNqrFD31hNp+Bt8U4lyphLlUFiqLSnfGOt2qXOcMUR9gjRmQB4pWwj1A4dCY0Ypz+igzBVvNQQ/fHIKu9i+OwRf0L6X+oxuGpBFKc/ooMw9lAZ1JoTSoE6HURps7whKm0bwU4w9kQHrO6U7OrvY2XKgjLBvPYWxHChv7KdPZSwHtp1qq/5Ox7bD8/61UTk4Trfmgn0zuE4Cn9E1D6bLhM/o4L34GZ3K3w88o8vkMGuIOq7KPj4NpUEfDusz9OGwDkZAGmxbHCi7oWRR6jM62LawTpD3Qv5dNcp/JGonM2OW6zagelEy1flVhvgq2q9S5XeVXzUF8YPlo/Or1L2U7YHzM2zjSvWrlD5SftVYVE6pftVYopyg+VVjUVq3X9XtVxVjT2To9qt4ygmyX/UrJr/q22FtmFej8drMeoOdfpWSRal+FVyrx3YDrgmpfHBNqFj/a7OWn/9j/+sOsB5122B/vsaDstce0j7fmkT9guo3GVof0/pNlJ9Rqt/EuR6l2tKmdSLYbjhw+jOwv/3S/RlqvmejP+O3T4qjHCijX5I/A/sJTFPlFPJnqH5G+ZvQn3m7CH8G3uvnz/wD+DPvWbhOpHvWF4R1ImoeVIF4L9ZPUfm/CNA6kc7fMbR/qWh/B+9fMu3vUPuXdP7OFIJXysbhdSLKr5pClENhKX0M2j6WsSiNWtsqtq/CPSfrdrKv4j0nkJ9VuV+iVH9nKpBFZ/0dbH+hzrgoDepqZ/wkyE8x/VyGYtZFTfs7a6Fy1mIsB8p7MipnMmM5sO3wc3rKhnTWHunWvcaD+6C/M2YIXSb0d+C92N9R+Z8D/s74HGYNwdeq7OPYp4V7orA+Q58C6yD0k2Db4kDZDSWLUv0d6Mtiu1HsGsoq2NNT9DcKg7qnp6/Tdu7DQZm5Ox7VPHNGapvM/CM3mp3eMXnE3BnJmRul00dkjjwS1gZrFK4t1hacR12vRsRDjLUK1AK/FUBZVoU1uQAWfiuAsp46y0XNmvo7/hYSrzhRvQ1bRZgf8jO1AD+7aPiZirDWLoB1GMKiZrsKa1oBrMMRFrx/GrrP9SkH5oHW0CXKpvCx3noFeD6ipT3PkC88UwsVwJqLsOD9IYQVLoB1FMKC94fRfRGfcmAeOCOOgHIqiDiKn6Nb/PmJIKymAljHICx4fxPCihbAmoew4P1RdF/MpxyYJwriY6CcCiKO4me3Fn9+1L3FjHCQV8YRJV2BylP1gHGw/K4a4QrJFc+a4wSv9UQafsoYJ8qJE+VQWGsxYk1hxJrMiDWVEWsaI5bLiOUxYoUZsUKMWBFGLGUTlU2D7VqPyqF8hGmacuD9eKZg6ulHPSrHb7a5EM02lQ76zTbVWFSN8v8JzDZPyGFSb1vgt3OgbjGuvEdVveHY6iCZwPFnCLjGgZo1Kr5LXW2CbYTHStj/4ygN9ucESoN9ah2UFib46ax+wbbqKj3Gq24uYzmUH4zlzVEO5SNTPiZebaJ88ZCmnIlEOYX6/0VD6DL9+r/y/apR/ltB/78UrTbBOq7KPo6fSlPjuEpLgDSsg+uANNi2OFB2Q8minKdr2G5Qfa/G6ajjq+LJlCq/1unYt0342NQcmhqbKbuq7qX6Le6b1JzbI8qhsJoQD7o5kqH2C3W2/UzPkaj2082Rim2/oUiunpF6hEN4TIaBenKPdylCnxav9zhINjDAOpX6NBDqmOLNsH8WwfV1CL7gukKpTwM7659B/cb9FLZHFKVBfcL2GY5/2K8z5Z911W7urvIDg+Cf4fl5qf6ZS5RTyD97pUT/DD8NVPkvB/7Z68g/g/0sqP4Z1mfon2EdLMc/U7Io1T+DdjsG8LEew3zUDjbchxwCA+Pgvq3q3IO4V32tkVrnGIDKKHWdYwDBbzE+qpkxpngfVZXfVT5quEi5UroVRjKn9ADrCCwnQpRDYWF7q/NRzfhSbqTY9lPld5WPSvn+Awi5doV++7XzNA0/Zux921dkCj3PUvxImfV0OuoQ9RwP8w2fe6k4v7bRPX+nfAxdP9U9f/erg18b6Z6/UzKoRmmr5SY1Uoa1Q9vnUc+NR4I8fXPX1LiM+7ShZ3NF92n8bC5qhh/tszkoH6izvRy97sC289u3sDZRV6zLUwvwhHW51D0SEAvrcql7JCAW1mVqDwM138I7/qhd7NTcUOFLHR871B9/mgbf0+CHNfhwFxj2UaG/j996gfOKJoC/pgZ/sgZ/qgZ/bQIfY+ITl2HZ1Sjv5ByG9JFfGkXzqzBkMPtVjOJtiiq/1ukoWxM2hTo5G8oH+3nUSZ66EzArUBosp9jTNIvZc1YsVtecXhgOU2snKlB9u9S1I/gW4Q6dPJkT93fYZnhdCbYBXleC8sXrSqbeNFvNp14c5UAZ/a/uWKfGY2hrOtPPdOOA35tzOw2lyyz2zTmV/0ywdrRrDrOGqCPjTvKS3yLGu+uLPXmzmF3mxdoNJYtynu2pOsldzmpPwkGZudtk5u+enDkjnZw7Y87snTOHH5U5cm4VgsXdFHentXzYhTiOhl0ZeqA0/JEa9ZGJHg4dillO6D50iefQJXyANzWdmEqUozvAiTqAvgGVQx2Mv4amnAaCZ8PmJUUNoSpQcm5AadQB050xE+t28sAQxZvZF5hDWWr5FvMFzWmprhZ82bizj+m4X8yT134HGEB+irEnMmB91x1ObuoxXVe/TGfaRVVtRS1XlGv3dIfo+z2mOwu5WmosLvYxncq/ALhay5GrZeijkiX3cXxwQ7GHlWMdpA4wKNZuwA9VdvalPWw3oB80u6V92jhw3yR03wSQBl/2031kS33wuT/6La/VR5qrEV93IH2AH3NmnF6n8XijyoBlTzRUdjG2QWc3Id+U/1bOR7BCmeZUNJnMhlNZN5XMZiqcjjZb57+p/NSLjv2J/GY/IhVOqv4CP4KFX5GsAmkTUVo1SFM8Uh/BMnRYXLIY+cPy64n824I6lNKW1BiLP75TLJb62BQcd/DH5vFcTwazdqD4+ZIqvxbxysxPfr400uko1ypCrtSynLqXWo6CNhimwXJ0Hz6EWONy12bbKBSlbLWD6k99VINaloTthgM1Bqs6lTqPgXLGh7QE5aO6pc5j4AdwS5nHQJnjpSioM9jngB+AwMubUA+xz0WN6cX0cxl0fnKVT704yoEywnZxJGM5UN5d9SFw1VY6H7Gz9mgEUU6heczbTPOYg+Bha10zjym5j+OPLkE/C+szXArGOgjnv7BtcTA1j8F2o9tX6LyvMIbgleq38KNn2D5UEnE6G6DasoZIW5W+wliUVo6voOpUqq8A9RX7CobsSMlyKtVXgH2+s74Cnv9SH4RSaWNBGvYjoB3x8yMgP8X0cxl0vnFX+QpdNYaPReWMZSxnLMij2qq/07HtYD+BaaocHKfzfcaj+owA90FfYcQwukzoK8B7sa+g8u8KfIXRueugzZuw/0TZQsqPwDoI/Yix4BqHQvOtWWXOtzDv1UTe4ShN5Z0M2mun3HV/p2P/y+0My6cNB2mjUdoIgqf+TkcdgBiwDKhzcMw/qKV9HVT+UI5vKcvQSBqzhw+m0mNq/UzVQ33EvAqk8elvypN8vzy8jQ8o05/q29K+TpR/AvPjNcqxRH5o85SMKDuFfaMRBNYoEKfW4Ch5Kh5XhTwhj8XIE+YvVZ5KRpQ8xyGs0QQWlLFOnorHVSFPyGMx8oT5S5WnkhElzwkIaxSBBfs7XiNW2D2J/NgmwfzbA5sTG96eP2g3sS4MJ7Ch7a1AGLAetUQ96lAavFfifjOwPf9qnN4d2P00Kpva8wFliNuPWhuH60n4+Ri1zTpoa4bYRyh2PQH7CHA9YSxKg89JoUxwKLRG+WoRH96m2pnyK/1sD0yD90LfEa8bzQA6dgwqe2KBsot5zjaR4Idae8MffzN0YG68juBVBUqP8JoV1COsY1CP8JoV1COsf1NBmt9xp45D6xg8TLdYHcPtXGjbPNax8QS/cC0T69hCoGOno7IpnaH2rqn8uoPwC+mYutfsc9Jg7e9QaXB7fqk6Bj+4VayOnW5Ix85COqZksBTo2CWo7KkFysY6Rr26BfuoahNq2zn+mBG8j1HHSj74G+sD1D88jkL9w2tbUP/w+pXfa3g4UDqm5FSKjuF2LnR8M9Yxar8e3MaPj3T4FdCxm1HZ1Oum8GgdrGPUcbawj2I7Rr2+VkPcx7jfo6mO4FUFlQZfE8V7OOErrdiOFXsUGN5PCo+awMcSw0DpmJJTKTqG25k6gqRYOxYCuPiYkUKvK2P9oV75LlZ/1L2G9SdQx8WptHVBmmn94daZi9Axn9CG4+NKvCLLVPkLvXqP9Y/SV2j/dfqHj5FV98E1Rcg/PgJR5X8MzO/XAWsfP/HU0laGkpPZNRg3Q63BQLlWt7Svt06GMpTa55XM6p2OtjmE0qC+4H43nsCER9fiD5+8APceIHtZ6FMBuI7Uq+7UB/Goj8fgo26D8o7GVJTG6V9R/n2pe7vhOyHFjou4nal3qoq1cVMA7hikY4q3D4GOfYXKdguUjXWMso2wvbB/D/VI3Wv2uMiwV0fwqgKlK3h8hLqCdYzSFezrUXoL7Qn+vAYMlI4pOZWiY1+VaEt0/j08kkF94BLr2PdAx/oMb182pWPUB/iK1TG1xvG/omO6YzWDrGO4nSkdg+tRWMfWIPiFH4XHOlY/vC3P6G4d+0Xo2GhDOtaMdGxCLm0C0DEPlb06UfY4EId1jHrOBJ83470D8FkffrcY3hfUvSV4bR4+CxiL0uCzALyHB65/QZngQOmYklMpOobbeQIqA7aVDFjHqgh+Je71uc12tahcdc/03G+3xBBKpzNexIsl4plIJJ1owh8ElkHpYh8D5UeakrFUMuZ5iYiXiXhdXn6qKdqcEky4Ge8ncXR1+U3p5rgbCyUT6VQ0HW5KdXX5meZIItacSDW5aTfhJcKFypd94cXcmY9YZzFfGKeUfYwyzGn5+b+yWz3B/YzrBSGF3wvxx4SfH3urnY5yUmX3NlK3bLaYdoDl1yJemWWd35/eG/GD5YPfBa0xI5+MVGWle3DM7UnIBvPRC/FYa4hHai1N8aTSqkCa4kPmGTy6PY89DPFoto9m8+9mw3Ea7sndE427qm3gWibU+x4gHebfD/hs++Su+wNcdb+yU31Aei8iXf1W7dWDyAuv8W/FO5YrzK90sqdPXXuiuqr8qVz9JG8NDTQmlB/kq4cPZhZgroPaBO7J0vV5lb8PkR/2McVPf6dj3+yD7oO81zjtA4yj2qcC5cVjsBqn4H1+v2sIHD8eehM41L65GsQrLBPrgwzY56wkyoF9Co75NUT5jONDEzVWqqDSeqL6wjRY931a2vLhQPn7qk6yvpug5xgwH+aH6mucvpGKrwbxuNxKlLcnygvHcyyzagYe64lyeiLcXhr+KxBOFXFfnUP3R+p/sfxWEPxSY0255UCsfVvalwPbGY5pS5D9hHa8krh3fktbOsy/HIxpS4sc07AtgXXYr6UtDtts7MfiPomfd+KxC+eB4zjMfy4xdmH7ALFk3PlF+AiU34d9hLuAPC9C8qR8gP5OR9lgHa5BZUH/WI0vWAZXAj4uH+5flpJrnaaOMu7q4XQ+yAPMhzGosVNhUP1a3def4Av3PWw7emrKoMYzqoxqlFZu+1DjNvQ1KB+GSofjOSwHx/Ug8hfyP2p9sCncngQOZed7o7QKIg3bMFhfaMOwb0LNyaBtpPqdX9vpfG+K92L8qp4a3in5QTvEvZbjxl3PTcWaslkvHU02Rwqt5aj4Xi3t6/XTfxBXDeolQ2+YH6XVgLSqlvbl1+Z+V4FyIJbioxrlfwy0tQw9wT3q/nqi/J6o/HZ8E3FQ1zBWJRGn8ss2/XOORxNrdKGmRDyZaHa9UDYUCsejpazRKX8d+yid5QUHyofJyw/U3QF88JQd8ioIOVT6yN5x2ta2zKyBtK1tUe8j9SDaSsnHzFpbyIVrW1BGh7R0lA3FhwzY54Z1UWsfMsA+CdepZFD9GvZ7mB+uJcD8rwP/5k00H6smypP5PtXkq/D5/xMGEVfV0j6OsgfQTqr8quzalo48qrQ+IK0aldM39xvKC2IpPqpR/o+RnYS2Td1fT5TfG5Xfjm8iDtvJPkT+PkT+n/YrobEP1p27L/5UJsKHcZi3T4ENp55z6Nbvzax7ekXbOFV+V63fU36cbv2+lxn5uDrfjJqHqLbsTaQpLGrtk1qLo/xv6M/j+dqP6N1X6H+reX8FkVZJxEG9/VozbyvV5uF1C2q+VIF+U+sRsL9Vo/yDR7TxXj2iPWahtcuDWtrnh/NXau0brx+o/DW5cuE7yRjTr15+mP1Avfrmrinboeog8w30qX+Fo5dpsfXv4cNrA6g/Xj+pJuoKeaX2KlSDfEN98skA17eGororXisdeq/ELi00nwqD+q/wcJxu3RLbLjPPZn/+fBO0D1S9cfmSakEddGsGOp2C+LUov7q/yqHX8FQbYp2aBPR/QhH9mpr36/S6mD44kejXVBtDvVZ8U2sJ6p5Ca7VTUH0L2UbMv8ofAjKchviixntqnQSu4+LxznHK7yu6cQuutVDtvAvKD5/TYV2m8itdhbrZB/CM7Z3Kvw7Qizka2wzbdL0RdNmwTasJXnHZO4A23RC1KfW8hHqeifu0boySYYuW9ryo/JsCOeje1VF8mX1XxyPPS4H6Vd3Svt7UM2TKL8L6BfNDe4d1G+oSXv+rJrAoG0b5TnC/Bu6vcOzEdoTiv4a4V+XvC7Co/AqvGuXfReMP9QX3UH2uygdzT6D3u6M+B9txZktbvvQIumxY/0qiPip/HVF/mL8v4lXl31dT/z5E/SFfx7a0x1T5DyD6GuYT1ouyuSq+H5G/jqhXf6ejXNS9WPYwH5Q9hYHtjyqv1umoEzIc2dKeV4iF90np+nZfglddW/clysFtfajGR+jtw6cff9Am4PX/agILjivc68TRSNSLx5PxVDSVTURSzV2+lzYRzSbC4WYvnEhnEl40KHtJYd/q6rmDmXWPtrlDb8Cnzs9U+Sn/rLcmP17Xwvh+z8igfwbXI/DcQeW/FYwVJ6MxQFdHGbCPiPeK4jx4vQf2TYpnP79uMTGHxnKj1pBkwP6Zyn+GZsyg7I9uzCjk++iev+P9czq/iMKG+SudwuNABVFPtb4mgxpPIIbqY3UIZ3rut1tmwGNdldNx7IH8YP/nAqTH/ZFMdTKD43YVgQFlUo3yX0DMdXBd+jgddZ1qE7x3FOvVJi3t01X+y0B/vgT5ftRawk/7SkbQZUMfo6+G1z4Er7DPLGhpn67yXwnkdYQPr5AfyCs1d1I6uyrmTtBuVSOeKPsB83fWflBzJ91+VWx/K4hydGMMbAcqv8LDOnlLkWtDFQD/VuQTU/O2CvS70DhFPVOFc8A7fdZF4VgCZTajpX19Vf7hI9sw7/HBVH6ADHNb2vLk9zs4HduM0Y9xsewovwHyg9fLHijBV4A4Kj/lr8BxWskE+ysPEDZWt/4OZQn1xmGUZTF7MQy1Y6IClafkAeOwTafaZjoPP9rnlLq9GIb89TjciwGfZ8G9GNR+Magv1P5nOH4+gfoC7DOU3dimpS0d5n8ajN1Padagqf3CCqOHT5nKBlLrn3i+httOBmXrMC9QZtQ7PzL49eUXNT439RyW0h+Vn9rPSe3FpZ414HGOKhvWp9BeamyL8H5mlf8NzdqX7lm4DFimKv/bJc5jdDItdR5DrXcWK1PVJzCvxcpU5f9AI1PqOYJOpir/xxqZUjLSyZRaV6XW+/o7HeXdF2EVkqn6bgDmtViZqvxfaGRK2TqdTFX+/65CmVLr0oXWZKBNVfG1Dl1nvAbr9x4rxKTsVy+iDrq2pGwabkt1MDPVllS9aoqsVy1TvWpLrFc+v6F6VfrUq7LEetUUqBf2s1X+vkXUi3qPRga81pV/JwNgBvVZJFyrqG5pX2/K7sH8pfoG+D0Wah1T936cTicqQBx+TlFBlAP9SWrui301ar8DLBPrgMo/ukgdgH66DFUt7Xmenot3ywq0DsBnBVgHit0HifsKzI/XQ2SoJ/LjvRY9CCyqnSmd8ZtTQFy4FsF+7kgk3Jz1solYczjrhuNel5+7knRDmYjX3NzkZZKJRLbLz13xPC8bjTTHo6mQm013+bkvkWwsGc3G3KZQOpIJpZNdXX4ylklEouFQKpxNJONuvKvLb05HU24i7KWTyZgbi8ZLeVZZ4bTvTzLo+h/l72H7WeidEYxVocEqtE9lG4Slswu6tSRDe8wjFag8VQ8H1Tv/npjTcXwysZZUSK49kOyovdPU3iC8JkmNKdQ6PYVVwYiFv6tCjRF+z/F1eoN92em53255oWi9UXFdpTeUP6bTmyqCV+p8rJ1a2vL52RDqm79dhaU7R8H0OSLF6gJ+N9CQbmrfDawk5ErtIVL34mdWMuD2o2wV5ZfaggXtj84eUfsrK1EalLfyqan9R4fm0rCNK2XtmhpbITZ+Rnlkbj5k+HmEi/0dWJbh8T1KPatWgXrujtsdzplxu1NzZmrfY6nf8VaykGVPGt2Gi/OpQOlIBUrrSdSDei6AxwDKB9KdYac7F4Oy37Nb2vNMzTOpcw8o37SQD13sWgW1BoH9pkL+OPZ7KX8c2ySqHDwe+tk1nb+vs4eQ550Rz37va+M2KfXZG36fpFzbCnnVvS+G9YJak4T6V4x/aeh9rWgFKk/xC+Ng+V3lXxb7jJKykXgPD34GCa91Z9XAciisXoxYlYxYVYxYuuf0WEcN+ZmxYnUUz4EqzPCjnQNVEHItdQ4Ez170GwOKnbd0Y3UOy+R5eVBPKL8R7n+5F33PXt3n91zqsJa2dJj/O7Bv7v7ctc7/wH1ahum5/25pIYojDI9pCTwmwED5zVTbqUD5zYpv+X+HkW24OB8uk3o/mZoT90Fp0Kfui9LgGFSH0kzprp8PxFGObt3W1Pst2E80ddYEPreP8gcrUJoqB8fhcqj3YwrtrXt9JF2m3/POw1va0mH+j4FteQvN9Q35iTHqWbaD6k3tNaD8RazP0DZgHYR7X2Db4kDZDSULydesEuwG1D1VJ7g/kXs/nypPt58vqDacaifcvnCvF25f+A4Mtgv9QBqUCQ6FxoxSvu9J2QGYT7fvAZ4H8Toa82G+YtYcqLURHY86/dPtMYFlUXN6v3NAoM2C/PvZrKpcGxTao6HkZHaPhhtb1ft08Do8NQfUrblRvorChH4sXBfB+PhdDxnUWjv2Z/86qg27YVT7PApvCMgzcFR7PmEf2rzFvw5w38hjOQxqbJM0PffbLSvEktRaNR9+KE3pF9Rzc3Y9kqpA5TlOcetNhp4ZeKX2p1LWm2Q4qaUtn18/LGYtRobljFgrGbEWM2ItYMQ6gxGrlRHrHEYsTnm1MmJx8UXZ2aDo6gpGLM6+zakTyxixuu1Xt/0yWUdO2Z/KiMWp9+cyYnH27aD2R04bHdSxlrMdFzFi/RLGoV9CHTn54rSrQRy35TWetwdFvzjldT4j1hJGLE7fJKhjWnd/XHV1bGXE4mzHX8I8jVMnTmHECqren82IFdS1jvMYsUzaaJWX2osvg9qfjJ+BPIyeOZjZvx5J42fmqgxYdo2hsitQeY5DPxNQ5evW4GuJtLLeqfSy4Yzb3BwJNaebotFoqbqh8lPnw1DPF5Ss+5iRdTP1jBPuRZKhCqTVoLRqkKZ4lLK/f3h7/s18Nz7SXIz8YflU35zV0pavlLZscNrrGuyP1HNFdQY4ta9IPdeEzxWp/eYVCJ86c1D+f35UG6/wPsgjrB/1HmcFKJ+Kh9cVKB6WC8vbrKX9fXgPF+YF17eS4JOSRQ9CFrqzIAp9Y4L73exYKNWUDDcl3FSmKZaMxkp5N1v3LVndN3pV3ZW+UudryIDf21L530Fjjxn7T7+3VYPqUOgM5p1RHVT+78EegPdHtZcZpXe6vXm67xBT53Thdih0Rhaug8r/SZF7VVR9FA9VLe35nJ6Ld8sLEWqvChzf4BgBxwnHaas3zI/HymLPnKpH+SmbRdk+KHO8l4k6h5Wy9/gdx69AG+FzWKFe43GJ2rdJ7bPBe3CgbtUAngfl3uOrcWibMT332y0vlLz/Ett12E/w3opS9/VVEDxUot9QFqW+78hhJ+AexJ/4a+nI16rot9DPwf2W8ll1Pm6hfq78rnqnY1ti/abGglL6jAy6s4JU28A+0weU1bOlLS9jG4RUvZSsKwHPVS1tvKvylb7A756qfIrXGjO8uopX9Z1UNW7BMmFdeqD8+Loaxa05uo1vWEfYjrpvWVPfaIXfrlU8Ut/z7dNSGlZvhNWrDCzFVz2Rv1cn+aKweiKsGgILxkEfejjoE9RZKHBcVf36p289gTaFtg36PPBe7POo/JuMbsOclrs28f65zlZTPh0eC0pdI4L3+61nqHTHMT2fLv5MEVU+tb7CyI+nG3uoM37Mrpe0fZOG8kmpdpbdpJ/Tsc0gf/DbGyqo99hLPQ8Bj42w7XTfK4DvkejmlxUIi+rHVL8odIagGpvxfG1L0O8PQP2eOj+D6r+432NdhWl+52f4tTmcO2D/p47IT81NqG+R1RWBpdvfX+hbarhsyBe8F5ftp7uUH6tkY9iPbaL8WOh7Yj9WN5+UoRhZUu1Yj/JD2VH9GPdHWG4flAb7H+7j1HuksL/gMRr2RzhG/ydXSA0hB06bDvsfN37cc6PQDhvgP6zGmDoj+OGowu9nhn9X6d2OLW34sC6qXKVzam0aXlegPDuDPPgsdJVnF5BnF588u4I8u/rk2Q3k2c0nzx4gzx4gD+R5T5BnTx+cvUCevXzy7A3y7O2TZx+QZx+fPPuBPPuBPJDn/UGe/X1wDgB5DvDJcyDIc6BPniTIk/TJkwJ5UiAP5DkN8qR9cDIgT8YnTxbkyfrkOQjkOcgnzwyQZwbIA+feh4A88PslDsgDn9ce6lPWTJBnpk+eWSDPLJ88s0Ge2T55/r+9b42R7LjOqzvdvTvP3ZmdXe6S1MOBECp2nKB7pueVOMASnOVTfIiiRFmWJc9ztRHFFXeXpkhaZsuKrTgyLDhKYgkKINt0bMuO4whGIBsKwChGoLyBIEFgJ4ydGDYUJIDgvID8MGBvDe/p/vrrr6pv79zq6Vl2AYO+c+u755w6dep9quoqYPAMDJT544D5eIDOc4B5LoC5BphrAcx1wFwPYG4A5gZgUObnAfN8gM4PAuYHA5gXAPNCAPMJwHwigHkRMC8CBmV+CTAvBei8DJiXA5gfAswPBTCfBMwnA5gfBswPAwZt/hXAvBLAtADTCmB+FDA/SvKodVFrh6zdS9HvWK+vNNK2q4113jPuIJ3G+3Qa3oXvpjL+0y5lH6Yzbj9N8rB+cK7/ANPqyMNx1VZvOpQfguWvHxdsAY5tK3Y+irULlm8pznBdr69uJbbJ5hHa5MrtaJO8blNt9aZjUJtE22KbxDkSq7eV/8grFIdzAy2KwzmLT1Ecjp1+hOJwDu7TFIfj579GcTjetvbAy/CM6zy/lD9bHk3ANxXX22bwfB/aVXnlc301Zfn3HAat9yoUhzZWBX1ukX7StKkd/aTQv+ewGJDfnn3AtRe1JmI6UmtnFYrD9Y9qq5uPrVOZzwnTMjl4Xeuj+f9q3YnXa5A/r9d0yS3e8XrYIOs7u/kzrnneB/z938X8ff1woT3/s5mG/pLRv5SG/rLRvx/ol9hu1o3+A0nod/TzYBr67fx9KKfvyqPd1s3DaWRv5+0jaeg3jT76GaXQz6NAP0tA/7E0+mnTfzyNfhq2fv17eeVn6x/Y/y4y/4/veE0Xvzec4lM9JJ+q4DMnvssCv8aH3zEfpGV2ZXxOCz7WJ5iH90exRm38p13KcU5nXDFP8rB+2K9tQcg6T3E+cFleEHwWBJ/jSMt0g7o8rP2iHeIYrZ/9Yv4chf0a/2HZr8q/mP2eEbLOU5wPbCdnBJ8zgs9xpMVl2+irX+PD70LlZFD7xfw5Cvs1/sOyX5V/MftdFLLOU5wPbCeLgs+i4HMcaXHZNvrq1/jwu1A5GdR+MX+Own6N/7DsV+VfzH7PClnnKc4HG4dlIq4i3k0cY1pcto2++jU+/C5UTga1X8yfo7Bf4z8s+1X5F7Pfc0LWeYrzgeu5c4LPOcHnONLism301a/x4XehcoL5cdr12gSPe9U6yekInwnBJ+0aU709/3wuDf0VtX5mcx9+3vQ/k85sbQX9Ynk9y+IR/yMTHZq/m79T65JcxyQ6b71wHcP77NOsA8TP5UX9cB0zJWRVe8C5LB/mrIdRpxU72+FW65jY3Qox+020b6Cw/Rr/Ydmvyr+Y/U4LWecpzge2E7VfQu2xPY601Fr1Ye1X7QkoYr+jtg8ntf2q/IvZ74yQlfd7+sB2ovaOKh/940hL+VMc1n5je6Rj9pton1Rh+zX+w7JflX8x+50Tss5TnA9sJ2q/jvIxOo60lM/PYe2X7dCH2B22mevNu1h+qjUzLicT8B328d+RaZ7Yx8exD58JYfjvgT7+PVk4jbxmiDLPUxzu6VmgOLTdMxSH65CLFIfrJWcpDueiJykO+4BTFIft6zTFqX2Rak8c5/2gdXG1IJ/aIfnUCvKZOySfuYJ8Th2Sz6mCfOYPyWe+IJ+FQ/JZKMhn8pB8JgvymToknynBJ2n7vrS1ZLKqNRd1t6rh1Rx3LYJXc4pzEbyagzsVwd8h8PMR/HmBX4jgLwh8bM/wnQI/FcHfJfBqPGVt3N0QlzdBbVt5C7wv0VaWM+JnsuI75D9NspYqD/QF3+J6dXe30J33X7Y8u7x347GrN/auo9xI6+cmOu8xHsPPge+RC+AszRhnZY3bwcXA+7OB9+cC7+8IvD8feH8h8P7OwPu76L3F8f2qfA/ZLP2PdSmHjP74PctUVrxLSLvseHtXCTxn9D4jjHO6vJg/aexOyUpEVsNVhEzqDsoskpYs8h3K/ECrW2bFc85p/flgdWeac3jXGxnxc07XnW2fc9er3xR1pzpHT7X7ac+dW69nrrcOqQieNZIn0f2B62rdgccT6txHdabQBOHx2b7Hd5/MDYLn95E+90194DMP1RqL6rMoWg+VSOvREZVrVGml1Fds3QnLk7fdj5Adprqnnc/lUnfNFqkfFB91rnKRdiDR+ZqF51ON/7DaAaVX1Q7wvkT8dp7ifGD7U3dKq/OPjiOtxLaz3m9+8/OZTpOa3/Th/lYnHvFfyDo0/07+rPqCVoZnCvLE75nnl4DnOya68VafTQRonib6XMf5YP1Dbk+x3T0RwE+RzIb/mVxmT+8PAzKH+gYzRNPwrwLN/z6h5XQuPs41vDofS61Dq3nfWdefN+oZ96Dh9yecTj/2nRD/yxGdzsI3Kj0zAZq/GtGpWkeJ6bTfeWw8J67OY1PfIa4SSF+/c+h47bBo3qGtI5+ieWf4r0XyTvU7UK5HCsigbJdl+HpEhjn4hudjOY34v9rX7wOfdWj410CG/wlzRMyjGuDnXHzOMHZWeGqfCh5LYzuIbdE3qS1SusdvLf85P++BtbZ/SW0R9kFMxrR71ho7lm6cc3Skk7cCb5SRQ4X+R7m97Xx7okOXccwT8+itFIfl5m0Uh3XQ2ykO14u+A54xXXhvA7Y3ZgsTrreewnxPu0dr8Pyapbi3QRy2jxxUXlqa/Hd/MkBeos1wXqJdm2yq/ea5CktXqA+FY6OD9LQ6ccM5/3O94fm8XulOL67J1FrdaVJrVrE1HLVmhXtaTEdqX83jxFuNydH+rT+k9GkyHoU+UcYi+kT8oPpkP13cfxFqa5EW6jimT5PxKPSJMrI+F/qkifUZs2fUkdqPNU20ivbXR628o4ysz6Jndcf0r/rLyp+AfTpUeUcdx/SJfRMfqhCXWp+x+3ti40MfWJ/9xh9c3lGH7LtymPJuMo5aeS/7XHEu72r/ybi8F9cnl3fUJ59Br+YDj0N5j9mnspGYffabP+Jzz1HXfA4G9kfxjh6e61N6xzlL1HtGMuPahc2FKh9K7nuoOR20B25b54GPwhu9GuH/fC6smpuYh28qrrfOnAnQ/ItAk+e2VPsXm9vq1/9gf1Yci9i3qjzYu7Tl4Y37A7g8YN4W6Z+dOoR+uDxg/4zLA9ogt42qHsNywWUAbQ/nzb4ZKQPVAjxj/uRqToz9pO8F2/zflW5+FfhGlXOeDzL8ZsTeKyCrGuPi3lL/p3wGYz6PymfwDsAYf6Xv8wV44xwCz6dfGFBW5X94ATB3kKwo350Dysrzx3cOKKvyfbwzIium464BZX241Z93TNa7Bf6uiKyYjrsHlPWRIctaEbLyfOwHYD72FZrbRnu3Nn7U2gPUObcHSr+IH1S/XGdi/p+nOJy743xRfZfjpNdYvelcsfoA6yfWK+r8AsVhOxvTK9+VfjvqVbUhMb1iPXsnxWGfOKZX67eO9ar1WqE4XI80nljXZvQd8iw6TqoAXdsTp9YnOZ2Drk/i97xea/XdZyJ9xNgZHD5wH9HwfyPSR1S+JGiv7EuixswTIs2Gj92Vi/yVvmcK8FZzZLH+REzWfv1Z9mVA+c4PKCv3Ec8PKGu/MsayYjouDCgr9xEvDChrv743yxrre/eTlfuIdw4oa7++N8sa63vHZPXPPP5KLeukkJV9NX4e+rOvR3w1eL8ululTBWTKIJ7l4e984LrN8L8s6rajm4PUbSvmE7etsT6zD5znsb1dqLN5wmN9pfalGk+V1zanM2p6jd2FqcpG7C7MfmMX1ivq/A6Ki+3DRb3G5ghHVa+qTY3pNTaGVHpFnfOYEOcPY3q1dfXbWa/9+iqsV2xTY34IrFdsM2zf5dGtmWm9xtbMVP8ztmYWywelV9WvUucT8hoL9llUf4HvKLHvTwg80uP2/D+JNRZ1/gGuQb0eGCP4oMYdPLaaC9C1MwVT2sjaev1g79yBrK2OTnB86Ih/jfB/kKcf9Wu/1UPIub+21dhf3trfWtna3W3ubJ0h+j6YPc4k4N9c2Vrb2VprNDaajb1mY2XY/HdWVrd3bgpR32v4f5eGzX9rbW+jubq8tLO8v7G1Xl/vxx/v07CyoOYZ8HveK6zmGTJIS4zWA0SrQnrA72oRPjw3jnikoehn9FfrI/PDJLPiad+c6EPrEaKl7vmeo+9Q57G5njkXTvNcRHa2C46vEU8fbD9UjWT9dznzg3XzSjfG6E0CplbRafbhUqs7DvdcmSz+3b/NaUy5Xt34v4v5//VDheae2j9eHv3VfbXfuTz6a02jP5lG/hV1Tmh59Jfq6hzHEuVfV+fwlEi/faftbJr8lXfdl0hf3n9aIv0lo386jf731L6REukvq30OJeqnXb7OpJG/XT8sJqG/tGv0z6bRT7v8nkujnw2jf0ca+m37P59GP+3680Ia+qvWTuMcp7XnxhvnQsobQzd3MuLnXHc/yBH/aZK1XHk6e+5j89k+cL/ubiGrmp8rMten/AAVrVqJtE6WSGuyRFpTJdKaLpHWTIm0ZkukVaa+ykxjmXLNlUirTFs9VSKtMst2mbo/PaJpHNdft0f9VWYay9T9fIm0yrT7hRJplVm2R7U8lllHj2pbW2Y+nimR1puhHXozpLFMucqsV0e13V4cUbnK1NfZEmmdK5FWmX2TUW3TxuXx6NI4qu32m2GcVqZN3FEirVG1+/Ml0hrVuY4LJdJKWUcbFv0u7Mw6H+xMI17D/1e0Zp7mTPTmrjpDLnPdvCcT8c6In3N6TQD3MbI8Jve0iDuM3852Y395r7693Vza3l1ZXV3NiL7Jyu943l/t11HrC2rtvERdb8f8Ui2uCnG8d7QGcSajx2yR/FOJ5C+if+Q/L/CPQRoGycszrtvWsDwqvxg7O5z9Ynwwvxz0i1F+QRnRV2do+9/fqXRkxe9QRkyfOsc/A/7qPT5n9B75Ir/NVvd3fG45y8LprQg5lS4mhC6Ufxb7YGE5NXq+j2f194mWawcsMz6czP+vAl3EG+0a4f8r+FX9Psh6gBX8PO5/RXBZ4PeAhnhXbXW/m2r14iutXrzxnm71ymhxMxCHdYUPs/n/qC+kZXLUCP/tHGx5Mgnf2Pfzgv8k8e+SW7xDW2BaFfEObe5bOaB9Hi/wLnu9+oAn0cd3LJvZTgq/1r3t5sba9sbOSn23vtHYWO7n1/pYHjFFcWXraUqksyz6643mNrbnCeRfVj6S5dFfb/uYVNLIX7c20to5lRYHv4bjbxDzCGB4r6VhHgfM4wHMuwHz7gCv9wDmPQE6TwPm6QDmewHzvQFe3weY7wvQ+TBgPhzAbAFmK8BrBzA7ATqXAXM5gLkCmCsBXh8FzEcDdK4C5moA8xxgngvwug6Y6wE6LwDmhQDmRcC8GOD1MmBeDtB5BTCvBDCfAsynArw+DZhPB+h8BjCfCWB+HDA/HuD1WcB8NkDnc4D5XADzU4D5qQCvzwPm8wE6Pw2Ynw5gvgiYLwZ4fQkwXwrQ+TJgvhzA/CxgfjbA61XAvBqg84uA+cUA5iuA+UqA168A5lcCdH4NML8WwHwVMF8N8Pp1wPx6gM7XAPO1AOY3AfObAV5fB8zXA3ReA8xrAcw3APONAK/fAsxvBeh8EzDfJMwUPDtXcj+j3txI206v13kc5CAtxjvNfUfF7+Ez/tMuZZ+o4wuq9kahftAX9ADT6siTUVy11ZsONZdi6fbzDk8Djm1rAnDb8HzFdcvQb68UzzeluCdpvb6zofbKlJdna3WVBzhP4EMV4vhsfcyDk6DPpwm38akObqKArituyLpuLG+l1XVjaLp+GHRdJd2lmP9GO010p+bSopAfeflg80PO6XkY05/pCedBeB4G53SqrW4+NueB8zBIy+SoEX4r/1/Njdn384I/zlUwL8Wf52HU/NSUwHt9fiB/9nMNNkbH/exllgejv5mEfn3J6F9KQ789R3J/q6PLkmi3dfNAGtmXjf6Daeg3ba/td+dGqPphWYn64jlt44G806z9rY3vQ47rZ9TuQ17js0fYNjKX7j7kz+S/ag02tuZmdUwm4iri3USAliqDt0qrTLlGlVZqfcXOocQy4O3tRv7Ma3uGVb/O9dZFSkbEFLljflA+aevgel2d5c7rnSdEOhL3+Qu3Dex/keje3XbboO6mUHdPp/VdadSLlCmUV9Xd7CPXr+7Gc1MHqbv/bv6rzmPm9iNWro23Dwf3ElPalA/RrZZrdbd1rDzcKp9YO57GdurraX1l6itpfYnqq+ocjjL7OeocDlce/YbyAbG89/bwFXiPcaF7MmycyefofBVo/v38Wd3hXaE45ZuizmM6SXHKR2hGpGNCpIPt3f+pO3lUWbL3pwUe/UdrJG/szGfFG8cFl1rd+PkBZVX3zqC/ON+zg/ItDCjrZqs/75isZdwJVFTWB1r9ecdk7XcfJcuK6VgcUFY+e3txQFnPCvxiRFZMx9kBZOW6PsQ7Jus5gT8bkRXTcW5AWacL8I7Jqs6zPBeRFdNxx4CyzgxZ1pqQle9n+ff5r6+DvzPr/h7rPK73sa6sBtKl7ibzgdsgw/92/uvr9qVM05xwur4++nsj1g7u11vJOnJwntVa3Wkq+94I05G6N4LbLHV/F9qjtVlKnybjUegT223WpypPiGd9no/oAHWkzgjm/VqqTUcdx/RpMh6FPlHGIvpUd7wVrZ9MR+psYO6nqP4Z6jimz6Ms7ygj6zPWj/OhSDuKejIdzbteXXNfSpV31HFMn+31svy3CnFHWd4X+qRp0L4pl3fUIff3bsfyvtAnTYPqk8t7rE86Lu/99cnlHfXJc2NqXQr7YJdIVtPhCRcfD3P/8WyuD6+bR7Ju+XD8z7ag5pBVv5XnDbBPynty8B5dZb/c7zT83ZCGJchfH5QfSVo7a0g7i91LG5vL8IHtTNVd2D/kehD7OkX8ilQ9yLKeEHhlZ4a/J2Jn6i7l2JwpjnVi6ZgQ6Sg6HzfqZ/jbosltd4b/TQFW99fqK0u7zb2l3b78U+6h28gJeLv4y1Sv1AQ/j3s4gssCvwc0xLtqq/vdqO+heyAnMMp76C5SucG0l72GeMCT6OM7ls1sZxTuxrB948d6D129uTasPXSVNPSX0vrHd/bQbba66Tviq/ae2zfKv9/aW9/eW5vun08DPR/Y18OHlPsSb9rEauI8aywG5PfBfP5w/aCrbiBdIB3lq490R73PYvOZR91neVv+PK7boiHx/uB6Y1j7gzdbHfqqTMbqtn71F4+PMO5+wTdlmm/axEri9qK9x0C1EVa3WTmvCCyWBeXjgHgn3mUuXD/yPjkH6W4sLzfq9d21xv7u/vLK2sbSdmN1eXV1/+Z4Y3W9ubu/0tzaXdtrNLeWlzb21ur7jfW9vbWV5Z211f2N3Z3VfU7rRCRtsT1V/c4EGfU6/K35/0ddh/+Z/Hlch0fDuH/qxv1TCoX6p3gGHeq55sJ1W42wtj7o+7SLAXpF+ruVwHc4RmUarkR9KTkyIcdx759/R/7/Udftl/Pn4123r6yO++fxYHU7+tYV7Z/bN76usvLnn98O3/iA5/xw//xhwdfi8OyfCsW9C+J4v/2jEMf7lvFMQN63jOcInaS4JyCOz0rEs4X4jMUnIW6a4vC8Ifa9egriZinuvRCH67b+f1xvLLE93FB3AZZoh7uLQn5e40+zv7ez/3YzDf1G4v29y7y/t2T6zcR7fHetv7OV01N9Re73JaoP97j/4lzvuhDyH9ZZJRWSh/Vjz76usLm1y3s3nnh++5krO4/svXj93md3n9i6duPK1jP37u5e27t+HVOjaliOx8AYxjG+aCo2W2/8xnZN2Pt+p7fcR7RUD9ZoFV25jt04bd+dCPBBjDodAuNDN1qjzCf6yHw/yax4pt1RXV8xWScjsiJ/kxW9ESaHI2v7xOepAWVVO6Mr9D/jEHNCfI/xk4J3NhydrJlOpgfUCaZ7ejiyrpusMwPKiiOtmeHIumGyzg4oK+5+mKXvZkU6YrameM8I3kOytS3TydyAOsF0zw1H1vbp5KcGlBXbzVPDkXXHZD09oKyqJ6483RCHmBPie4w/JXhzGxeT2QfrkZ6O8FSz/Tyqjc1mxnbqKy9L3h2N9aHaFT5DcVgG5yhOeW7yLmlsM9TpHdMUh/XfLMVh2bL8Og6zaPv5/0c9i2YzIcd8hWRrvEISD8NYITEvdv98Buj5oFZILA5H7TzDxqdqYRzO2g3ndL7OqkuitrAZO53PZiFsJtPXfbZb7eZI+uYY+n1bz1zZ3bpx5eqzT+499/ze9Rt84EyF/ud4vhTDWCOOQ0b/86RIRv9PCByG2AKJag65yVOL5qqpRLWOenNhEyZH3VyMHT4LheXE1flyymrOB9VchKaUfLDqHZ9NplttUrisI21chPfPuHlR1R0X3eH1Ynajuupl0PdhUciP5Q+dQmfh+dmrN67sv/jY8888c2X/yt7uY1dv7DkKXPWHqmVMFn/HwXBjv9LiVSjvqz+mVejKsKrQLA39euqirKpQVax9kZ6FZxxRh75P7FvUHAXfIqvSvW5sZH+zl/vk1rO7Vz92/5W9Z3a5BkPtxsJxqK1sl/9R11ZL+fMxr612hlVbpVo7SHySr6ytMC0WbzYcugHrMB2+xF7vq4l12OR5Tud6a+xEJziuqLqvQu+Q/7BOR1Xrqup0VLUTn+d7qq3edPAOWsxfj3kL4Ni2eH4aJznM64vn0X0we/f03wm8/lz+nHgQsnOUgxB7d7LV0Ud7pADvaqC/A/0gnuJwx3K11c3nVm+IuCf/f5RviLC59xnX6fV8N9DjsmLlB/sR6FVj869vDAbvu7a3dUMPBdXVt/j/REAIni0MzR4ifRfhxTQRd1yGlY38/6PuqFnE8e6orW0f75m5paHNzOGiSWxmznD8DVYkDwLmwQDmIcA8FMA8DJiHA5giV6e+CzDvCmAeBcyjAcxjgHksgClyTesTgHkigAld5YqYJwHzZABT5LrXpwDzVADzXsC8N4B5H2DeF8AUuVr2/YB5fwATun4WMR8AzAcCmCJX1H4QMB8MYL4fMN8fwHwIMB8KYIpch/sDgPmBACZ0ZS5itgGzHcDsAGYngNkFzG4AsweYvQBmHzD7AcxlwFwOYD4CmI8ApgKYK4C5QphhzfqnqdOXGmoA0u5Quu4+WMm8lzLi55weOBr/YV25FHM69iE2cMwortrqTYcaOFr++o74JuDYtnhVGSczzH7V6pXZraf/OPB6ynXLjt9UiL9zvVvZU+TFen11K63d62scY4P+2LWlobzz4SXAse7STDZ1dJemnDQasSMWzFZGfZD+WP7/KA/SH8ifb4NrHFNv82qm3ebVrNskiR0hn3qsVWRCd3zd1fi6K3y27/Hdbv5b9nVXH6K0pb7uivtm/Y7mqRH+ZZD9rxJNlY/YD2IH0imgxXikVyP8s/mvj/9dp2mG0hWieR1keS5/VnWHpcG/e9Hp9GcurtOi6Z8IyPqC66T/vwVkRXlQ1pgXpf/9ZARXE7iMZK043de39ipWH9+qnWOaue7CclpmO8n1jUo38/d/M5CGiuutgxivbArp81U17bl2p+tSPrbZ8D+Z/3pd/vWADM712rUPmy0twwk3WBn8ifwXy7XKY7Rrk1ttlIxtQPXhYv5bP1xopLW1pTZ9vkKpJPnbblQzaeivK69urEv+NvE1V6qidbjhvwQ0v5A/q03e3J9Q3uYzrndDlHOHr6twcxX3G07BN6qcWR1q+HngWyEaCm9jNKwb1JHxfKT7q/mv1/sf5M9q8xbm6d9zmjfm6ayQlXn/BtD8pfxZbcrk6wdw498cydKee3Baz3z9gOF/1XX08C3X0YMPOP9hcqVc97TrB/4HyMG2Wmt1p1ttdEQ8rxn3u36AbVtddchlGmmpNkT1XXmDIsppdFU9ouQ/Jb41/ALQUnijVyP8P85/VX90Ab5RZa4aoPkNkOU1151+zINpwP2bAG9Mf0Wkx/BnRPoRv0CyGv6fuXD650X68aqUKaJp+H8ONL8VkBPTpepce9/v+kiTR111ad8q3RsOda9ocP1j/KadtokZkhXj+GikWNlWV/zE8lpdYcN5/R/yX9VHmwvIGZIP64TN1hu/ql3Bq0isXRl1n5L/kv9/213bMeD1AmXzX1pfX91Y2r65ore7s7/bXB42/9XmamN9fWt9Z3Vnf6O5sz1s/jsrq9s7NzOhvtc4UMdRXpvybcPe/Puj/JnXdZCfx/1JBJcFfg9oiHfVVvc7tSYwStem/HH+/yhfm/L/jF7+i2kvey76gCfRx3csm9mOt+vvygkcb1+51d3j7SvXWBqWrxz6mcV85WKbGgwT8k1DTMg3DTEh3zTEhHzTEBPyTUNMyDcNMSHfNMSEfNMQE/JNQ0zINw0xId80xIR80xAT8k1DTMg3DTEh3zTEhHzTEBPyTfPxif2Ytofhz4FlzEFa0voxFV8vfbP5MS0Bjm0r5sdk9qv8mMxuPf2/Arzud92yI73YWDutL87KbuJ2TPoxcb5WW928MQ7zrgr6XCL9pOinoH5S6N/rJ7bdl8cRzun+t+noqHyVvif/f5R9lVby55Cvkv+7mL+vHy400/oqdXyhLiWh3zlSO42vUqfv/0Aa+u0jtR9MQ7+dvw+lob9n9B9OQf/m9Ib5iuGcQahvUqTv4AOvWfAhzcinViIf7K9xm5lqM7OlaRLkVOup7EOFY2rlQ8B47g8y/anhpLfHnwzXOdVGeLVu71y59YenmWjdfr1G6TW/DZ/Wp4knrilwHvnAe8ZmKY8Yw/5kc8CbdY7f8prqB/Nfn4Za1k1T+ajhwcubRNPwHwaak5mW07l4f9beq8N3cZ3D5FGHw56i72Jrj4o2X7Oh6PDaEqdzAt5NC9pmo7w+dDH/v37IYPTQ9yATPE0eXv//GMl1hnQa05n/WxB8cc58mvguEF9vQzNkQybbjNP1C+fJCeLBdsX+BoaP+SSq+tjjXgrwxrXG00LWKaf1dzH/v36osNRjB6gLlX9sB5/Ifw+uccvCujghdBEblw/DR2OB5MV6sUYyqfpJ+WYPWj/Nu978naQ45ROKdQrzUX4YbHchH0Cjxzb/Y/nvwcEcWbd8NfE9+iueFnz4G5wvjrWDaq4F/Zt+gujiGplqV6wPXiP8HwHNz+XPKecK6nCJgaVH+ZsZT5Qn0cE3dbaZkO9qxXXr0PBfcN15gZcWVFyvHVQIPyP4oj2zX9wM8cU2oiJ44DgisS9qPTZ2SZyPGxnxM33gO+Q/7XTeXCxHnugBRqgfHo/NpJFn3fct5l23ffiA42fMG3VRhqqXsP1/Fd5zmVH10qVWJx7xvwQ0fyF/Vr606C/LPCcCPK2OVX1mHo/zXiUf+OwKfJ4U6UUb5LJs+H+Q/6oxg7rsRdkP1z+IZ5tyTvusczuqeKPt4NwXfh/y4Zuh9Bv+H7lO+t+ZaZq1QHomAjR/A2gWGYfFdDroOExdKlFUp1YmWNaiOjX8a5D+dwbSX1Snhv+nQJN1qnQU02m/C1NYpzH/vn46xTlU5FNUp4b/F66TftapqutiOjX8vwaaw9YpppkvwEHZ1T4gbkvVd9MRmrMBmqr+CrVLobxUdRrn5X/Mf1VeqnTNFkzXXEnpmhswXYZ/PVG6KoF0VQZM12yfdHE/2/C/XyBdWPaw7d5sddM0/B8CTSt7aryOe7l8qLa65b2Yv68fKujxOvYfa63udKt6D/GD9g1MZ/NOl1GMw77SJPFRNpHBO+s3qP6kfYv9STW2Dl1wGeprbrY68Yj/v/lvPxvAfroP1Va3zBfz9/VDBW0DWOezDSj/kFgbETtQFXU273rzltde+vlnWD4rmzEZlQ3gmrTNdYy6z301J3C7+dwftc/7oD7nt53P/cbq/sby8nZjeWN3b6OxepQ+9+dyAr5cnqe6sib4edw9EVwW+D2gId5VW93vRt3n/h05gVH2uX8L1VuY9rLnww54En18x7KZ7YzCXqKfz5+Pt8//ytAuMsjS0B/atSuXWh36qm+ClxT653OuG9+vb8TzvpUk+f3GNTvc9yqxv7qWynf1Kuknje9qRz8p9O/1E/NdTXseXKcu2UxBH3zkXorkVVZeeurKlzwj3onsfL1IHwX5T7uUdtVZX6qSPKwfrmcS7d1Y43E4ylMT+mF/BM47HG/imB7xuIaMeHy27/Hdn81/Y2c4ZRTnhAzO6QsZUvuKVohPpQQ+bB8+XMx/64cKS3Ved0Q+yi+Fy3Qan82l8RmJcf0cqzMS/1L+q85I5DI9yBmJTUob9usOW6ZRrth5YSn6z4nOHV1jm3Su3P4M522Z9q58psuUX811oq/aJrzHODWnze0j4h8Cmnb+cD//CeUPwe3KTIAf1ufsp/QoyPL+/Ln4lYzsqRQKlnO8YnEx/79+uLCrTriyYHGnCsrNs8ooty81LaDLOOaJqzfGX9Uu7ImJtROeaGg5FPOOOS14T1CcWjlSnhOhVWD0xFXf8clNhkfv+88CPnN6dRxX0LiV6HcC2RylWZ3WdYSrieteBz8JcnB6a63u9M4NqJ/YiW6Gca5jc6g79opRvWy0dxshq94wyqj+Rxtjr2Pl9TFILe2DzY47p2ehTc9HtfPUTt8d5Z2n1/Ln43Bj2yv5/0e90qdmXrjXefEWZeEQ6/2mnXkpPkrjmZdUM/QZ8TN5WD/DmXlZqqNnL+pos9WrGyWHD7FV+Nv9JLG/adibf3/LdfRxgG318kPPlDfjqubP5P+P8qrmF41e/otpP+pVTbOd22dVcbU5XlWMh/Gq4iChsT9eVYzrZ7yqeDusKi7Vb7Vv+yZZVdzPiD7KM15VHLyvOV5VHK8qmjwhmxuvKo5XFQcNiVcV98erimH5x6uKb4TxqqKjdI5XFcerimXXZuNVxV4bG68qjlcVTb7xqmLxMF5VbIfxqqI7vK2PVxU7odrqfjdeVXwjvBlWFf9CTuB4ryo2h3Y/UaLZ9KW0bVhnVZHPQHfEl+th/Ea1wXZ30cF5p67zfAfQ8wHvL+J2O9HK2k7iPGuM0sqaK4926vsQlhPfh9BU9yGk0E+i+xDq6j6EEuVvWN99O6fnx6e2cnRzNuyhZ3f3PrG3+9TW5ctXnr38nr2da3s37r3+nr2br69x95sXmHBBjIOpiWlk9P9EhIZzeiISF43UUThc5SSa3G4WHSrgcdfpuubxq6HU0T+mu5NCVnXldb9jMPndRITWRIm0OL8xPy7mv/XBwjK/SH1MLS9mYbC4aZHmTODVlK/J7X8/AnQZxzwxn6YpTk2LqYX2WYqLXaPO9YP6da7YgpcaXqZeWOOuVapFeT5690SJfNS1JKddb97xMeaDluGa4KOcDKzp9XJdDPBUR+v6YN0adsp43HVo3pc/p506qa+x/WPgY/3QftVCN9sz1g1sg+rI5qL1hunCy/VjQJdxnA615KOmfdpDa9ebR+/Of73MH4ZvkKbJjbL6UGQRXh0vqeycrwoatTZA5TPbBy5LsH3gMgrXK7h0gjrh0K/N+TLQZZwFlc+qTkFeNuRSdodHkF/Mn0d9uv9y/v8oTPfbkKHIdHyiYXfhPnZ7Ss/1tskp+tgVkof1w+VPOdRxu+7DZquD47iKeDcxZFpH5xRbXylqC6PqFMtjVfyW+0Q+bLY6OI6LtXnHhZZ970NsSUiNRXgpSfUXVR/cpom4jjvtwnljcuFVMM71ptNos8MSHlXL7WiZU0lcpyOvxH3bVTUOsaDGfZzv2KfifGcHPIxT/d5MyNCvb/s7QJdxFpSNZBSnnLtVn5LbgEzIFXPcVC4lfEw32j1OLyJN55x0+rV+lXLkC/UTYk59SgdcvvCKTE6TD1y+DP8L+W9ah01dvqYoDSchDUqvl1rdaTD8P8l/PfYrrltn6hhupU+2t9j4BuXmfFBO05ORNBj+H+a/fFS5D8N3Sas3vRxnQQ6U9UD+Vne61bH5iOcxZb9j89n9C8dgXIeoNhR1fh/Jii5iajzLDrKG/3r+67HflXXLh3Y9TbJj2rmeqQi+as5qCmT+7fw58Rz90OZcuF1COxi0XTJdDNoulVFPVInfqJRbnBPhcotltCLwXG77lXPrP8673rxk+1ZtwSBlxoeYuym6S1uZCY3PayIN/rvXgR7mI9bv+C3X74b/PyDL7+XPKfpEMbtU7RfbfdENN2q+23DK7ixdauPGUYxzjf+00EmKca4qZ7GNYomuLGzG2l+Vz95l8ZTrzTN17RT2mc1lYdA+OtcDRfroaO/9NshkREuVY1Uu+q0L85XPRv//57/++9O5ElT55XKvxnSq/HK5D43pQnkeu9pIbTNQ/TC1zWSuAK2TEd79rgdk3up6QJbFubDtqjbbdJO4zV5RbXZs+0es7+xDEV2qfFRXSs9RHJZjLo/IN7aNics42qnZL5YXNfeHfXhro29n1+cLWSe9d4FeDrCCn8d9ZwSXBX4PaIh31Vb3u1F3fb4H6lofRtH1+e35R6Po+my2MwrXxJzPn4+56/Xq2PU6Hqw92Wx103fEV/k72TdqvfVSHjfpYGuf67Rz7PuWIt+5fSxTb4tCfp5nXsj/9+3+PfnzlWd3ru19bO/ZG/d+/ONdTqwHjq3myeoo8Ep2Rv/380o9DhsHzSn/qD0J0HvGBzy6LEXNdzYN/bqaQTwHz2cpnWg7F0uSweiZHdRcb+Del2F5JJCVL1/DUVC9MAuL+e9ZeHcuIGuimZYlo59opkLaDM6izFCc5V1VfJcF/ld1VQibRejOiTijaXmF8lo6rFbGQxKMbpm6xNWDBPTb9Uei1fllZQt8bJhzusxwq851asmybrVHeiBDhXiyjIhR9sttaZXeVwpglf2iBw3Lx9/xzDC/Q+9HDpwvfLk408LZOcSfJGyqPFwUMpnsfwpJ+ocfC38fAA==","debug_symbols":"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FKKLMpFCdFEmUoguykQK0UOZZlKILspECtFFmUghuigTKUQXZRLK1EOZSCG6KBMpRBdlIoXookykEF2UiRSihzItpBBdlIkUoosykUJ0USZSiC7KJJSphzKRQnRRJlKILspECtFFmUghuigTKUQPZVpJIbooEylEF2UiheiiTKQQXZRJKFMPZSKF6KJMpBBdlIkU4pvKtMh2R3i2yiTXvUzbNF3vy0QK0UWZSCF6KJOQQnRRJlKILspECtFFmUghuiiTUKYeykQK0UWZSCG6KBMpRBdlIoXookykED2UaSOF6KJMpBBdlIkUoosykUJ0USahTD2UiRSiizKRQnRRJlKILspECtFFmUgheijTTgrRRZlIIbooEylEF2UiheiiTEKZeigTKUQXZSKF6KJMpBBdlIkUoosykUL0UKaDFKKLMpFCdFEmUoguykQK0UWZhDL1UCZSiC7KRArRRZlIIbooEylEF2UiheihTCcpRBdlIoXookykEF2UiRSiizIJZeqhTKQQXZSJFKKLMpFCdFEmUoguykQK0UOZLlKILspECtFFmUghuigTKUQXZRLK1EOZSCG6KBMpRBdlIoXookykEF2UiRSigzK9/N8oUw9lIoXookykEF2UiRSiizIJZeqhTKQQXZSJFKKLMpFCdFEmUoguykQK0UOZZlKILspECtFFmUghuigTKUQXZRLK1EOZSCG6KBMpRBdlIoXookykEF2UiRSihzItpBBdlIkUoosykUJ0USZSiC7KJJSphzKRQnRRJlKILspECtFFmUghuigTKUQPZVpJIbooEylEF2UiheiiTKQQXZRJKFMPZSKF6KJMpBBdlIkUoosykUJ0USZSiB7KJKQQXZSJFKKLMpFCdFEmUoguyiSUqYcykUJ0USZSiC7KRArRRZlIIbooEylED2XaSCG6KBMpRBdlIoXookykEF2USShTD2UiheiiTKQQXZSJFKKLMpFCdFEmUogeyrSTQnRRJlKILspECtFFmUghuiiTFC7TPs33Mh2/LPx6+tev+Q7lsUxKUc/pVtRjvlqfXqbr9ullOX759I8yVU4hOipT5RSiozJVTiE6KlPlFKKjMlVOIfop01E5heioTJVTiI7KVDmF6KhMlVOIjsoklKmHMpFCdFEmUoguykQK0UWZSCFSlEnW9fZpOVu3VHZZfn54399Kuu7PjvJ6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eVFieVFieVFieVFieVFieVHieFHieFHieFHieFHieFHieFHieFHieFHieFHieFHieVHieVHieVHieVHieVHieVHieVHieVHC0149T3v1PO3V87RXz9NePU979Tzt1fO0V8/TXj1Pe/U87dXztNfA014DT3sNPO018LTXwNNeA097DTztNfC018DTXgNPew087TXwtNfA014DT3sNPO018LTXwNNeA097DTztNfC018DTXgNPew087TXwtNfA014DT3sNPO018LTXwNNeA097DTztNfC018DTXgNPew087TXwtNfA014DT3sNPO018LTXwNNeA097DTztNfC018DTXgNPew087TXwtNfA014DT3sNPO018LTXwNNeA097DTztNfC018DTXgNPew087TXwtNfA014DT3sNPO018LTXwNNeA097DTztNfC018DTXgNPew087TXwtNfA014DT3sNPO01nGivIb5hKLcFN2F2EiXxSD8ZgvplljrKt9RFIeFM023VHN9Xc0JXzTnTtls1R/bVHNVXc3RfzaG+mmP6ak5fs7Lva1b2fc3Kvq9ZOfQ1K4e+ZuXQ16wc+pqVQ+1Z+f0dVyGYztpjO2uP66w9vrP2hJ7aY0R6B1dJv58zopQ0mfZI60RsvnX/PL1gcyJrOFE1nOgiTrQ9nFj95CTxRZ7X+8FAWjyf+yTSx6mKeOaa0Me39z78tJ86b7+J+Fuj9Wv7zeDtt4O33w3efj94+8PY7Zdi8PbLwduvBm9/7+tvrv2Dr79y8PVXDr7+ysHXXzn4+isHX3/V4OuvGnz9VYOvv2rw9VcNvv6qwddfNfj6qwZff9Xg668afP3Vg6+/evD1Vw++/urB1189+PqrB19/9eDrrx58/dWDr7968PWXBl9/afD1lwZff2nw9ZcGX39p8PWXBl9/afD1lwZff2nw9dcMvv6awddfM/j6awZff83g668ZfP01g6+/ZvD11wy+/prB1187+PprB19/7eDrrx18/bWDr7928PXXDr7+2sHXXzv4+msHX3/d4OuvG3z9dYOvv27w9dcNvv66wddfN/j66wZff93g668bfP31g6+/fvD11w++/vrB118/+PrrB19//eDrrx98/fWDr79+8PU3DL7+hsHX3zD4+hsGX3/D4OtvGHz9DYOvv2Hw9TcMvv6GsddfKcZef6UYe/2VYuz1V3Z//lWu/WOvv3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrOfj5V3Lw86/k4OdfycHPv5KDn38lBz//Sg5+/pUc/PwrNfj5V2rw86/U4OdfqcHPv1Ji7PVX9X7+lQnG/zztvAzP7U88rGJnjTI2PhxSD0tSezskueNhbxIP603o2xu9rfnxYWVTjdZCqfg0+fi0Fi7xtJeWfp72ShxPKy8TT5MT+udpclIdv230D6OdZyRg9DKjnedoYPQyo51nrWD0MqOd5/Fg9CqjvZ8sCEYvM9p5rQdGLzPaefULRi8z2rkeAEYvM0pgdDJGoRnNxig0o9kYhWY0G6PQjGZjFJrRZIz2fhp2L4ySDHujyasMo0bIHQ8jyB1dtD+gQ9ZpADqUlwagQxxpADoB9PqgQ2JoADpUgAago1BvADpq6Qago9ytD3rv90PMCToq0gagT1WRWoqge6ffg+6l23/Z/xLINhHrAc1UdWNZaAjQnEEzVQ1WFpqpKqWy0ExVz5SFZqqqoyw0U9UGRaHp64aZR5O6ym8fTeoq+3s0qaus69Ek6q9JXWUZjyZ1tbo/mtTVqvpoUler2aNJXa0i303q636SR5P6m737ukXk0aT+Zu++7vp4NKm/2buvGzkeTepv9u7r3oxHk/qbvfu63eLRpP5m777uoHg0qb/Zu6+bIh5N6m/27us+h0eT+pu9+7p14dGk/mbvvu5GeDSpv9m7rxsMHk3qb/bu656BR5P6m737ug3g0aT+Zu++zux/NKm/2buvk/UfTepv9u7r/PtHk/qbvfs6pf7RpP5m777Okn80qb/Zu68T3x9N6m/27utc9keT+pu9+zo9/dGk/mbvvs44fzSpv9m7r5PIH03qb/bu67zwR5O6m711X6d6P5rU3eyt+zp7+9Gk7mZvLbqbvXVfh14/mtTd7K37Onb40aTuZm/d18Gv303q6+TSR5P6m737Ojvy0aT+Zu++Tu97NKm/2buv89MeTepv9u7rBKtHk/qbvfs6Q+jRpP5m777On3k0qb/Zu6+zSx5N6m/27uvci0eT+pu9+zoz4dGk/mbvvr63fzSpv9m7r2+1H03qb/bu69vkR5P6m737+hb30aT+Zu++vj19NKm/2bu/by11f99a6v6+tdT9fWup+/vWUvf3raXu71tL3d+3lrq/by11f99a6v6+tdT9fWup+/vWUvf3raXu71tL3d+3lrq/by11f99a6v6+tdT9fWup+/vWUhf6gCien7f9Ld1Tkx5OLk9+DzPimRmemeWZOZ6Z55kFltn1Dw0eZpJnpnhmvCjxvCjxvCjxvCjxvCjxvCjxvCgJvCgJvCgJvCgJvCgJvCgJvCgJvCgJvCgJvCgJrCghIXhmkmemeGaaZ0Y8M8MzszwzxzPzPDNelEhelEhelEhelEhelEhelEhelEhelEhelEhelEhelChelChelChelChelChelChelChelChelChelChelGhelGhelGhelGhelGhelGhelGhelGhelGhelGhelBAvSogXJcSLEuJFCfGiJL0ZQjaa/bri7zCzaTN5mCnx93tNwIt46aA+zpJVXiSeDX4XNEL4/eyjOa6v5vi+mhO6ak56g6Jdc2RfzVF9NUf31Rzqqzmmr+b0NSubvmZl09esbPqalW3tWTleOSyFUIn2yM7aozprj+6sPdRZe0xn7bk8Nz/MHM/Ms8wKnYL3dquPCp1rl3FCNZyYGk5sDSeuhpMybwCQPJyY8OTk2k74o0mhuyYVOvGtaJNk7SZtavF+H8wm5b5EUqHz3go2SPfWoDLz34X3SHILYP2j3rItst21yHXXIt9di0JvLap/ylu2RbK7FqnuWqS7a1F3c3bobs5ucL6bEWL/7c1/7reDiT8dvHzqgPzpgBu9A370DoSxO2AanEtXuANy9A6o0TugR+8Ajd4BM3oHel+JfdD700L/7kBC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","names":["add_credential_note"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","get_public_keys_and_partial_address","get_key_validation_request","notify_nullified_note_oracle_wrapper","random","notify_created_note_oracle_wrapper","build_msg_block","attach_len_to_msg_block","get_random_bytes","get_random_bytes","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"verify_note_in_merkle_tree","hash":"468063867033368075","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"claim_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"indices","type":{"kind":"array","length":5,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_root","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1433889167918961673":{"error_kind":"fmtstring","length":17,"item_types":[]},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5641381842727637878":{"error_kind":"string","string":"Got more notes than limit."},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11358519862625644973":{"error_kind":"string","string":"Merkle root verification failed"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"11873158822563704285":{"error_kind":"string","string":"Mismatch return note field."},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"18313900523101689315":{"error_kind":"string","string":"Note contract address mismatch."}}},"bytecode":"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","debug_symbols":"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R4YeeI9Maz3wniVuvHZcv5EZxpc/Otp57RSXTT4wvjyMxdIHydJvql8RydZ6bA3JDzatddlKNq312T9OvHZumu7WOzGO3qfMbl0clpv2uOhe2cybux2eux3m191+rChcvyL/XNH3myGEnRuF37miVNqKdm6OfeeKXHEr8tevyObnJ0vmK9/e1o84b2bflz/WvXyre/lT3cuf615+qHv5se7lp6qXb0Phy/fxufzvDZm5updf+lk3s/zCz7rTtPQ8fpr/7Q8RgxV+iv7NXjN/Whis8PP55MZ1ryFzX5S4PmE42suaP78HHazwc79yq4X3CcqtFt5TKLdaeP8h3OpUeK+i3GrpZ9bfbHValhHD/GWrGy/8+M/r5Pzllle2tUH//Gv64cuhHwhLP2FXgLClPuAmhC31FzchbKlvuQlhS/3QPQhDS83HbxAOz8cFuJdLYpsIY1wWkVz2j5ofv3u9/BdDeB7v0/TJvPDpTpPMCx9JNcm8127/TuYG88uZ9+oTdzLvVUDuZN6rsdzJvFfFuZN5S7PnSphHPPR65njo9czx0OuZ46HXMzeYX84cD72eOR56PXM89HrmeOj1zPHQy5knPPR65njo9czx0OuZ46HXMzeYX84cD72eOR56PXM89HrmeOj1zPHQq5nHAQ+9njkeej1zPPR65njo9cwN5pczx0OvZ46HXs8cD72eOR56PXM89HLmDg+9njkeej1zPPR65njo9cwN5pczx0OvZ46HXs8cD72eOR56PXM89HLmHg+9njkeej1zPPR65njo9cwN5pczx0OvZ46HXs8cD72eOR56PXM89HLmIx56PXM89HrmeOj1zPHQ65kbzC9njodezxwPvZ45Hno9czz0euZ46OXMS3/AbZPM8dDrmeOh1zPHQ69nbjC/nDkeej1zPPR65njo9czx0OuZ46GXM2/q4eW1MMdDr2eOh17PHA+9nrnB/HLmeOj1zPHQ65njodczx0OvZ46HXs58xkOvZ46HXs8cD72eOR56PXOD+eXM8dDrmeOh1zPHQ69njodezxwPvZx5wEOvZ46HXs8cD72eOR56PXOD+eXM8dDrmeOh1zPHQ69njodezxwPvZx5xEOvZ46HXs8cD72eOR56PXOD+eXM8dDrmeOh1zPHQ69njodezxwPvZx5wkOvZ46HXs8cD72eOR56PXOD+eXM8dDrmeOh1zPHQ69njodezxwPvZp5GvDQ65njodczx0OvZ46HXs/cYH45czz0euZ46PXM8dDrmeOh1zPHQy9n7vDQ65njodczx0OvZ46HXs/cYH45czz0euZ46PXM8dDrmeOh1zPHQy9n7vHQ65njodczx0OvZ46HXs/cYH45czz0euZ46PXM8dDrmeOh1zPHQy9nPuKh1zPHQ69njodezxwPvZ65wfxy5njo9czx0OuZ46HXM8dDr2eOh17O3PDQ65njodczx0OvZ46HXs/cYH45czz0euZ46PXM8dDrmeOh1zPHQy9nPuGh1zPHQ69njodezxwPvZ65wfxy5njo9czx0OuZ46HXM8dDr2eOh17OfMZDr2eOh17PHA+9njkeej1zg/nlzPHQ65njodczx0OvZ46HXs8cD72cecBDr2eOh17PHA+9njkeej1zg/nlzPHQ65njodczx0OvZ46HXs8cD72cecRDr2eOh17PHA+9njkeej1zg/nlzPHQ65njodczx0OvZ46HXs8cD72cecJDr2eOh17PHA+9njkeej1zg/nlzPHQ65njodczx0OvZ46HXs8cD72Y+TgMeOj1zPHQ65njodczx0OvZ24wv5w5Hno9czz0euZ46PXM8dDrmeOhlzN3eOj1zPHQ65njodczx0OvZ24wv5w5Hno9czz0euZ46PXM8dDrmeOhlzP3eOj1zPHQ65njodczx0OvZ24wv5w5Hno9czz0euZ46PXM8dDrmeOhlzMf8dDrmeOh1zPHQ69njodez9xgfjlzPPR65njo9czx0OuZ46HXM8dDL2dueOj1zPHQ65njodczx0OvZ24wv5w5Hno9czz0euZ46PXM8dDrmeOhlzOf8NDrmeOh1zPHQ69njodez9xgfjlzPPR65njo9czx0OuZ46HXM8dDL2c+46HXM8dDr2eOh17PHA+9nrnB/HLmeOj1zPHQ65njodczx0OvZ46HXs484KHXM8dDr2eOh17PHA+9nrnB/HLmeOj1zPHQ65njodczx0OvZ46HXs484qHXM8dDr2eOh17PHA+9nrnB/HLmeOj1zPHQ65njodczx0OvZ46HXs484aHXM8dDr2eOh17PHA+9nrnB/HLmeOj1zPHQ65njodczx0OvZ46HXs3cDXjo9czx0OuZ46HXM8dDr2duML+cOR56PXM89HrmeOj1zPHQ65njoZcz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IhypholqSM3btuQNj+fs4Hbv/zSrzReOIcFD/E8lXqCe6nF1fhLhT9TbajoUDGdEyX8f0WU/15beO/vIDD4Kg4863Edo35zo7MMz+AgMPoDBBzL4iAw+EoOPzOCjMPhgmOdt2RTq+SwP3uTf732UWwPwefHNxVOFbz6mfSWJh7YiOzWiIC4iEBcRiosoiosoiYsoi4uoiIuoSosoiFuzg7g1O4hbs4O4NTuIW7ODuDU7iFuzg7g1O4hbs4O4NRv416Maz4ientt9RMQ+1656Eegw16S8YOrr4wXdp2ehDlk7QN5orGWjsdZ9xopuo7H6jcYaNhorbDRW3GiscaOxbrRvwo32TbjRvgk32jfFjfZNcaN9U9xo3xQ32jfFjfZNcaN9U9xo3xQ32jfFjfZNcaF9U4DHWPH1UeCQFto3XY51oX3T5VgXqq+XY11oHb546Sikhdbhy7EutA5fjTUvtA5fjnWhdfhyrAv1r5djXah/vRzrQvX1cqwL9a+XY12of70c60J7ie+/THYb60J7iauxloX2EpdjXamn+/YA/dtYF9pLXI51ob3E5Vhxo7EutJe4HOtCe4nLsS6kwVyOdaF90+VYV9LCL8ZaV9LCr8a60b6pdqivfd8TqPzvCZxc3f6sjYjY38m5OOoy1CwuoiIuoiosInBOXEReXETs7y1dvCUEDsRFhOIikvZuF7gkLqIsLqIiLqIqLaL2yRe34nKeieKeP3Zxk5J/mbVfUL82CzQzYpBIM4s0s0QzyzSzQjOrJLP2qcPXZrQsAVqWAC1LgJYlQMsSoGUJ0LIEaFkCtCxBWpYgLUuQliVIyxKkZQnSsgRpWYK0LEFaliAtSyItSyItSyItSyItSyItSyItSyItSyItSyItSyItSxItSxItSxItSxItSxItSxItSxItSxItSxItSxItSzItSzItSzItSzItSzItSzItSzItSzItSzItSzItSwotSwotSwotSwotSwotSwotSwotSwotSwotSwotSyotSyotSyotSyotSyotSyotSyotSyotSyotSyopS9A5mpmnmQWaGdDMkGYWaWaJZpZpZoVmRssST8sST8sST8sSmvSHnpYlnpYlnpYlnpYlnpYlnpYlgZYlNO0Vador0rRXpGmvSNNekaa9Ik17RZr2ijTtFWnaK9K0V6Rpr0jTXpGmvSJNe0Wa9oo0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","names":["verify_note_in_merkle_tree"],"brillig_names":["discover_new_messages","get_notes_internal","get_collapse_hints","field_less_than","decompose_hint","lte_hint","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"constructor","hash":"974377266527945817","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3bTus6EIbfpddc2OPxab3K0hbitFClChCHLW0h3n2nXY1TSGjAuJ60+W8QoZ7m99dJPL9T7NfF9c3ly+358u7P/dPi1+/Xxer+6uJ5eX/XHL2+nS0uH5er1fL2fPfPC7X+od2m/dPDxd368On54vF58UuT1+pscXN3vf49ONu8x5/l6mbxK/q3s35zG13b2mnXNeaBxhyV3zbmuNPY0UDjwBy2jQM73m38z9lC+xLinYlJfKD94ol8+9ZkqGusWQ++teP2rb3md63X8sNxy49HLZ9Ucflxv3zvzLat913e8yaVSU9KDU1KjZmUGi6hxpNJuen9fjVGqfb2apSLI2lPSrf3V1I+9NLeHrd8d9zyfWn5gX+QymFSauKU1Jgiw0Pg1DrYkcLImtDKsaxof2GklbW2fWvV1F8fSiOjj1s+Hbd8c9zy+bjl2+OW76rLZ+7k2/BRj5+YnlBfj+ZOT9z/8bpI7aCiuvGHSG20x+PVzmVGRNdpD3pEu40pD5we0e6jbyuvoFiPyBi5BlnPqK80o76aGfWVZ9TXMkO+pq6vPGYLdTszaTSPNA46TUUFUt2ARmHIQ3LoZkib5qm1sWbTVzejvvoZ9TXMqK9xPn21akZ91TPqK82or2ZGfeUZ9XVGdZOdUd1kZ1Q32YnXTaS7vlo90lcfufU5PkYaaW1sK5p3vknRPIMaejKlo942biZ04khrS+3TUmvUu7Zr4hOv3k6PuJt4DXmCxCdeyZ4g8YnX0ydIfOJV/QkSZxCvTHziDucEiU/cZ50g8Ym7vRMkDs9Zmzg85wGIx3ZixWn7kbiH56xNHJ6zNnF4ztrE4TlrE2cQr0wcnrM2cXjO2sThOWsTh+esTRyeszLxAM9Zmzg8Z23i8Jy1icNz/pT4miKDYgGK8IYlKMLvlaAID1eCInxZCYrwWgUoRvinEhThiUpQhM8pQRHepQRFBsUCFOFdSlCEd/kSRTIdRaYeRXiXEhThXQpQ1AoFYxGMGKW/hNHrdkVS8h++Kfu91hvoGNTLQ9euWzbJ7SwDm6CjBhCAjpJBADoqDAHomEw9AHTvu6WlY7960Zh7FYCOylsAOmZ2BaBjIlgAOgN6fehwpALQ4UgFoMORCkCHIxWADkdaHzrBkQpAhyMVgA5HKgAdjlQAOgN6fehwpAeAHlXakTXSAHQ4UgHoZRxp+m88HY3Z5bg5R6hwjnj4c5TZIjTGNjGaz0Dvzzlr0nbo1rhOEDnzV1GJ2pOUUUkRhxFFKrSNm1/fbdU3cMlY3fY17C7xtt3Nvcimn9Rdw6Ss2q8+2vbSiVH3aZoyny93enQvh7jCOWyFc3xys45pR7AmOcntP4f17Ufn1MiVwLHbEyBqN5J3nC6bwI57eecLaHcJpjMj29izp3R79+z3a4/OpBx1LvS0Y17lS4OkUe1nSWbnLtsOe4yZkiIYMfdRBCNmM772deIQE0ZFY5WvSnddrZztQ8dshgB0BvTy0HUq4LXm/rcDp75Z6mlCx2yGAHQ8XxeAjufrh4DuEg8d+gPp1DdePU7oppv/M7Gf6VPfAfY0oaNOF4DOgF4fOup0Aeio0wWgo04XgI46/QDQLSV6dufZToKO5zX1oWP3ZAnocKQC0OFIBaDDkQpAZ0CvDx2O9BDQXfpKpg2xDx2OVAA6HKkAdDhSAehwpPWhY29lCehwpALQ4UgFoDOgH2A+vfvXKUP9+XTs+isBHeZIADrMkQB0mCMB6DBH9aFjE2AJ6DBHAtBhjgSg43GdAHQG9PrQ4UgFoMORHgI6c4Ju+w+msZOxBHQ4UgHocKT1oWNbZQnocKQC0OFIBaDDkdb/9xdsCS0BHY5UADocqQB0mKOfQm8w0vCmep7bM3h2/ZjB4bTrQrShH8MZMTYjxmXE+IyYkBETvx/zyRYT+5f9ok/2SBiLoqwokxXFWVE2K8plRfmsqJAVFXOiTFZumKzcMFm5Mbz67v67y/Bqut1ytJEGYjKu+uGVXfefZ3gZ05EYnRFDGTEZd2XOuCtzxl15eHG2mJZcir6fO8Nri43EhIyYsbvyQIxV32cwvILUSAxlxGTkgc3IA5uRBzbjOrUZo7PNGJ1txujsvpsHb83hvxePy4vL1c1TE7J+9eXu6nl5f7c9fP7voX3l8nG5Wi1vzx8e769url8eb85X91fr1xZq++M3eXNGkdcF8eZQ6TNSbn24zjaKtnnVN2dtzvw/","names":["constructor"],"brillig_names":["constructor"]},{"name":"read_all_credentials","hash":"15278231497803451231","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"addr","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"credential_notes::CredentialNotes","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"claim_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"claim_hash","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["read_all_credentials"],"brillig_names":["read_all_credentials"]},{"name":"read_credential_hash","hash":"17924188830751029501","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"claim_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"addr","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["read_credential_hash"],"brillig_names":["read_credential_hash"]},{"name":"read_credential","hash":"13402271329203771836","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"claim_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"addr","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"credential_notes::CredentialNotes","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"claim_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"claim_hash","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5672954975036048158":{"error_kind":"string","string":"Collapse hint vec length mismatch"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7506220854563469239":{"error_kind":"string","string":"Dirty collapsed vec storage"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"10583567252049806039":{"error_kind":"string","string":"Wrong collapsed vec order"},"11499495063250795588":{"error_kind":"string","string":"Wrong collapsed vec content"},"11553125913047385813":{"error_kind":"string","string":"Wrong collapsed vec length"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"15431201120282223247":{"error_kind":"string","string":"Out of bounds index hint"},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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dpy5toXHb+9L/Zg/CZ9/PPinGMLX+cfF558Wn39efP5l8fnXtefvt8Xn7xafv198/tLX3978F19//eLrr198/fWLr79+8fXXL77+hsXX37D4+hsWX3/D4utvWHz9DYuvv2Hx9Tcsvv6GxdffsPj6S4uvv7T4+kuLr7+0+PpLi6+/tPj6S4uvv7T4+kuLr7+0+PobF19/4+Lrb1x8/Y2Lr79x8fU3Lr7+xsXX37j4+hsXX3/j4utvWnz9TYuvv2nx9Tctvv6mxdfftPj6mxZff9Pi629afP1Ni6+/efH1Ny++/ubF19+8+PqbF19/8+Lrb158/c2Lr7958fU3L77+lsXX37L4+lsWX3/L4utvWXz9LYuvv2Xx9bcsvv6Wxdffsvj6Wxdff+vi629dfP2ti6+/dfH1ty6+/tbF19+6+PpbF19/69Lrb962pdff2/yXXn9v8196/b3Nf+n19zb/pdff2/yXXn9v8196/b3Nf+n19zb/pdff2/wXX3/d4uuvW3z9dYuvv+LPv+rNf/H1d+3zr27zX3z9Xfv8q9v8F19/1z7/Km9rn391m//i6+/a51/d5r/4+rv2+Ve3+S++/q59/tVt/ouvv2uff3Wb/+Lr79rnX93mv/j6u/b5V7f5L77+rn3+1W3+i6+/a59/dZv/4uvv2udf3ea/+Pq79vlXt/kvvv6uff7Vbf6Lr79rn391m//i6+/a51/d5r/4+rv2+Ve3+S++/q59/tVt/ouvv2uff3Wb/+Lr79rnX93mv/j6u/b5V7f5L77+rn3+1W3+i6+/a59/dZv/4uvv2udf3ea/+Pq79vlXt/kvvv6uff7Vbf6Lr79rn391m//i6+/a51/d5r/4+rv2+Ve3+S++/q59/tVt/ouvv2uff3Wb/+Lr79rnX93mv/j6u/b5V7f5L77+rn3+1W3+i6+/a59/dZv/4uvv2udf3ea/+Pq79vlXt/kvvv6uff7Vbf6Lr79rn391m//i6+/a51/d5r/4+rv2+Ve3+S++/q59/tVt/muvv27x86/c4udfucXPv3KLn3/ltrXXX7f4+Vdu8fOv3OLnX7nFz79yi59/5RY//8otfv6VW/z8K7f4+Vdu8fOvnPTzr2KN5WN0Lq4+z78x2B/BRh/TMbi2Bjvy+zwc5cfgEhuDgyvbPmlXH4N9ak06bN4fo6kco8OWG6OLS/Qxuvjt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","names":["read_credential"],"brillig_names":["read_credential"]},{"name":"init_credential_note","hash":"2057493422126266862","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"flag","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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act52pb0tC3laVva07aMp21ZT9tynrblPW0reNpW9LStNBmLYWX62VUoVqVYjWJ1ijUo1qRYi2JtinUo1qVYj2J9ig0oNqTYiGJjik0oNqXYjGJzii0otqTYimJrim0otqXYjmJ7ijxFoXoxrOwhsoqnbVVP22qettU9bWt42tb0tK3laVvb07aOp21dT9t6nrb1PW0beNo29LRt5Gnb2NO2iadtU0/bZp62zT1tW3jatvS0beVp29rTto2nbVtP23aetu09bXlPW2EyFkORfjaiKFGUKXag2JFiJ4qdKXah2JViN4rdKfag2JNiL4q9Kfah2JdiP4r9KQ6gOJDiIIqDKQ6hOJTiMIrDKY6gGExxZPViKHqIRJ62kqet7GnbwdO2o6dtJ0/bzp62XTxtu3radvO07e5p28PTtqenbS9P296etn08bft62vbztO3vaTvA03agp+0gT9vBnrZDPG2HetoO87Qd7mk7wtM22NN25GQshqPoZ4+mOIbiWIrjKI6nOIHiRIqTKE6mOIXiVIrTKE6nOIPiTIqzKM6mOIfiXIrzKM6nuIDiQoqLKC6muITiUorLKC6nuKJ6MRzlIXK0p+0YT9uxnrbjPG3He9pO8LSd6Gk7ydN2sqftFE/bqZ620zxtp3vazvC0nelpO8vTdran7RxP27metvM8bed72i7wtF3oabvI03axp+0ST9ulnrbLPG2Xe9qumIzFcCX97FUUV1NcQ3EtxXUU11PcQHEjxU0UN1PcQnErxW0Ut1PcQXEnxRCKoRR3UdxNcQ/FvRT3UQyjGE5xP8UIigcoHqR4qHoxXOkhcpWn7WpP2zWetms9bdd52q73tN3gabvR03aTp+1mT9stnrZbPW23edpu97Td4Wm709M2xNM21NN2l6ftbk/bPZ62ez1t93nahnnahnva7ve0jfC0PeBpe9DT9tBkLIaR9LMPUzxC8SjFKIrHKEZTPE7xBMWTFGMonqJ4muIZimcpnqN4nuIFihcpXqJ4meIVilcpXqN4neINijcp3qJ4m+IdinerF8NID5GHPW2PeNoe9bSN8rQ95mkb7Wl73NP2hKftSU/bGE/bU562pz1tz3janvW0Pedpe97T9oKn7UVP20uetpc9ba942l71tL3maXvd0/aGp+1NT9tbnra3PW3veNrejS2GPg31+UZHYF+iXwyGxNkjhvO9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","debug_symbols":"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lq79Wb70Z+t07c/CtT+7tpGu1zbSk1sdt6K7/9W2Pf9M9ai9jTd/+nl1vHVU394ivf8t8tvf4uRWh+pbhPe/RXz/W8zvfwt5/1ss73+L9f1v8f7Vvb1/dW/vX93p/as7vX91p/ev7vT+1Z3ev7rT+1d3ev/qTr9e3R9/lq79Wb70Z3m69mfh2p/Fa382X/szufZny7U/W6/92bUqydeqJF+qkjRN1/4sXPuzeO3P5mt/Jtf+bLn2Z+u1P9uu/Vm69mfXqiRcq5JwrUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSuK1KonXqiReq5J4rUritSqJ16okXquSeK1K4rUqideqZL5WJfO1KpmvVcl8rUrma1UyX6uS+VqVzNeqZL5WJfO1KpFrVSLXqkSuVYlcqxK5ViVyrUrkWpXItSqRa1Ui16pkuVYly7UqWa5VyXKtSpZrVbJcq5LlWpUs16pkuVYly7UqWa9VyXqtStZrVbJeq5L1WpWs16pkvVYl67UqWa9VyXqtSrZrVbJdq5LtWpVs16pku1Yl27Uq2a5VyXatSrZrVbJdq5J0rUrStSpJ16okXauSdK1K0rUqSdeq5Fr2mq5lr+la9pquZa/pWvaarmWv6Vr2mq5lr+la9pquZa/pWvaarmWv6Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9pqvZa/5Wvaar2Wv+Vr2mq9lr/la9ppPste8f8Mw3HbOgz87qZL9SL+Qc/zyZ0dH+Wo9KCSfZbq1hrP5Gk7yNZzsajhnmXmt4QRfw4m+hjP7Go74Go6vT+Xk61M5+fpUTr4+lZOvT+Xs61M5+/pUzr4+lbP1p/LPz7jKWZyNZ3E2ntXZeDZn40nOxnN8gHpI93NGYgxLYTxh3aZ9+Ov2r6cXLNPx/V7t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","names":["init_credential_note"],"brillig_names":["discover_new_messages","random","notify_created_note_oracle_wrapper","decompose_hint","lte_hint","field_less_than","build_msg_block","attach_len_to_msg_block","get_random_bytes","get_random_bytes","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","directive_invert","directive_to_radix","directive_integer_quotient"]},{"name":"update_verification_root","hash":"2235908299686008197","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_root","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+VZzY7jRBBuJ3F+x5uwCInHsGeSyc4taGcYTnDggDh6EwdFWnZRZvg5IXPjzoXHAAmJl+DCWyAkJA6ICxfSk67ky+eyJ9nYq11tSVHb7uqqr6urqqs7ntmS59oGvRuFZ+La8DiKSpQVqkCLSHg67qHj3mvQXy9xsh3SW6b8R+HwoqPMr0T8Zx0ns0r7iMwK5IctJ+eDdCuf52IpcO/oQzKmvfqdmO3zQ/fcoTFVrG2Ftg/fVvDXYG6WHqeV6D4T+Zcg35Q4N5F/VQ3+jfz3q8G/yRvX1eCPembty8+cPOvfA/ccf/X5R19Mn8+S92azZXJzgzHB/lhEh8isHyDzXZb54ZdPny7mi2R59c3i5jYjW9vc5LlG32o5uPA7kk86BJu17S1g7jPmj5Nns2T5oqbltGlp4trwSApoSohH9PrwvUS3HHqkz5isa6D+rskucZlh4pE+wcP2kXUT2zUVrAOlD+eGfainqeh5WbJ4vS1NXBseRqf8IVAwsZ+1CNML6mYa7etnor+bY6NJOXg2ftYiPHlrJrZrK1gHSh/7RlvR01b0vE6yxEcDk/VZL6cVPfyN9WC+a5CeRol6MI81SU+zRD0oS0ok0dMqUQ/KukzXrcQ2ruvEteFxtDlO4LGrxDiNxUZdkyXp64Fu9skT6GM/CqCP1/4B9LWorw99GA9MdXpHO9lxX4Nc5hN60+1bVJ+VYd++ogf3QJTZUHBZukzXrU/8n7pW1rAL48s8Gj0EuYZ0VXykvQhozkiBMm/2H/Qt9h/0LfYf9C1cLybNR8QW1kd+BrnMJ6T5CPoC7311k/UROVb2lfF+Dj5f4eX9W9739U3hX7jW2uBP91zBscmKfCcj8vb5Mv4s+WS5uE14AB8Hea/3FD4m5GM5mLOPBpdnlTxw1tk3ySTdjisrIMePwlAw1Z1832SDAPX7xH/j3jFopW0cgXM+jqP5WTyPR/FsNpzGnLTQbr0K9D9JouRsPp+fJfFwfj6/Vz/e1UjQagc26WsRTnlGh8PvWqHmE/+3rq24CFA3kA7NoQVz0A5Kj2kOwv+jay3vd2bXZk3SgX1ozxr1aQeavoKb10F8yjf6YYfnIPzfu9by/uWeZcOQuMH5VBnjKxpaHH8DDsR6hz/dnXcP+uoKP2Zz3HiRHzdqsdnAZDdqn2RpGyPa/Jqwig2bCj/K84n/B9da3qa3iw/9ukvYtcJP+uqKXu3g2AHMP7nnjtFzxsS9h8fRWDs8CmmXFR71YZzwJQcXqtinFWyegkErvMQWhxZeZeSJBul7VeIWC2eOW4zRusLPcXtfnF+l63ZgsmvJ/q3tBYfEjKVr0qcVYRgzvO9qF0syBzvuF5CH64j5Hcdyfhf+3wDLr+65b/R8hn3ol+x7fJGKfZpfavsX+z2ufZE/aBfMwldxLTHU9iOPdPeq0b33JbPo7xo9303KwRMVxaV2ySz2OalobQRPoODR6oG3zPqihtcM8YksbT/UcgnnGcwlvDfj2nGe0XKJxVhUq3skS8sTWtxpf+xgXpE8x7Xv76614/9wz1p+4LyC+YHzCsct9qEfc+2r1XTaRX+Rj2h1nuhG/wj2kNUq0P1A4Q8KdCMuHMu68/xYqwnENhXXBCOtJsB8wTVBUW1uaR9baus4IH60nRbHHI+ot0d9GH+cG9BPxX8xXrgGwHjEGqDs+4LwdDY9T05XVyrj8+j0Yvay7yumo/Mn0+EoDpPoDs19+uXirplu+9GfLbXcu5zhmR8vHpH/H+Fd/f51z+IbvqLP8vlePp+X097JUL410t1vnTTLX0+z/KK7m2YxSl8P+jDWLJ24d7QXyhIcPvHXnABZkzaMkfEDRX+b9O/gVr7xLWxP4e8p/HZ9/hN5rsW5l10D3ekk+fiNsYnvVBFXq5AaT+NxFF0Mo2QYje6Lq/8BvhtN3r0rAAA=","debug_symbols":"7Z3bbuM4DED/xc95ECnq1l9ZLAZpmw4CBGmRtgssiv772rvxZWImGlPewRTiSxEXPBV9LDukm1gfzePu/v37t/3x6fm1ufvjozk8P2zf9s/Hduvjc9Pcn/aHw/77t+mvG9P9gPRv/OvL9thtvr5tT2/NHVgkt2l2x8futY2m/RtP+8OuuUvhczMPN4h9tCEcg4kJpmTCOZgS+CHYIxMcieI5OJKnafCfmwbNKsmn1EcDpF+XPKySvIuD+ZgxDy70yYO39nbyyVk6B6eWu0weV04e8IfkuyHs/z8EcUMgDXvejjUyDpgBnInmHNy+jJkJ4aDPPTprLp06PhuIQzaTg8ZmA8bbcS6PweA8Ox98/5fNuJsWIhMb0qA9pDRGY+TysK6/HtDkJEHDxSIk6NNAkzLRDvuTdSqwi+0MejVYaDCowUKDUQ0WGkxqsMygNWqw0CCowUKDqAYLDVo1WGiQ1GChQe1JSg1qT1JqUHuSnzCY+ls7HtzMoPYkpQa1Jyk0SNqTlBrUnqTUoPYkpQa1Jyk1SGqw0KD2JKUGtScpNag9SalB7UlKDWpPUmjQaU9SalB7kkuDnRXtMzgr2jtwVkitMFa0xuesaN3OWdFanLOi9TVnRWtmxorXOpizorUtZ0VrW85KpbUtxv4f92gnefRWSK0wViqtbTNWKq1tM1YqrW0zViqtbTNWKq1tb1sJlda2GSuV1rYZK5XWthkrWttyVkitMFa0tuWsaG3LWdHalrOitS1nRWtbxkrU2pazorUtZ0VrW86K1racFarTSoAhjXDxPbRl0Z3DSivhRQ7B+/7pOeBDnDmstG5e1WGlVfaqDiutyVd1WGkFv8xhCMMehjR7X06V1vurOqy0O1jVYaW9xKoOK+08VnVI6rDYofYp5Q61Tyl3qH1KuUPtU8odap/yEw6TGZ6ZnXDmEIw2KitIXKFTgTg8/hrJZSQ6l/oO3kccn1feHk5Oo+8/EB0m3T5491/y+JWTt185efrKyfPVqAv9SYjtYLeTX/GJ7O01iHfpR5e5dIBMv8NAGH7YYyYfjP2eRmsok7yJQ/Jg/e1gAG+GRRrAk53ta/i993VYpSEC0iz5WM+BurLqxXQNDj/7oj5cWW4iR/HrPIAdbvUCxTllRRSJKCeiPE/50XxkbFxZLGV4QkL7cj6WNSIKRBSKKCuiSEQ5EcUfL4fDUXYU5lQQUVFEJQnFPxUxS4GIQhHFzw3nh9rVxTSnSEQ5EeVFVBBRUUQlCeWMiLpyBRh7DYvz88tZEUUiyokoL6KCiIoiKkkob0QUiCjR3PCiueGvzA2igXLzq413IsqLqCCioohKEioYESWqHIKocgiiyiGIKgf+066B+pItkJ8zbH7jDaDkmHFIwDgB4wVMEDBRwKTlTBL1JUnUl/D/gc5SVkSRiHIiyouoIKKiiEoCCo0RUSCiUETR4qsL8nerxiUiEzLM8rMeTVo+DhgBAwIGBczyqzICCRgnYPjjM9wYSGE+dyAImChgcldlhuHvFt12wN8ryjAoYATzAAXzAAXzAAXnKQYBEwXM8ndntEvnwWe7+df2tN/eH3bnZYSf3o8Pk1WF3/5+2V0sMPxyen7YPb6fdt1Sw+Mqw93YSGaDHrr3kG4TwGwAXLfZzTZsJz56akdtR/4H","names":["update_verification_root"],"brillig_names":["update_verification_root"]},{"name":"public_dispatch","hash":"2297429781745112439","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"sync_notes","hash":"12130747433433909573","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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TXewvub5dH0PT7xuOd3B+oTadAe7n9emO1h6WJuuzDXdqboq38OTa1tOd6quyvfwRNWW052rq+rhSZ8tpztXV9XDEyhbTneurqqHJyO2nO5cXVUPT+xrOd25uqoeniTXcrpzdVU9POGs5XTn6qp6ePJWy+nO1VX18ESoltOdq6vq4UlFLac7V1fVwxN0Wk53rq6qhye7tJzuXF1VD08caTndubqqHp6E0XK6c3VVPTyhoeV05+qqenhyQMvpztVV9bCjfcvpztVV9bDTesvpztVV9bADeMvpztVVyVxdlczVVclcXZXM1VWtc3VV61xd1TpXV9XDUyxaTlfmmu5cXdVYz5GoT3eurmqs50jUpztXVzXWcyTq052rqxrsORLV6c7VVQ32rIfqdOfqqgZ7HkN1unN1VYM9M6E63bm6qsGea1Cd7lxd1WDPHqhOd66uarCnCVSnO1dXNdjTBKrTnaurGuxpAtXpztVVjbbrf226c3VVo+2iX5vuXF3VaLvS16Y7V1c12i7vtenO1VWNtmt6bbpzdVWj7UJem+5cXdVou3rXpjtXV1VkrunO1VXNtbe6n2tvdT/X3up+rr3Vw1x7q4e59lYPc+2tHubaWz0sMtd0p+qqwmh7q7/sOUdxO9Ytv2Z1d/CVI48kbMORZxK24chDCZtwHG3/ejWOPJawDcdpHgt+na7MNd1pHrN9ne40zed1utP0iNfpTtPKXac7Tcf1e7qjbUFfm+40/ct1utM8/vg63bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvTnaurGm0L+tp05+qqRtuCvjbdubqq0bagr013rq5qtC3oa9Odq6sabQv62nTn6qpG24K+Nt25uqrRtqCvTXeurmq0Lehr052rqxptC/radOfqqkbbgr423bm6qtG2oK9Nd66uarQt6GvT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9zXG24je/lmreZHU4LNm5fd2rtx+r3j31ZA95UtlnrnmZaK5uonm6ieaa5horjLRXNeJ5honmmuaaK4T9U15or6pTNQ3lYn6pjJR31Qm6pvKRH1TmahvKhP1TWWivqlM1DeVefomWebpm2QZqG/y4TZX8QdzHahvqs51oL6pOteB7q/VuQ50Ha78BkPcQNfh6lwHug5X5zrQdbg614Guw9W5ykRzHci/Vuc60P21OteB/Gt1rgP519pc/UC9ROVBTeIH6iWqcx2ol6jOdSRP93w/cfED9RLVuQ7US1TnOpJXr811oF6iOteBeonqXAfKYGpzDQP1TdW5jpSF1+Y6UhZem+tEfVN4/29ynv9OQML7fyewa3X5sxyM6O2/yans/CehWBuRLOZG5MyNyJsbUTA3IjH2KyGR1dyIorkRWfttl0g2N6JibUTrYm5EztyIjvcZW/y+39USv+4iKA+2nq+ddrwbgXNh36DPST44zZ07zZ87LZw7TY5PizsSl4+QPHiKQrk9RaEcvVs+d1o5dVpazp3mzp3mz50Wzp12rNvqd7nvH9R1O209d1o8d1o6d1o+d1o5ddqjTfxrpx1XyXp71MOaD76p92AT/+pp4dxpcu609dxp8dxp6dxp+dRp5dEjcfbTgj/4vD3a+792mj93Wjh3mpw7bT13Wjx3Wjp3Wj53Wjlz2ros505z5057UCX7QxddWNPBaeHcaXLutPXcafHcaencafncaacajNUt505z50471WCsx8ld2rcPvLRXX086Do5ugWhZD97pONupneTPnBTOnCRnTlrPnBTPnJTOmJNV8rnTTlmh9cFj0KqnuXOn+XOnhXOnybnT1nOnxXOnnauSc4Z5PXa+lWvHse8tu6Uv/uikM5eB483Uau8Uz5yUzpyUz5xUToBIZy7X6czl+tjllj0uKOmgjI49bu0kOXNS7XJ9eNKZy/Wxt62dlM+cdKYi8pmKyGcqIp/55OYzN/B85gaez9zA808r4r8u//r//uO//+0f/+nv//Ifl1N+/d//86///J9/+7d//fjX//z//vf2f/7p3//297//7X/9w//+93/753/5H//n3//lH/7+b//86//9Zfn4x39Pv1aqkw/rZTi/RLl0f+tfL71cuPx7+P3/l+Xy/93y6///OuES0ZS/XgIX+fUffp9xWeC+HLGGy9gu4/v/AQ==","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"read_root","hash":"5103062043635837095","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"addr","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"root_struct::RootStruct","fields":[{"name":"root","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2896122431943215824":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3367683922240523006":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5870202753060865374":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"6336853191198150230":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8830323656616886390":{"error_kind":"string","string":"Got a public log emitted by a different contract"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"12822839658937144934":{"error_kind":"fmtstring","length":75,"item_types":[]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15366650908120444287":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"17879506016437779469":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"18194595712952743247":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","names":["read_root"],"brillig_names":["read_root"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PrivateRegister::verify_note_in_merkle_tree_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateRegister::verify_note_in_merkle_tree_parameters","fields":[{"name":"claim_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"siblings","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"indices","type":{"kind":"array","length":5,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"expected_root","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PrivateRegister::add_credential_note_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateRegister::add_credential_note_parameters","fields":[{"name":"flag","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"claim","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PrivateRegister::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateRegister::constructor_parameters","fields":[]}}]},{"kind":"struct","path":"PrivateRegister::init_credential_note_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateRegister::init_credential_note_parameters","fields":[{"name":"flag","type":{"kind":"integer","sign":"unsigned","width":8}}]}}]},{"kind":"struct","path":"PrivateRegister::update_verification_root_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateRegister::update_verification_root_parameters","fields":[{"name":"new_root","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PrivateRegister"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"root","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"credentials","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"CredentialNotes"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"claim_type","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"claim_hash","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use dep::aztec::{\n    macros::notes::note, oracle::random::random, protocol_types::{address::AztecAddress, traits::{Packable,ToField}},\n};\n\n#[note]\n#[derive(Eq)]\npub struct CredentialNotes {\n    owner: AztecAddress,\n    claim_type: u8,\n    claim_hash: Field,\n    randomness: Field,\n}\n\nimpl CredentialNotes {\n    pub fn new(owner: AztecAddress, claim_type: u8, claim_hash: Field) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { owner, claim_type, claim_hash, randomness }\n    }\n\n    pub fn to_fields(self) -> [Field; 4] {\n        [\n            self.owner.to_field(),\n            self.claim_type.to_field(),\n            self.claim_hash,\n            self.randomness,\n        ]\n    }\n}","path":"/Users/ouyildiz/Desktop/noir/react-box/src/contracts/src/credential_notes.nr"},"51":{"source":"mod credential_notes;\nmod root_struct;\nuse dep::aztec::macros::aztec;\n\n\n#[aztec]\npub contract PrivateRegister {\n\n    use crate::credential_notes::CredentialNotes;\n    use crate::root_struct::RootStruct;\n    use aztec::{\n        macros::{functions::{initializer, private, public, utility}, storage::storage},\n        messages::logs::note::encode_and_encrypt_note,\n        note::note_interface::{NoteProperties, NoteType},\n        prelude::{AztecAddress, Map,  PublicMutable, PrivateMutable, PrivateSet, NoteViewerOptions, NoteGetterOptions, RetrievedNote},\n        protocol_types::{ traits::{ToField, Serialize}, hash::poseidon2_hash as poseidon2},\n        utils::comparison::Comparator,\n    };\n\n    global AGE    : Field = 1;\n    global STUDENT: Field = 2;\n    global WID    : Field = 3;\n    global SOCIAL : Field = 4;\n    global EVM   : Field = 5;\n\n\n\n    #[storage]\n    struct Storage<Context> {\n        root       : Map<AztecAddress, PublicMutable<RootStruct, Context>, Context>,\n        credentials   : Map<AztecAddress, PrivateSet<CredentialNotes, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {\n\n    } \n\n    // A function add_claim\n    #[private]\n    fn init_credential_note(flag: u8) {\n        let credential_note = CredentialNotes::new(context.msg_sender(), flag, 0);\n        storage.credentials.at(context.msg_sender()).insert(credential_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n    }\n\n    #[private]\n    fn add_credential_note(flag: u8, claim:Field) {\n        let mut options = NoteGetterOptions::new()\n        .select(\n            CredentialNotes::properties().claim_type,\n            Comparator.EQ,\n            flag,\n        )                      \n        .set_limit(1);  \n\n        let old = storage.credentials.at(context.msg_sender()).pop_notes(options);   \n\n        if old.len() > 0 {\n            assert(old.get(0).claim_hash == 0);\n        }\n\n\n        let credential_note = CredentialNotes::new(context.msg_sender(), flag, claim);\n        storage.credentials.at(context.msg_sender()).insert(credential_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n    }\n\n    // Update_root\n    #[public]\n    fn update_verification_root(new_root: Field) {\n        let current_root_loc = storage.root.at(context.msg_sender());\n  \n        current_root_loc.write(\n            RootStruct {\n                root: new_root,\n                owner: context.msg_sender()\n            },\n        );\n    }\n\n    #[private]\n    fn verify_note_in_merkle_tree(\n        claim_type: u8,\n        siblings: [Field; 5],\n        indices: [u8; 5],\n        expected_root: Field,\n    ) {\n        let mut options = NoteGetterOptions::new();\n        let notes = storage.credentials.at(context.msg_sender()).get_notes(options.select(CredentialNotes::properties().claim_type, Comparator.EQ, claim_type).set_offset(0));\n\n        let rn = notes.get(0).note;\n\n        let leaf = poseidon2(rn.to_fields());\n\n        let mut node = leaf;\n        // Iterate through the Merkle proof up to MAX_DEPTH\n        for i in 0..5 {\n            // Only compute hash if the current level is within the tree depth\n            if i < 3 {\n                let sibling = siblings[i];\n\n                // Determine the ordering of node and sibling based on the index bit\n                // If indices[i] == 0, node is on the left; otherwise, it's on the right\n                let (left, right) = if indices[i] == 0 {\n                    (node, sibling)\n                } else {\n                    (sibling, node)\n                };\n\n                // Hash the pair to move one level up the tree\n                node = poseidon2([left, right]);\n            }\n        }\n\n        // Return the root computed\n        assert(node == expected_root, \"Merkle root verification failed\");\n    }\n\n\n    #[utility]\n    unconstrained fn read_credential(claim_type:u8, addr: AztecAddress) -> CredentialNotes {\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.credentials.at(addr).view_notes(options.select(CredentialNotes::properties().claim_type, Comparator.EQ, claim_type).set_offset(0));\n        notes.get(0)\n    }\n\n    #[utility]\n    unconstrained fn read_all_credentials(addr:AztecAddress) -> BoundedVec<CredentialNotes, 10> {\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.credentials.at(addr).view_notes(options.select(CredentialNotes::properties().claim_type, Comparator.LT, 8 as u8));\n        notes\n    }\n\n    #[utility]\n    unconstrained fn read_root(addr: AztecAddress) -> RootStruct {\n        storage.root.at(addr).read()\n    }\n\n    #[utility]\n    unconstrained fn read_credential_hash(claim_type:u8, addr: AztecAddress) -> Field {\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.credentials.at(addr).view_notes(options.select(CredentialNotes::properties().claim_type, Comparator.EQ, claim_type).set_offset(0));\n        poseidon2(notes.get(0).to_fields())\n    }\n\n}\n","path":"/Users/ouyildiz/Desktop/noir/react-box/src/contracts/src/main.nr"},"53":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"61":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"62":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"64":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"68":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"83":{"source":"use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr"},"84":{"source":"use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr"},"85":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"89":{"source":"use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"90":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"94":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"97":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"99":{"source":"use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"100":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"102":{"source":"use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"103":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"104":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"106":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr"},"107":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"108":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"109":{"source":"use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"116":{"source":"use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr"},"117":{"source":"use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr"},"122":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"124":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"127":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"130":{"source":"use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"131":{"source":"use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteType;\nuse dep::protocol_types::traits::{Packable, ToField};\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteType + Packable<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr"},"133":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"137":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"139":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"141":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"146":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"147":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"148":{"source":"use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"149":{"source":"use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr"},"151":{"source":"use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"152":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"153":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"154":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"156":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"162":{"source":"use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:insert\n    pub fn insert<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS, let N: u32>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes<let N: u32>(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable<N>,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"165":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"179":{"source":"/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"180":{"source":"/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr"},"182":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"183":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"184":{"source":"struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr"},"185":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"186":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"188":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"190":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"191":{"source":"use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/random.nr"},"201":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"218":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr"},"220":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"263":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"280":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"281":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"282":{"source":"use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr"},"295":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"297":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"298":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"307":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"318":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"332":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"336":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"337":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"353":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"354":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"356":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"366":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/ouyildiz/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"}}}